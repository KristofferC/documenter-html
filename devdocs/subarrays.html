<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>SubArrays · Julia language documentation</title><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../assets/debug.js"></script></head><body><nav class="toc"><a href><img class="logo" src="../logo.png" alt="Julia language logo"/></a><h1>Julia language</h1><input id="search-query" type="text" placeholder="Search docs"/><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../manual/arrays.html">Multi-dimensional Arrays</a></li><li><a class="toctext" href="../manual/calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="toctext" href="../manual/complex-and-rational-numbers.html">Complex and Rational Numbers</a></li><li><a class="toctext" href="../manual/constructors.html">Constructors</a></li><li><a class="toctext" href="../manual/control-flow.html">Control Flow</a></li><li><a class="toctext" href="../manual/conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="toctext" href="../manual/dates.html">Date and DateTime</a></li><li><a class="toctext" href="../manual/documentation.html">Documentation</a></li><li><a class="toctext" href="../manual/embedding.html">Embedding Julia</a></li><li><a class="toctext" href="../manual/faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="../manual/functions.html">Functions</a></li><li><a class="toctext" href="../manual/getting-started.html">Getting Started</a></li><li><a class="toctext" href="../manual/handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="../manual/index.html">The Julia Manual</a></li><li><a class="toctext" href="../manual/integers-and-floating-point-numbers.html">Integers and Floating-Point Numbers</a></li><li><a class="toctext" href="../manual/interacting-with-julia.html">Interacting With Julia</a></li><li><a class="toctext" href="../manual/interfaces.html">Interfaces</a></li><li><a class="toctext" href="../manual/introduction.html">Introduction</a></li><li><a class="toctext" href="../manual/linear-algebra.html">Linear algebra</a></li><li><a class="toctext" href="../manual/mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="../manual/metaprogramming.html">Metaprogramming</a></li><li><a class="toctext" href="../manual/methods.html">Methods</a></li><li><a class="toctext" href="../manual/modules.html">Modules</a></li><li><a class="toctext" href="../manual/networking-and-streams.html">Networking and Streams</a></li><li><a class="toctext" href="../manual/noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="../manual/packages.html">Packages</a></li><li><a class="toctext" href="../manual/parallel-computing.html">Parallel Computing</a></li><li><a class="toctext" href="../manual/performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="../manual/profile.html">Profiling</a></li><li><a class="toctext" href="../manual/running-external-programs.html">Running External Programs</a></li><li><a class="toctext" href="../manual/stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="../manual/strings.html">Strings</a></li><li><a class="toctext" href="../manual/style-guide.html">Style Guide</a></li><li><a class="toctext" href="../manual/types.html">Types</a></li><li><a class="toctext" href="../manual/unicode-input.html">Unicode Input</a></li><li><a class="toctext" href="../manual/variables-and-scoping.html">Scope of Variables</a></li><li><a class="toctext" href="../manual/variables.html">Variables</a></li><li><a class="toctext" href="../manual/workflow-tips.html">Workflow Tips</a></li></ul></li><li><span class="toctext">Standard Libary</span><ul><li><a class="toctext" href="../stdlib/arrays.html">Arrays</a></li><li><a class="toctext" href="../stdlib/base.html">Essentials</a></li><li><a class="toctext" href="../stdlib/c.html">C Interface</a></li><li><a class="toctext" href="../stdlib/collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="../stdlib/constants.html">Constants</a></li><li><a class="toctext" href="../stdlib/dates.html">Dates and Time</a></li><li><a class="toctext" href="../stdlib/file.html">Filesystem</a></li><li><a class="toctext" href="../stdlib/index.html">The Julia Standard Library</a></li><li><a class="toctext" href="../stdlib/io-network.html">I/O and Network</a></li><li><a class="toctext" href="../stdlib/libc.html">C Standard Library</a></li><li><a class="toctext" href="../stdlib/libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="../stdlib/linalg.html">Linear Algebra</a></li><li><a class="toctext" href="../stdlib/math.html">Mathematics</a></li><li><a class="toctext" href="../stdlib/numbers.html">Numbers</a></li><li><a class="toctext" href="../stdlib/parallel.html">Tasks and Parallel Computing</a></li><li><a class="toctext" href="../stdlib/pkg.html">Package Manager Functions</a></li><li><a class="toctext" href="../stdlib/profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/punctuation.html">Punctuation</a></li><li><a class="toctext" href="../stdlib/simd-types.html">SIMD Support</a></li><li><a class="toctext" href="../stdlib/sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="../stdlib/stacktraces.html">StackTraces</a></li><li><a class="toctext" href="../stdlib/strings.html">Strings</a></li><li><a class="toctext" href="../stdlib/test.html">Unit Testing</a></li></ul></li><li><span class="toctext">DevDocs</span><ul><li><a class="toctext" href="C.html">Developing/debugging Julia&#39;s C code</a></li><li><a class="toctext" href="ast.html">Julia ASTs</a></li><li><a class="toctext" href="backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="callconv.html">Calling Conventions</a></li><li><a class="toctext" href="cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="eval.html">Eval of Julia code</a></li><li><a class="toctext" href="functions.html">Julia Functions</a></li><li><a class="toctext" href="init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="julia.html">Documentation of Julia&#39;s Internals</a></li><li><a class="toctext" href="llvm.html">Working with LLVM</a></li><li><a class="toctext" href="locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="promote-op.html">Operator-sensitive promotion</a></li><li><a class="toctext" href="reflection.html">Reflection and introspection</a></li><li><a class="toctext" href="stdio.html">printf() and stdio in the Julia runtime</a></li><li class="current"><a class="toctext" href="subarrays.html">SubArrays</a><ul class="internal"><li><a class="toctext" href="#Indexing:-cartesian-vs.-linear-indexing-1">Indexing: cartesian vs. linear indexing</a></li><li><a class="toctext" href="#Index-replacement-1">Index replacement</a></li><li><a class="toctext" href="#SubArray-design-1">SubArray design</a></li></ul></li><li><a class="toctext" href="sysimg.html">System Image Building</a></li><li><a class="toctext" href="types.html">More about types</a></li><li><a class="toctext" href="valgrind.html">Using Valgrind with Julia</a></li></ul></li><li><span class="toctext">Dynamic pages</span><ul><li><a class="toctext" href="../dynamic/code.html">Code examples</a></li><li><a class="toctext" href="../dynamic/admonitions.html">Admonitions &amp; Co</a></li><li><a class="toctext" href="../dynamic/styles.html">Demonstrating <em>styles</em> of MD elements</a></li><li><a class="toctext" href="../dynamic/latex.html">The <span>$\sin(x^2)$</span> project</a></li><li><a class="toctext" href="../dynamic/bugs.html">Some existing bugs</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>DevDocs</li><li><a href="subarrays.html">SubArrays</a></li></ul><a class="edit-page" href="https://github.com/"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><a id="SubArrays-1"></a><h1>SubArrays</h1><p>Julia&#39;s <code>SubArray</code> type is a container encoding a &quot;view&quot; of a parent <code>AbstractArray</code>.  This page documents some of the design principles and implementation of <code>SubArray</code>s.</p><a id="Indexing:-cartesian-vs.-linear-indexing-1"></a><h2>Indexing: cartesian vs. linear indexing</h2><p>Broadly speaking, there are two main ways to access data in an array. The first, often called cartesian indexing, uses <code>N</code> indexes for an <code>N</code> -dimensional <code>AbstractArray</code>.  For example, a matrix <code>A</code> (2-dimensional) can be indexed in cartesian style as <code>A[i,j]</code>.  The second indexing method, referred to as linear indexing, uses a single index even for higher-dimensional objects.  For example, if <code>A = reshape(1:12, 3, 4)</code>, then the expression <code>A[5]</code> returns the value 5.  Julia allows you to combine these styles of indexing: for example, a 3d array <code>A3</code> can be indexed as <code>A3[i,j]</code>, in which case <code>i</code> is interpreted as a cartesian index for the first dimension, and <code>j</code> is a linear index over dimensions 2 and 3.</p><p>For <code>Array</code>s, linear indexing appeals to the underlying storage format: an array is laid out as a contiguous block of memory, and hence the linear index is just the offset (+1) of the corresponding entry relative to the beginning of the array.  However, this is not true for many other <code>AbstractArray</code> types: examples include <code>SparseMatrixCSC</code>, arrays that require some kind of computation (such as interpolation), and the type under discussion here, <code>SubArray</code>.  For these types, the underlying information is more naturally described in terms of cartesian indexes.</p><p>You can manually convert from a cartesian index to a linear index with <code>sub2ind</code>, and vice versa using <code>ind2sub</code>.  <code>getindex</code> and <code>setindex!</code> functions for <code>AbstractArray</code> types may include similar operations.</p><p>While converting from a cartesian index to a linear index is fast (it&#39;s just multiplication and addition), converting from a linear index to a cartesian index is very slow: it relies on the <code>div</code> operation, which is one of the slowest low-level operations you can perform with a CPU.  For this reason, any code that deals with <code>AbstractArray</code> types is best designed in terms of cartesian, rather than linear, indexing.</p><a id="Index-replacement-1"></a><h2>Index replacement</h2><p>Consider making 2d slices of a 3d array:</p><pre><code class="language-julia">S1 = slice(A, :, 5, 2:6)
S2 = slice(A, 5, :, 2:6)</code></pre><p><code>slice</code> drops &quot;singleton&quot; dimensions (ones that are specified by an <code>Int</code>), so both <code>S1</code> and <code>S2</code> are two-dimensional <code>SubArray</code>s. Consequently, the natural way to index these is with <code>S1[i,j]</code>.  To extract the value from the parent array <code>A</code>, the natural approach is to replace <code>S1[i,j]</code> with <code>A[i,5,(2:6)[j]]</code> and <code>S2[i,j]</code> with <code>A[5,i,(2:6)[j]]</code>.</p><p>The key feature of the design of SubArrays is that this index replacement can be performed without any runtime overhead.</p><a id="SubArray-design-1"></a><h2>SubArray design</h2><a id="Type-parameters-and-fields-1"></a><h3>Type parameters and fields</h3><p>The strategy adopted is first and foremost expressed in the definition of the type:</p><pre><code class="language-julia">type SubArray{T,N,P&lt;:AbstractArray,I&lt;:(ViewIndex...),LD} &lt;: AbstractArray{T,N}
    parent::P
    indexes::I
    dims::NTuple{N,Int}
    first_index::Int   # for linear indexing and pointer
    stride1::Int       # used only for linear indexing
end</code></pre><p><code>SubArray</code> has 5 type parameters.  The first two are the standard element type and dimensionality.  The next is the type of the parent <code>AbstractArray</code>.  The most heavily-used is the fourth parameter, a <code>tuple</code> of the types of the indexes for each dimension. The final one, <code>LD</code>, is used only in special circumstances, to implement efficient linear indexing for those types that can support it.</p><p>If in our example above <code>A</code> is a <code>Array{Float64, 3}</code>, our <code>S1</code> case above would be a <code>SubArray{Float64,2,Array{Float64,3},(Colon,Int64,UnitRange{Int64}),2}</code>. Note in particular the tuple parameter, which stores the types of the indexes used to create <code>S1</code>.  Likewise,</p><pre><code class="language-jlcon">julia&gt; S1.indexes
(Colon(),5,2:6)</code></pre><p>Storing these values allows index replacement, and having the types encoded as parameters allows one to dispatch to efficient algorithms.</p><p>An <code>Int</code> index is used to represent a parent dimension that should be dropped.  The distinction between the <code>sub</code> and <code>slice</code> commands is that <code>sub</code> converts <em>interior</em><code>Int</code> indices into ranges at the time of construction.  For example:</p><pre><code class="language-jlcon">S3 = sub(A, :, 5, 2:6)

julia&gt; S3.indexes
(Colon(),5:5,2:6)</code></pre><p>Because of this conversion, <code>S3</code> is three-dimensional.</p><a id="getindex-and-setindex!-(index-translation)-1"></a><h3><code>getindex</code> and <code>setindex!</code> (index translation)</h3><p>Performing index translation requires that you do different things for different concrete <code>SubArray</code> types.  For example, for <code>S1</code>, one needs to apply the <code>i,j</code> indexes to the first and third dimensions of the parent array, whereas for <code>S2</code> one needs to apply them to the second and third.  The simplest approach to indexing would be to do the type-analysis at runtime:</p><pre><code class="language-none">parentindexes = Array{Any}(0)
for i = 1:ndims(S.parent)
    ...
    if isa(thisindex, Int)
        # Don&#39;t consume one of the input indexes
        push!(parentindexes, thisindex)
    else
        # Consume an input index
        push!(parentindexes, thisindex[inputindex[j]])
        j += 1
    end
end
S.parent[parentindexes...]</code></pre><p>Unfortunately, this would be disastrous in terms of performance: each element access would allocate memory, and involves the running of a lot of poorly-typed code.</p><p>The better approach is to dispatch to specific methods to handle each type of input.  Note, however, that the number of distinct methods needed grows exponentially in the number of dimensions, and since Julia supports arrays of any dimension the number of methods required is in fact infinite.  Fortunately, <code>@generated function</code>s allow one to generate the necessary methods quite straightforwardly.  The resulting code looks quite a lot like the runtime approach above, but all of the type analysis is performed at the time of method instantiation.  For a <code>SubArray</code> of the type of <code>S1</code>, the method executed at runtime is literally</p><pre><code class="language-none">getindex(S::&lt;type of S1&gt;, i, j) = S.parent[i, S.indexes[2], S.indexes[3][j]]</code></pre><a id="Linear-indexing-1"></a><h3>Linear indexing</h3><p>Linear indexing can be implemented efficiently when the entire array has a single stride that separates successive elements.  For <code>SubArray</code> types, the availability of efficient linear indexing is based purely on the types of the indexes, and does not depend on values like the size of the array.  It therefore can miss some cases in which the stride happens to be uniform:</p><pre><code class="language-jlcon">julia&gt; A = reshape(1:4*2, 4, 2)
4×2 Array{Int64,2}:
 1  5
 2  6
 3  7
 4  8

julia&gt; diff(A[2:2:4,:][:])
3-element Array{Int64,1}:
 2
 2
 2</code></pre><p>A view constructed as <code>sub(A, 2:2:4, :)</code> happens to have uniform stride, and therefore linear indexing indeed could be performed efficiently.  However, success in this case depends on the size of the array: if the first dimension instead were odd,</p><pre><code class="language-jlcon">julia&gt; A = reshape(1:5*2, 5, 2)
5×2 Array{Int64,2}:
 1   6
 2   7
 3   8
 4   9
 5  10

julia&gt; diff(A[2:2:4,:][:])
3-element Array{Int64,1}:
 2
 3
 2</code></pre><p>then <code>A[2:2:4,:]</code> does not have uniform stride, so we cannot guarantee efficient linear indexing.  Since we have to base this decision based purely on types encoded in the parameters of the <code>SubArray</code>, <code>S = sub(A, 2:2:4, :)</code> cannot implement efficient linear indexing.</p><p>The last parameter of <code>SubArray</code>, <code>LD</code>, encodes the highest dimension up to which elements are guaranteed to have uniform stride. When <code>LD == length(I)</code>, the length of the <code>indexes</code> tuple, efficient linear indexing becomes possible.</p><p>An example might help clarify what this means:</p><ul><li><p>For <code>S1</code> above, the <code>Colon</code> along the first dimension is uniformly spaced (all elements are displaced by 1 from the previous value), so this dimension does not &quot;break&quot; linear indexing. Consequently <code>LD</code> has a value of at least 1.</p></li><li><p>The second dimension of the parent, sliced out as <code>5</code>, does not not by itself break linear indexing:  if all of the remaining indexes were <code>Int</code>, the entire <code>SubArray</code> would have efficient linear indexing.  Consequently, <code>LD</code> is at least 2.</p></li><li><p>The last dimension is a <code>Range</code>.  This would by itself break linear indexing (even though it is a <code>UnitRange</code>, the fact that it might not start at 1 means that there might be gaps).  Additionally, given the preceding indexes any choice other than <code>Int</code> would also have truncated <code>LD</code> at 2.</p></li></ul><p>Consequently, as a whole <code>S1</code> does not have efficient linear indexing.</p><p>However, if we were to later say <code>S1a = slice(S1, 2:2:7, 3)</code>, <code>S1a</code> would have an <code>LD</code> of 3 (its indexes tuple has type <code>(Colon, Int, Int)</code>) and would have efficient linear indexing.  This ability to re-slice is the main motivation to use an integer <code>LD</code> rather than a boolean flag to encode the applicability of linear indexing.</p><p>The main reason <code>LD</code> cannot always be inferred from the <code>indexes</code> tuple is because <code>sub</code> converts internal <code>Int</code> indexes into <code>UnitRange</code>s.  Consequently it is important to encode &quot;safe&quot; dimensions of size 1 prior to conversion.  Up to the <code>LD</code>th entry, we can be sure that any <code>UnitRange</code> was, in fact, an <code>Integer</code> prior to conversion.</p><a id="A-few-details-1"></a><h3>A few details</h3><ul><li><p>Hopefully by now it&#39;s fairly clear that supporting slices means that the dimensionality, given by the parameter <code>N</code>, is not necessarily equal to the dimensionality of the parent array or the length of the <code>indexes</code> tuple.  Neither do user-supplied indexes necessarily line up with entries in the <code>indexes</code> tuple (e.g., the second user-supplied index might correspond to the third dimension of the parent array, and the third element in the <code>indexes</code> tuple).</p><p>What might be less obvious is that the dimensionality of the parent array may not be equal to the length of the <code>indexes</code> tuple.  Some examples:</p><code>A = reshape(1:35, 5, 7) # A 2d parent Array
S = sub(A, 2:7)         # A 1d view created by linear indexing
S = sub(A, :, :, 1)     # Appending extra indexes is supported
S = sub(A, :, :, 1:1)</code><p>Consequently, internal <code>SubArray</code> code needs to be fairly careful about which of these three notions of dimensionality is relevant in each circumstance.</p></li><li><p>Because the processing needed to implement all of the <code>@generated</code> expressions isn&#39;t readily available at the time <code>subarray.jl</code> appears in the bootstrap process, <code>SubArray</code> functionality is split into two files, the second being <code>subarray2.jl</code>.</p></li><li><p>Bounds-checking has currently not been tackled. There are two relevant notions of bounds-checking, one at construction time and one during element access.  This is an important outstanding issue.</p></li></ul><footer><hr/><a class="previous" href="stdio.html"><span class="direction">Previous</span><span class="title">printf() and stdio in the Julia runtime</span></a><a class="next" href="sysimg.html"><span class="direction">Next</span><span class="title">System Image Building</span></a></footer></article></body></html>
