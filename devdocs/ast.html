<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Julia ASTs · Julia language documentation</title><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../assets/debug.js"></script></head><body><nav class="toc"><a href><img class="logo" src="../logo.png" alt="Julia language logo"/></a><h1>Julia language</h1><input id="search-query" type="text" placeholder="Search docs"/><ul><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../manual/arrays.html">Multi-dimensional Arrays</a></li><li><a class="toctext" href="../manual/calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="toctext" href="../manual/complex-and-rational-numbers.html">Complex and Rational Numbers</a></li><li><a class="toctext" href="../manual/constructors.html">Constructors</a></li><li><a class="toctext" href="../manual/control-flow.html">Control Flow</a></li><li><a class="toctext" href="../manual/conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="toctext" href="../manual/dates.html">Date and DateTime</a></li><li><a class="toctext" href="../manual/documentation.html">Documentation</a></li><li><a class="toctext" href="../manual/embedding.html">Embedding Julia</a></li><li><a class="toctext" href="../manual/faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="../manual/functions.html">Functions</a></li><li><a class="toctext" href="../manual/getting-started.html">Getting Started</a></li><li><a class="toctext" href="../manual/handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="../manual/index.html">The Julia Manual</a></li><li><a class="toctext" href="../manual/integers-and-floating-point-numbers.html">Integers and Floating-Point Numbers</a></li><li><a class="toctext" href="../manual/interacting-with-julia.html">Interacting With Julia</a></li><li><a class="toctext" href="../manual/interfaces.html">Interfaces</a></li><li><a class="toctext" href="../manual/introduction.html">Introduction</a></li><li><a class="toctext" href="../manual/linear-algebra.html">Linear algebra</a></li><li><a class="toctext" href="../manual/mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="../manual/metaprogramming.html">Metaprogramming</a></li><li><a class="toctext" href="../manual/methods.html">Methods</a></li><li><a class="toctext" href="../manual/modules.html">Modules</a></li><li><a class="toctext" href="../manual/networking-and-streams.html">Networking and Streams</a></li><li><a class="toctext" href="../manual/noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="../manual/packages.html">Packages</a></li><li><a class="toctext" href="../manual/parallel-computing.html">Parallel Computing</a></li><li><a class="toctext" href="../manual/performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="../manual/profile.html">Profiling</a></li><li><a class="toctext" href="../manual/running-external-programs.html">Running External Programs</a></li><li><a class="toctext" href="../manual/stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="../manual/strings.html">Strings</a></li><li><a class="toctext" href="../manual/style-guide.html">Style Guide</a></li><li><a class="toctext" href="../manual/types.html">Types</a></li><li><a class="toctext" href="../manual/unicode-input.html">Unicode Input</a></li><li><a class="toctext" href="../manual/variables-and-scoping.html">Scope of Variables</a></li><li><a class="toctext" href="../manual/variables.html">Variables</a></li><li><a class="toctext" href="../manual/workflow-tips.html">Workflow Tips</a></li></ul></li><li><span class="toctext">Standard Libary</span><ul><li><a class="toctext" href="../stdlib/arrays.html">Arrays</a></li><li><a class="toctext" href="../stdlib/base.html">Essentials</a></li><li><a class="toctext" href="../stdlib/c.html">C Interface</a></li><li><a class="toctext" href="../stdlib/collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="../stdlib/constants.html">Constants</a></li><li><a class="toctext" href="../stdlib/dates.html">Dates and Time</a></li><li><a class="toctext" href="../stdlib/file.html">Filesystem</a></li><li><a class="toctext" href="../stdlib/index.html">The Julia Standard Library</a></li><li><a class="toctext" href="../stdlib/io-network.html">I/O and Network</a></li><li><a class="toctext" href="../stdlib/libc.html">C Standard Library</a></li><li><a class="toctext" href="../stdlib/libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="../stdlib/linalg.html">Linear Algebra</a></li><li><a class="toctext" href="../stdlib/math.html">Mathematics</a></li><li><a class="toctext" href="../stdlib/numbers.html">Numbers</a></li><li><a class="toctext" href="../stdlib/parallel.html">Tasks and Parallel Computing</a></li><li><a class="toctext" href="../stdlib/pkg.html">Package Manager Functions</a></li><li><a class="toctext" href="../stdlib/profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/punctuation.html">Punctuation</a></li><li><a class="toctext" href="../stdlib/simd-types.html">SIMD Support</a></li><li><a class="toctext" href="../stdlib/sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="../stdlib/stacktraces.html">StackTraces</a></li><li><a class="toctext" href="../stdlib/strings.html">Strings</a></li><li><a class="toctext" href="../stdlib/test.html">Unit Testing</a></li></ul></li><li><span class="toctext">DevDocs</span><ul><li><a class="toctext" href="C.html">Developing/debugging Julia&#39;s C code</a></li><li class="current"><a class="toctext" href="ast.html">Julia ASTs</a><ul class="internal"><li><a class="toctext" href="#Lowered-form-1">Lowered form</a></li><li><a class="toctext" href="#Surface-syntax-AST-1">Surface syntax AST</a></li></ul></li><li><a class="toctext" href="backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="callconv.html">Calling Conventions</a></li><li><a class="toctext" href="cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="eval.html">Eval of Julia code</a></li><li><a class="toctext" href="functions.html">Julia Functions</a></li><li><a class="toctext" href="init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="julia.html">Documentation of Julia&#39;s Internals</a></li><li><a class="toctext" href="llvm.html">Working with LLVM</a></li><li><a class="toctext" href="locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="promote-op.html">Operator-sensitive promotion</a></li><li><a class="toctext" href="reflection.html">Reflection and introspection</a></li><li><a class="toctext" href="stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="subarrays.html">SubArrays</a></li><li><a class="toctext" href="sysimg.html">System Image Building</a></li><li><a class="toctext" href="types.html">More about types</a></li><li><a class="toctext" href="valgrind.html">Using Valgrind with Julia</a></li></ul></li><li><span class="toctext">Dynamic pages</span><ul><li><a class="toctext" href="../dynamic/code.html">Code examples</a></li><li><a class="toctext" href="../dynamic/admonitions.html">Admonitions &amp; Co</a></li><li><a class="toctext" href="../dynamic/styles.html">Demonstrating <em>styles</em> of MD elements</a></li><li><a class="toctext" href="../dynamic/latex.html">The <span>$\sin(x^2)$</span> project</a></li><li><a class="toctext" href="../dynamic/bugs.html">Some existing bugs</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>DevDocs</li><li><a href="ast.html">Julia ASTs</a></li></ul><a class="edit-page" href="https://github.com/"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><a id="Julia-ASTs-1"></a><h1>Julia ASTs</h1><p>Julia has two representations of code. First there is a surface syntax AST returned by the parser (e.g. the <a href="../stdlib/numbers.html#Base.parse"><code>parse()</code></a> function), and manipulated by macros. It is a structured representation of code as it is written, constructed by <code>julia-parser.scm</code> from a character stream. Next there is a lowered form, or IR (intermediate representation), which is used by type inference and code generation. In the lowered form there are fewer types of nodes, all macros are expanded, and all control flow is converted to explicit branches and sequences of statements. The lowered form is constructed by <code>julia-syntax.scm</code>.</p><p>First we will focus on the lowered form, since it is more important to the compiler. It is also less obvious to the human, since it results from a significant rearrangement of the input syntax.</p><a id="Lowered-form-1"></a><h2>Lowered form</h2><p>The following data types exist in lowered form:</p><ul><li><p><code>Expr</code></p><p>has a node type indicated by the <code>head</code> field, and an <code>args</code> field which is a <code>Vector{Any}</code> of subexpressions.</p></li><li><p><code>Slot</code></p><p>identifies arguments and local variables by consecutive numbering. <code>Slot</code> is an abstract type with subtypes <code>SlotNumber</code> and <code>TypedSlot</code>. Both types have an integer-valued <code>id</code> field giving the slot index. Most slots have the same type at all uses, and so are represented with <code>SlotNumber</code>. The types of these slots are found in the <code>slottypes</code> field of their <code>LambdaInfo</code> object. Slots that require per-use type annotations are represented with <code>TypedSlot</code>, which has a <code>typ</code> field.</p></li><li><p><code>LambdaInfo</code></p><p>wraps the IR of each method.</p></li><li><p><code>LineNumberNode</code></p><p>contains a single number, specifying the line number the next statement came from.</p></li><li><p><code>LabelNode</code></p><p>branch target, a consecutively-numbered integer starting at 0</p></li><li><p><code>GotoNode</code></p><p>unconditional branch</p></li><li><p><code>QuoteNode</code></p><p>wraps an arbitrary value to reference as data. For example, the function <code>f() = :a</code> contains a <code>QuoteNode</code> whose <code>value</code> field is the symbol <code>a</code>, in order to return the symbol itself instead of evaluating it.</p></li><li><p><code>GlobalRef</code></p><p>refers to global variable <code>name</code> in module <code>mod</code></p></li><li><p><code>SSAValue</code></p><p>refers to a consecutively-numbered (starting at 0) static single assignment (SSA) variable inserted by the compiler.</p></li><li><p><code>NewvarNode</code></p><p>Marks a point where a variable is created. This has the effect of resetting a variable to undefined.</p></li></ul><a id="Expr-types-1"></a><h3>Expr types</h3><p>These symbols appear in the <code>head</code> field of <code>Expr</code>s in lowered form.</p><ul><li><p><code>call</code></p><p>function call (dynamic dispatch). <code>args[1]</code> is the function to call, <code>args[2:end]</code> are the arguments.</p></li><li><p><code>invoke</code></p><p>function call (static dispatch). <code>args[1]</code> is the LambdaInfo to call, <code>args[2:end]</code> are the arguments (including the function that is being called, at <code>args[2]</code>).</p></li><li><p><code>static_parameter</code></p><p>reference a static parameter by index.</p></li><li><p><code>line</code></p><p>line number and file name metadata. Unlike a <code>LineNumberNode</code>, can also contain a file name.</p></li><li><p><code>gotoifnot</code></p><p>conditional branch. If <code>args[1]</code> is false, goes to label identified in <code>args[2]</code>.</p></li><li><p><code>=</code></p><p>assignment</p></li><li><p><code>method</code></p><p>adds a method to a generic function and assigns the result if necessary.</p><p>Has a 1-argument form and a 4-argument form. The 1-argument form arises from the syntax <code>function foo end</code>. In the 1-argument form, the argument is a symbol. If this symbol already names a function in the current scope, nothing happens. If the symbol is undefined, a new function is created and assigned to the identifier specified by the symbol. If the symbol is defined but names a non-function, an error is raised. The definition of &quot;names a function&quot; is that the binding is constant, and refers to an object of singleton type. The rationale for this is that an instance of a singleton type uniquely identifies the type to add the method to. When the type has fields, it wouldn&#39;t be clear whether the method was being added to the instance or its type.</p><p>The 4-argument form has the following arguments: <code>args[1]</code> - A function name, or <code>false</code> if unknown. If a symbol, then the expression first behaves like the 1-argument form above. This argument is ignored from then on. When this is <code>false</code>, it means a method is being added strictly by type, <code>(::T)(x) = x</code>.</p><p><code>args[2]</code> - a <code>SimpleVector</code> of argument type data. <code>args[2][1]</code> is a <code>Tuple</code> type of the argument types, and <code>args[2][2]</code> is a <code>SimpleVector</code> of type variables corresponding to the method&#39;s static parameters.</p><p><code>args[3]</code> - a <code>LambdaInfo</code> of the method itself. For &quot;out of scope&quot; method definitions (adding a method to a function that also has methods defined in different scopes) this is an expression that evaluates to a <code>:lambda</code> expression.</p><p><code>args[4]</code> - <code>true</code> or <code>false</code>, identifying whether the method is staged (<code>@generated function</code>)</p></li><li><p><code>const</code></p><p>declares a (global) variable as constant</p></li><li><p><code>null</code></p><p>has no arguments; simply yields the value <code>nothing</code></p></li><li><p><code>new</code></p><p>allocates a new struct-like object. First argument is the type. The <code>new</code> pseudo-function is lowered to this, and the type is always inserted by the compiler.  This is very much an internal-only feature, and does no checking. Evaluating arbitrary <code>new</code> expressions can easily segfault.</p></li><li><p><code>return</code></p><p>returns its argument as the value of the enclosing function.</p></li><li><p><code>the_exception</code></p><p>yields the caught exception inside a <code>catch</code> block. This is the value of the run time system variable <code>jl_exception_in_transit</code>.</p></li><li><p><code>enter</code></p><p>enters an exception handler (<code>setjmp</code>). <code>args[1]</code> is the label of the catch block to jump to on error.</p></li><li><p><code>leave</code></p><p>pop exception handlers. <code>args[1]</code> is the number of handlers to pop.</p></li><li><p><code>inbounds</code></p><p>controls turning bounds checks on or off. A stack is maintained; if the first argument of this expression is true or false (<code>true</code> means bounds checks are disabled), it is pushed onto the stack. If the first argument is <code>:pop</code>, the stack is popped.</p></li><li><p><code>boundscheck</code></p><p>indicates the beginning or end of a section of code that performs a bounds check. Like <code>inbounds</code>, a stack is maintained, and the second argument can be one of: <code>true</code>, <code>false</code>, or <code>:pop</code>.</p></li><li><p><code>copyast</code></p><p>part of the implementation of quasi-quote. The argument is a surface syntax AST that is simply copied recursively and returned at run time.</p></li><li><p><code>meta</code></p><p>metadata. <code>args[1]</code> is typically a symbol specifying the kind of metadata, and the rest of the arguments are free-form. The following kinds of metadata are commonly used:</p><p><code>:inline</code> and <code>:noinline</code>: Inlining hints.</p><ul><li><p><code>:push_loc</code>: enters a sequence of statements from a specified source location.</p><ul><li><p><code>args[2]</code> specifies a filename, as a symbol.</p></li><li><p><code>args[3]</code> optionally specifies the name of an (inlined) function that originally contained the code.</p></li></ul></li></ul><p><code>:pop_loc</code>: returns to the source location before the matching <code>:push_loc</code>.</p></li></ul><a id="LambdaInfo-1"></a><h3>LambdaInfo</h3><p><code>sparam_syms</code> - The names (symbols) of static parameters.</p><p><code>sparam_vals</code> - The values of the static parameters (once known), indexed by <code>sparam_syms</code>.</p><p><code>code</code> - An <code>Any</code> array of statements, or a UInt8 array with a compressed representation of the code.</p><p><code>slotnames</code> - An array of symbols giving the name of each slot (argument or local variable).</p><p><code>slottypes</code> - An array of types for the slots.</p><ul><li><p><code>slotflags</code> - A UInt8 array of slot properties, represented as bit flags:</p><ul><li><p>1  - captured (closed over)</p></li><li><p>2  - assigned (only false if there are <em>no</em> assignment statements with this var on the left)</p></li><li><p>4  - assigned by an inner function</p></li><li><p>8  - const (currently unused for local variables)</p></li><li><p>16 - statically assigned once</p></li><li><p>32 - might be used before assigned. This flag is only valid after type inference.</p></li></ul></li><li><p><code>ssavaluetypes</code> - Either an array or an Int giving the number of compiler-inserted</p><p>temporary locations in the function. If an array, specifies a type for each location.</p></li><li><p><code>nargs</code> - The number of argument slots. The first <code>nargs</code> entries of the slots</p><p>arrays refer to arguments.</p></li></ul><p><code>isva</code> - A boolean indicating whether the function is variadic.</p><a id="Surface-syntax-AST-1"></a><h2>Surface syntax AST</h2><p>Front end ASTs consist entirely of <code>Expr</code>s and atoms (e.g. symbols, numbers). There is generally a different expression head for each visually distinct syntactic form. Examples will be given in s-expression syntax. Each parenthesized list corresponds to an Expr, where the first element is the head. For example <code>(call f x)</code> corresponds to <code>Expr(:call, :f, :x)</code> in Julia.</p><a id="Calls-1"></a><h3>Calls</h3><table><tr><th>Input</th><th>AST</th></tr><tr><td>f(x)</td><td>(call f x)</td></tr><tr><td>f(x, y=1, z=2)</td><td>(call f x (kw y 1) (kw z 2))</td></tr><tr><td>f(x; y=1)</td><td>(call f (parameters (kw y 1)) x)</td></tr><tr><td>f(x...)</td><td>(call f (... x))</td></tr></table><p><code>Do</code> syntax:</p><pre><code class="language-julia">f(x) do a,b
    body
end</code></pre><p>parses as <code>(call f (-&gt; (tuple a b) (block body)) x)</code>.</p><a id="Operators-1"></a><h3>Operators</h3><p>Most uses of operators are just function calls, so they are parsed with the head <code>call</code>. However some operators are special forms (not necessarily function calls), and in those cases the operator itself is the expression head. In julia-parser.scm these are referred to as &quot;syntactic operators&quot;. Some operators (<code>+</code> and <code>*</code>) use N-ary parsing; chained calls are parsed as a single N-argument call. Finally, chains of comparisons have their own special expression structure.</p><table><tr><th>Input</th><th>AST</th></tr><tr><td>x+y</td><td>(call + x y)</td></tr><tr><td>a+b+c+d</td><td>(call + a b c d)</td></tr><tr><td>2x</td><td>(call * 2 x)</td></tr><tr><td>a&amp;&amp;b</td><td>(&amp;&amp; a b)</td></tr><tr><td>x += 1</td><td>(+= x 1)</td></tr><tr><td>a ? 1 : 2</td><td>(if a 1 2)</td></tr><tr><td>a:b</td><td>(: a b)</td></tr><tr><td>a:b:c</td><td>(: a b c)</td></tr><tr><td>a,b</td><td>(tuple a b)</td></tr><tr><td>a==b</td><td>(comparison a == b)</td></tr><tr><td>1&lt;i&lt;=n</td><td>(comparison 1 &lt; i &lt;= n)</td></tr><tr><td>a.b</td><td>(. a (quote b))</td></tr><tr><td>a.(b)</td><td>(. a b)</td></tr></table><a id="Bracketed-forms-1"></a><h3>Bracketed forms</h3><table><tr><th>Input</th><th>AST</th></tr><tr><td>a[i]</td><td>(ref a i)</td></tr><tr><td>t[i;j]</td><td>(typed_vcat t i j)</td></tr><tr><td>t[i j]</td><td>(typed_hcat t i j)</td></tr><tr><td>t[a b; c d]</td><td>(typed_vcat t (row a b) (row c d))</td></tr><tr><td>a{b}</td><td>(curly a b)</td></tr><tr><td>a{b;c}</td><td>(curly a (parameters c) b)</td></tr><tr><td>[x]</td><td>(vect x)</td></tr><tr><td>[x,y]</td><td>(vect x y)</td></tr><tr><td>[x;y]</td><td>(vcat x y)</td></tr><tr><td>[x y]</td><td>(hcat x y)</td></tr><tr><td>[x y; z t]</td><td>(vcat (row x y) (row z t))</td></tr><tr><td>[x for y in z, a in b]</td><td>(comprehension x (= y z) (= a b))</td></tr><tr><td>T[x for y in z]</td><td>(typed_comprehension T x (= y z))</td></tr><tr><td>(a, b, c)</td><td>(tuple a b c)</td></tr><tr><td>(a; b; c)</td><td>(block a (block b c))</td></tr></table><a id="Macros-1"></a><h3>Macros</h3><table><tr><th>Input</th><th>AST</th></tr><tr><td>@m x y</td><td>(macrocall @m x y)</td></tr><tr><td>Base.@m x y</td><td>(macrocall (. Base (quote @m)) x y)</td></tr><tr><td>@Base.m x y</td><td>(macrocall (. Base (quote @m)) x y)</td></tr></table><a id="Strings-1"></a><h3>Strings</h3><table><tr><th>Input</th><th>AST</th></tr><tr><td>&quot;a&quot;</td><td>&quot;a&quot;</td></tr><tr><td>x&quot;y&quot;</td><td>(macrocall @x_str &quot;y&quot;)</td></tr><tr><td>x&quot;y&quot;z</td><td>(macrocall @x_str &quot;y&quot; &quot;z&quot;)</td></tr><tr><td>&quot;x = x&quot;</td><td>(string &quot;x = &quot; x)</td></tr><tr><td><code>a b c</code></td><td>(macrocall @cmd &quot;a b c&quot;)</td></tr><tr><td>x ~ distr</td><td>(macrocall @~ x distr)</td></tr></table><p>Doc string syntax:</p><pre><code class="language-julia">&quot;some docs&quot;
f(x) = x</code></pre><p>parses as <code>(macrocall (|.| Base &#39;@doc) &quot;some docs&quot; (= (call f x) (block x)))</code></p><a id="Imports-and-such-1"></a><h3>Imports and such</h3><table><tr><th>Input</th><th>AST</th></tr><tr><td>import a</td><td>(import a)</td></tr><tr><td>import a.b.c</td><td>(import a b c)</td></tr><tr><td>import ...a</td><td>(import . . . a)</td></tr><tr><td>import a.b, c.d</td><td>(toplevel (import a b) (import c d))</td></tr><tr><td>import Base: x</td><td>(import Base x)</td></tr><tr><td>import Base: x, y</td><td>(toplevel (import Base x) (import Base y))</td></tr><tr><td>export a, b</td><td>(export a b)</td></tr></table><a id="Numbers-1"></a><h3>Numbers</h3><p>Julia supports more number types than many scheme implementations, so not all numbers are represented directly as scheme numbers in the AST.</p><table><tr><th>Input</th><th>AST</th></tr><tr><td>11111111111111111111</td><td>(macrocall @int128_str &quot;11111111111111111111&quot;)</td></tr><tr><td>0xfffffffffffffffff</td><td>(macrocall @uint128_str &quot;0xfffffffffffffffff&quot;)</td></tr><tr><td>1111...many digits...</td><td>(macrocall @big_str &quot;1111....&quot;)</td></tr></table><a id="Block-forms-1"></a><h3>Block forms</h3><p>A block of statements is parsed as <code>(block stmt1 stmt2 ...)</code>.</p><p>If statement:</p><pre><code class="language-julia">if a
    b
elseif c
    d
else e
    f
end</code></pre><p>parses as:</p><pre><code class="language-none">(if a (block (line 2) b)
    (block (line 3) (if c (block (line 4) d)
                        (block (line 5) e (line 6) f))))</code></pre><p>A <code>while</code> loop parses as <code>(while condition body)</code>.</p><p>A <code>for</code> loop parses as <code>(for (= var iter) body)</code>. If there is more than one iteration specification, they are parsed as a block: <code>(for (block (= v1 iter1) (= v2 iter2)) body)</code>.</p><p><code>break</code> and <code>continue</code> are parsed as 0-argument expressions <code>(break)</code> and <code>(continue)</code>.</p><p><code>let</code> is parsed as <code>(let body (= var1 val1) (= var2 val2) ...)</code>.</p><p>A basic function definition is parsed as <code>(function (call f x) body)</code>. A more complex example:</p><pre><code class="language-julia">function f{T}(x::T; k = 1)
    return x+1
end</code></pre><p>parses as:</p><pre><code class="language-none">(function (call (curly f T) (parameters (kw k 1))
                (:: x T))
          (block (line 2 file.jl) (return (call + x 1))))</code></pre><p>Type definition:</p><pre><code class="language-julia">type Foo{T&lt;:S}
    x::T
end</code></pre><p>parses as:</p><pre><code class="language-none">(type #t (curly Foo (&lt;: T S))
      (block (line 2 none) (:: x T)))</code></pre><p>The first argument is a boolean telling whether the type is mutable.</p><p><code>try</code> blocks parse as <code>(try try_block var catch_block finally_block)</code>. If no variable is present after <code>catch</code>, <code>var</code> is <code>#f</code>. If there is no <code>finally</code> clause, then the last argument is not present.</p><footer><hr/><a class="previous" href="C.html"><span class="direction">Previous</span><span class="title">Developing/debugging Julia&#39;s C code</span></a><a class="next" href="backtraces.html"><span class="direction">Next</span><span class="title">Reporting and analyzing crashes (segfaults)</span></a></footer></article></body></html>
