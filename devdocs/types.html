<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Documenter.jl</title><link href="../normalize.css" rel="stylesheet" type="text/css"/><link href="../style.css" rel="stylesheet" type="text/css"/><link href="../highlight.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="../require.js" data-main="../documenter.js"></script><script src="../search-index.js"></script></head><body><nav class="toc"><a href="http://julialang.org/"><img class="logo" src="http://docs.julialang.org/en/release-0.4/_static/julia-logo.svg" alt="\$pkgname.jl logo"/></a><h1>$pkgname.jl</h1><input type="text" placeholder="Search docs"/><ul><li><a class="toctext" href="../index.html">Overview</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../man/guide.html">Guide</a></li><li><a class="toctext" href="../man/examples.html">Examples</a></li><li><a class="toctext" href="../man/syntax.html">Syntax</a></li><li><a class="toctext" href="../man/doctests.html">Doctests</a></li><li><a class="toctext" href="../man/hosting.html">Hosting Documentation</a></li><li><a class="toctext" href="../man/latex.html"><span>$\LaTeX$</span> syntax</a></li><li><a class="toctext" href="../man/internals.html">Package Internals</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../lib/public.html">Public Documentation</a></li><li><a class="toctext" href="../lib/internals.html">Internal Documentation</a></li></ul></li><li><span class="toctext">Dynamic pages</span><ul><li><a class="toctext" href="../dynamic/code.html">Code examples</a></li><li><a class="toctext" href="../dynamic/admonitions.html">Admonitions &amp; Co</a></li><li><a class="toctext" href="../dynamic/styles.html">Demonstrating <em>styles</em> of MD elements</a></li><li><a class="toctext" href="../dynamic/bugs.html">Some existing bugs</a></li></ul></li><li><span class="toctext">JuliaDocs - Manual</span><ul><li><a class="toctext" href="../manual/arrays.html">Multi-dimensional Arrays</a></li><li><a class="toctext" href="../manual/calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="toctext" href="../manual/complex-and-rational-numbers.html">Complex and Rational Numbers</a></li><li><a class="toctext" href="../manual/constructors.html">Constructors</a></li><li><a class="toctext" href="../manual/control-flow.html">Control Flow</a></li><li><a class="toctext" href="../manual/conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="toctext" href="../manual/dates.html">Date and DateTime</a></li><li><a class="toctext" href="../manual/documentation.html">Documentation</a></li><li><a class="toctext" href="../manual/embedding.html">Embedding Julia</a></li><li><a class="toctext" href="../manual/faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="../manual/functions.html">Functions</a></li><li><a class="toctext" href="../manual/getting-started.html">Getting Started</a></li><li><a class="toctext" href="../manual/handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="../manual/index.html">The Julia Manual</a></li><li><a class="toctext" href="../manual/integers-and-floating-point-numbers.html">Integers and Floating-Point Numbers</a></li><li><a class="toctext" href="../manual/interacting-with-julia.html">Interacting With Julia</a></li><li><a class="toctext" href="../manual/interfaces.html">Interfaces</a></li><li><a class="toctext" href="../manual/introduction.html">Introduction</a></li><li><a class="toctext" href="../manual/linear-algebra.html">Linear algebra</a></li><li><a class="toctext" href="../manual/mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="../manual/metaprogramming.html">Metaprogramming</a></li><li><a class="toctext" href="../manual/methods.html">Methods</a></li><li><a class="toctext" href="../manual/modules.html">Modules</a></li><li><a class="toctext" href="../manual/networking-and-streams.html">Networking and Streams</a></li><li><a class="toctext" href="../manual/noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="../manual/packages.html">Packages</a></li><li><a class="toctext" href="../manual/parallel-computing.html">Parallel Computing</a></li><li><a class="toctext" href="../manual/performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="../manual/profile.html">Profiling</a></li><li><a class="toctext" href="../manual/running-external-programs.html">Running External Programs</a></li><li><a class="toctext" href="../manual/stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="../manual/strings.html">Strings</a></li><li><a class="toctext" href="../manual/style-guide.html">Style Guide</a></li><li><a class="toctext" href="../manual/types.html">Types</a></li><li><a class="toctext" href="../manual/unicode-input.html">Unicode Input</a></li><li><a class="toctext" href="../manual/variables-and-scoping.html">Scope of Variables</a></li><li><a class="toctext" href="../manual/variables.html">Variables</a></li><li><a class="toctext" href="../manual/workflow-tips.html">Workflow Tips</a></li></ul></li><li><span class="toctext">JuliaDocs - Standard Libary</span><ul><li><a class="toctext" href="../stdlib/arrays.html">Arrays</a></li><li><a class="toctext" href="../stdlib/base.html">Essentials</a></li><li><a class="toctext" href="../stdlib/c.html">C Interface</a></li><li><a class="toctext" href="../stdlib/collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="../stdlib/constants.html">Constants</a></li><li><a class="toctext" href="../stdlib/dates.html">Dates and Time</a></li><li><a class="toctext" href="../stdlib/file.html">Filesystem</a></li><li><a class="toctext" href="../stdlib/index.html">The Julia Standard Library</a></li><li><a class="toctext" href="../stdlib/io-network.html">I/O and Network</a></li><li><a class="toctext" href="../stdlib/libc.html">C Standard Library</a></li><li><a class="toctext" href="../stdlib/libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="../stdlib/linalg.html">Linear Algebra</a></li><li><a class="toctext" href="../stdlib/math.html">Mathematics</a></li><li><a class="toctext" href="../stdlib/numbers.html">Numbers</a></li><li><a class="toctext" href="../stdlib/parallel.html">Tasks and Parallel Computing</a></li><li><a class="toctext" href="../stdlib/pkg.html">Package Manager Functions</a></li><li><a class="toctext" href="../stdlib/profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/punctuation.html">Punctuation</a></li><li><a class="toctext" href="../stdlib/simd-types.html">SIMD Support</a></li><li><a class="toctext" href="../stdlib/sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="../stdlib/stacktraces.html">StackTraces</a></li><li><a class="toctext" href="../stdlib/strings.html">Strings</a></li><li><a class="toctext" href="../stdlib/test.html">Unit Testing</a></li></ul></li><li><span class="toctext">JuliaDocs - DevDocs</span><ul><li><a class="toctext" href="ast.html">Julia ASTs</a></li><li><a class="toctext" href="backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="callconv.html">Calling Conventions</a></li><li><a class="toctext" href="cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="C.html">Developing/debugging Julia&#39;s C code</a></li><li><a class="toctext" href="debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="eval.html">Eval of Julia code</a></li><li><a class="toctext" href="functions.html">Julia Functions</a></li><li><a class="toctext" href="init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="julia.html">Documentation of Julia&#39;s Internals</a></li><li><a class="toctext" href="llvm.html">Working with LLVM</a></li><li><a class="toctext" href="locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="promote-op.html">Operator-sensitive promotion</a></li><li><a class="toctext" href="reflection.html">Reflection and introspection</a></li><li><a class="toctext" href="stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="subarrays.html">SubArrays</a></li><li><a class="toctext" href="sysimg.html">System Image Building</a></li><li class="current"><a class="toctext" href="types.html">More about types</a><ul class="internal"><li><a class="toctext" href="#Types-and-sets-(and-Any-and-Union{}/Bottom)-1">Types and sets (and <code>Any</code> and <code>Union{}</code>/<code>Bottom</code>)</a></li><li><a class="toctext" href="#TypeVars-1">TypeVars</a></li><li><a class="toctext" href="#TypeNames-1">TypeNames</a></li><li><a class="toctext" href="#Tuple-types-1">Tuple-types</a></li><li><a class="toctext" href="#Introduction-to-the-internal-machinery:-jltypes.c-1">Introduction to the internal machinery: <code>jltypes.c</code></a></li><li><a class="toctext" href="#Subtyping-and-method-sorting-1">Subtyping and method sorting</a></li></ul></li><li><a class="toctext" href="valgrind.html">Using Valgrind with Julia</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>JuliaDocs - DevDocs</li><li><a href="types.html">More about types</a></li></ul><a class="edit-page" href="https://github.com/"><span class="fa">ï‚›</span> Edit on GitHub</a></nav><hr/></header><a id="More-about-types-1"></a><div class="mdnote debug">Base.Markdown.Header{1}</div><h1>More about types</h1><div class="mdnote debug">Base.Markdown.Paragraph</div><p>If you&#39;ve used Julia for a while, you understand the fundamental role that types play.  Here we try to get under the hood, focusing particularly on <a href="@ref">parametric types</a>.</p><a id="Types-and-sets-(and-Any-and-Union{}/Bottom)-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Types and sets (and <code>Any</code> and <code>Union{}</code>/<code>Bottom</code>)</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>It&#39;s perhaps easiest to conceive of Julia&#39;s type system in terms of sets.  A concrete type corresponds to a single entity in the space of all possible types; an abstract type refers to a collection (set) of concrete types.  <code>Any</code> is a type that describes the entire universe of possible types; <code>Integer</code> is a subset of <code>Any</code> that includes <code>Int</code>, <code>Int8</code>, and other concrete types.  Internally, Julia also makes heavy use of another type known as <code>Bottom</code>, or equivalently, <code>Union{}</code>.  This corresponds to the empty set.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Julia&#39;s types support the standard operations of set theory: you can ask whether <code>T1</code> is a &quot;subset&quot; (subtype) of <code>T2</code> with <code>T1 &lt;: T2</code>.  Likewise, you intersect two types using <code>typeintersect</code>, take their union with <code>Union</code>, and compute a type that contains their union with <code>typejoin</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">typeintersect</span><span class="p">(</span><span class="kt">Int</span><span class="p">,</span><span> </span><span class="kt">Float64</span><span class="p">)</span><span>
</span><span class="go">Union{}
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Union</span><span class="p">{</span><span class="kt">Int</span><span class="p">,</span><span> </span><span class="kt">Float64</span><span class="p">}</span><span>
</span><span class="go">Union{Float64,Int64}
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">typejoin</span><span class="p">(</span><span class="kt">Int</span><span class="p">,</span><span> </span><span class="kt">Float64</span><span class="p">)</span><span>
</span><span class="go">Real
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">typeintersect</span><span class="p">(</span><span class="n">Signed</span><span class="p">,</span><span> </span><span class="n">Union</span><span class="p">{</span><span class="n">UInt8</span><span class="p">,</span><span> </span><span class="kt">Int8</span><span class="p">}</span><span class="p">)</span><span>
</span><span class="go">Int8
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Union</span><span class="p">{</span><span class="n">Signed</span><span class="p">,</span><span> </span><span class="n">Union</span><span class="p">{</span><span class="n">UInt8</span><span class="p">,</span><span> </span><span class="kt">Int8</span><span class="p">}</span><span class="p">}</span><span>
</span><span class="go">Union{Signed,UInt8}
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">typejoin</span><span class="p">(</span><span class="n">Signed</span><span class="p">,</span><span> </span><span class="n">Union</span><span class="p">{</span><span class="n">UInt8</span><span class="p">,</span><span> </span><span class="kt">Int8</span><span class="p">}</span><span class="p">)</span><span>
</span><span class="go">Integer
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">typeintersect</span><span class="p">(</span><span class="n">Tuple</span><span class="p">{</span><span class="n">Integer</span><span class="p">,</span><span class="kt">Float64</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">Tuple</span><span class="p">{</span><span class="kt">Int</span><span class="p">,</span><span class="n">Real</span><span class="p">}</span><span class="p">)</span><span>
</span><span class="go">Tuple{Int64,Float64}
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Union</span><span class="p">{</span><span class="n">Tuple</span><span class="p">{</span><span class="n">Integer</span><span class="p">,</span><span class="kt">Float64</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">Tuple</span><span class="p">{</span><span class="kt">Int</span><span class="p">,</span><span class="n">Real</span><span class="p">}</span><span class="p">}</span><span>
</span><span class="go">Union{Tuple{Int64,Real},Tuple{Integer,Float64}}
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">typejoin</span><span class="p">(</span><span class="n">Tuple</span><span class="p">{</span><span class="n">Integer</span><span class="p">,</span><span class="kt">Float64</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">Tuple</span><span class="p">{</span><span class="kt">Int</span><span class="p">,</span><span class="n">Real</span><span class="p">}</span><span class="p">)</span><span>
</span><span class="go">Tuple{Integer,Real}
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>While these operations may seem abstract, they lie at the heart of Julia.  For example, method dispatch is implemented by stepping through the items in a method list until reaching one for which <code>typeintersect(args, sig)</code> is not <code>Union{}</code>.  (Here, <code>args</code> is a tuple-type describing the types of the arguments, and <code>sig</code> is a tuple-type specifying the types in the function&#39;s signature.)  For this algorithm to work, it&#39;s important that methods be sorted by their specificity, and that the search begins with the most specific methods.  Consequently, Julia also implements a partial order on types; this is achieved by functionality that is similar to <code>&lt;:</code>, but with differences that will be discussed below.</p><a id="TypeVars-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>TypeVars</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Many types take parameters; an easy example is <a href="../stdlib/arrays.html#Core.Array"><code>Array</code></a>, which takes two parameters often written as <code>Array{T,N}</code>.  Let&#39;s compare the following methods:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">f1</span><span class="p">(</span><span class="n">A</span><span class="p">:</span><span class="p">:</span><span class="n">Array</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="mi">1</span><span>
</span><span class="n">f2</span><span class="p">(</span><span class="n">A</span><span class="p">:</span><span class="p">:</span><span class="n">Array</span><span class="p">{</span><span class="kt">Int</span><span class="p">}</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="mi">2</span><span>
</span><span class="n">f3</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">(</span><span class="n">A</span><span class="p">:</span><span class="p">:</span><span class="n">Array</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="mi">3</span><span>
</span><span class="n">f4</span><span class="p">(</span><span class="n">A</span><span class="p">:</span><span class="p">:</span><span class="n">Array</span><span class="p">{</span><span class="kt">Any</span><span class="p">}</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="mi">4</span><span>
</span><span class="n">f5</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="kt">Any</span><span class="p">}</span><span class="p">(</span><span class="n">A</span><span class="p">:</span><span class="p">:</span><span class="n">Array</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="mi">5</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>All but <code>f4</code> can be called with <code>a = [1,2]</code>; all but <code>f2</code> can be called with <code>b = Any[1,2]</code>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Let&#39;s look at these types a little more closely:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Array</span><span>
</span><span class="go">Array{T,N}
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">dump</span><span class="p">(</span><span class="n">Array</span><span class="p">)</span><span>
</span><span class="go">Array{T,N} &lt;: DenseArray{T,N}
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This indicates that <a href="../stdlib/arrays.html#Core.Array"><code>Array</code></a> is a shorthand for <code>Array{T,N}</code>.  If you type this at the REPL promptâ€“on its own, not while defining a function or typeâ€“you get an error <code>T not defined</code>. So what, exactly, are <code>T</code> and <code>N</code>? You can learn more by extracting these parameters:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">T</span><span class="p">,</span><span class="n">N</span><span> </span><span class="o">=</span><span> </span><span class="n">Array</span><span class="o">.</span><span class="n">parameters</span><span>
</span><span class="go">svec(T,N)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">dump</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span>
</span><span class="go">TypeVar
</span><span class="go">  name: Symbol T
</span><span class="go">  lb: Union{}
</span><span class="go">  ub: Any
</span><span class="go">  bound: Bool false
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>A <code>TypeVar</code> is one of Julia&#39;s built-in typesâ€“it&#39;s defined in <code>jltypes.c</code>, although you can find a commented-out version in <code>boot.jl</code>.  The <code>name</code> field is straightforward: it&#39;s what&#39;s printed when showing the object.  <code>lb</code> and <code>ub</code> stand for &quot;lower bound&quot; and &quot;upper bound,&quot; respectively: these are the sets that constrain what types the TypeVar may represent.  In this case, <code>T</code>&#39;s lower bound is <code>Union{}</code> (i.e., <code>Bottom</code> or the empty set); in other words, this <code>TypeVar</code> is not constrained from below.  The upper bound is <code>Any</code>, so neither is it constrained from above.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In a method definition like:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">g</span><span class="p">{</span><span class="n">S</span><span class="o">&lt;:</span><span class="n">Integer</span><span class="p">}</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">S</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="mi">0</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>one can extract the underlying <code>TypeVar</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">g</span><span class="p">{</span><span class="n">S</span><span class="o">&lt;:</span><span class="n">Integer</span><span class="p">}</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">S</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="mi">0</span><span>
</span><span class="n">m</span><span> </span><span class="o">=</span><span> </span><span class="n">first</span><span class="p">(</span><span class="n">methods</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="n">p</span><span> </span><span class="o">=</span><span> </span><span class="n">m</span><span class="o">.</span><span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span>
</span><span class="n">tv</span><span> </span><span class="o">=</span><span> </span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span>
</span><span class="n">dump</span><span class="p">(</span><span class="n">tv</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">TypeVar
  name: Symbol S
  lb: Union{}
  ub: Integer &lt;: Real
  bound: Bool true</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Here <code>ub</code> is <code>Integer</code>, as specified in the function definition.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The last field of a <code>TypeVar</code> is <code>bound</code>.  This boolean value specifies whether the <code>TypeVar</code> is defined as one of the function parameters. For example:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">h1</span><span class="p">(</span><span class="n">A</span><span class="p">:</span><span class="p">:</span><span class="n">Array</span><span class="p">,</span><span> </span><span class="n">b</span><span class="p">:</span><span class="p">:</span><span class="n">Real</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="mi">1</span><span>
</span><span class="go">h1 (generic function with 1 method)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">h2</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Real</span><span class="p">}</span><span class="p">(</span><span class="n">A</span><span class="p">:</span><span class="p">:</span><span class="n">Array</span><span class="p">,</span><span> </span><span class="n">b</span><span class="p">:</span><span class="p">:</span><span class="n">T</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="mi">1</span><span>
</span><span class="go">h2 (generic function with 1 method)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">h3</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Real</span><span class="p">}</span><span class="p">(</span><span class="n">A</span><span class="p">:</span><span class="p">:</span><span class="n">Array</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">b</span><span class="p">:</span><span class="p">:</span><span class="n">T</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="mi">1</span><span>
</span><span class="go">h3 (generic function with 1 method)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">p1</span><span> </span><span class="o">=</span><span> </span><span class="n">first</span><span class="p">(</span><span class="n">methods</span><span class="p">(</span><span class="n">h1</span><span class="p">)</span><span class="p">)</span><span class="o">.</span><span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span>
</span><span class="go">svec(#h1,Array{T,N},Real)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">p2</span><span> </span><span class="o">=</span><span> </span><span class="n">first</span><span class="p">(</span><span class="n">methods</span><span class="p">(</span><span class="n">h2</span><span class="p">)</span><span class="p">)</span><span class="o">.</span><span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span>
</span><span class="go">svec(#h2,Array{T,N},T&lt;:Real)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">p3</span><span> </span><span class="o">=</span><span> </span><span class="n">first</span><span class="p">(</span><span class="n">methods</span><span class="p">(</span><span class="n">h3</span><span class="p">)</span><span class="p">)</span><span class="o">.</span><span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span>
</span><span class="go">svec(#h3,Array{T&lt;:Real,N},T&lt;:Real)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">dump</span><span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="p">)</span><span>
</span><span class="go">TypeVar
</span><span class="go">  name: Symbol T
</span><span class="go">  lb: Union{}
</span><span class="go">  ub: Any
</span><span class="go">  bound: Bool false
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">dump</span><span class="p">(</span><span class="n">p3</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="p">)</span><span>
</span><span class="go">TypeVar
</span><span class="go">  name: Symbol T
</span><span class="go">  lb: Union{}
</span><span class="go">  ub: Real &lt;: Number
</span><span class="go">  bound: Bool true
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Note that <code>p2</code> shows two objects called <code>T</code>, but only one of them has the upper bound <code>Real</code>; in contrast, <code>p3</code> shows both of them bounded.  This is because in <code>h3</code>, the same type <code>T</code> is used in both places, whereas for <code>h2</code> the <code>T</code> inside the array is simply the default symbol used for the first parameter of <a href="../stdlib/arrays.html#Core.Array"><code>Array</code></a>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>One can construct <code>TypeVar</code>s manually:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">TypeVar</span><span class="p">(</span><span class="p">:</span><span class="n">V</span><span class="p">,</span><span> </span><span class="n">Signed</span><span class="p">,</span><span> </span><span class="n">Real</span><span class="p">,</span><span> </span><span class="n">false</span><span class="p">)</span><span>
</span><span class="go">Signed&lt;:V&lt;:Real
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>There are convenience versions that allow you to omit any of these arguments except the <code>name</code> symbol.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Armed with this information, we can do some sneaky things that reveal a lot about how Julia does dispatch:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">TV</span><span> </span><span class="o">=</span><span> </span><span class="n">TypeVar</span><span class="p">(</span><span class="p">:</span><span class="n">T</span><span class="p">,</span><span> </span><span class="n">false</span><span class="p">)</span><span>   </span><span class="c"># bound = false</span><span>
</span><span class="go">T
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">candid</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">(</span><span class="n">A</span><span class="p">:</span><span class="p">:</span><span class="n">Array</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">T</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="mi">0</span><span>
</span><span class="go">candid (generic function with 1 method)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="p">@</span><span class="n">eval</span><span> </span><span class="n">sneaky</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">(</span><span class="n">A</span><span class="p">:</span><span class="p">:</span><span class="n">Array</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="o">$</span><span class="n">TV</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="mi">1</span><span>
</span><span class="go">sneaky (generic function with 1 method)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">methods</span><span class="p">(</span><span class="n">candid</span><span class="p">)</span><span>
</span><span class="go"># 1 method for generic function &quot;candid&quot;:
</span><span class="go">candid{T}(A::Array{T,N&lt;:Any}, x::T) at none:1
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">methods</span><span class="p">(</span><span class="n">sneaky</span><span class="p">)</span><span>
</span><span class="go"># 1 method for generic function &quot;sneaky&quot;:
</span><span class="go">sneaky{T}(A::Array{T,N&lt;:Any}, x::T&lt;:Any) at none:1
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>These therefore print identically, but they have very different behavior:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">candid</span><span class="p">(</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="p">,</span><span class="mf">3.2</span><span class="p">)</span><span>
</span><span class="go">ERROR: MethodError: no method matching candid(::Array{Int64,1}, ::Float64)
</span><span class="go">Closest candidates are:
</span><span class="go">  candid{T}(::Array{T,N}, !Matched::T)
</span><span class="go"> ...
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">sneaky</span><span class="p">(</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="p">,</span><span class="mf">3.2</span><span class="p">)</span><span>
</span><span class="go">1
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>To see what&#39;s happening, it&#39;s helpful to use Julia&#39;s internal <code>jl_()</code> function (defined in <code>builtins.c</code>) for display, because it prints bound <code>TypeVar</code> objects with a hash (<code>#T</code> instead of <code>T</code>):</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">jl_</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="k">ccall</span><span class="p">(</span><span class="p">:</span><span class="n">jl_</span><span class="p">,</span><span> </span><span class="n">Void</span><span class="p">,</span><span> </span><span class="p">(</span><span class="kt">Any</span><span class="p">,</span><span class="p">)</span><span class="p">,</span><span> </span><span class="n">x</span><span class="p">)</span><span>
</span><span class="go">jl_ (generic function with 1 method)
</span></code></pre><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">jl_</span><span class="p">(</span><span class="n">first</span><span class="p">(</span><span class="n">methods</span><span class="p">(</span><span class="n">candid</span><span class="p">)</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="go">Method(sig=Tuple{Main.#candid, Array{#T&lt;:Any, N&lt;:Any}, #T&lt;:Any}, va=false, isstaged=false, tvars=#T&lt;:Any, func=Main.candid(?), invokes=nothing, next=nothing)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">jl_</span><span class="p">(</span><span class="n">first</span><span class="p">(</span><span class="n">methods</span><span class="p">(</span><span class="n">sneaky</span><span class="p">)</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="go">Method(sig=Tuple{Main.#sneaky, Array{#T&lt;:Any, N&lt;:Any}, T&lt;:Any}, va=false, isstaged=false, tvars=#T&lt;:Any, func=Main.sneaky(?), invokes=nothing, next=nothing)
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Even though both print as <code>T</code>, in <code>sneaky</code> the second <code>T</code> is not bound, and hence it isn&#39;t constrained to be the same type as the element type of the <a href="../stdlib/arrays.html#Core.Array"><code>Array</code></a>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Some <code>TypeVar</code> interactions depend on the <code>bound</code> state, even when there are not two or more uses of the same <code>TypeVar</code>. For example:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">S</span><span> </span><span class="o">=</span><span> </span><span class="n">TypeVar</span><span class="p">(</span><span class="p">:</span><span class="n">S</span><span class="p">,</span><span> </span><span class="n">false</span><span class="p">)</span><span class="p">;</span><span> </span><span class="n">T</span><span> </span><span class="o">=</span><span> </span><span class="n">TypeVar</span><span class="p">(</span><span class="p">:</span><span class="n">T</span><span class="p">,</span><span> </span><span class="n">true</span><span class="p">)</span><span>
</span><span class="go">T
</span><span class="go">
</span><span class="go"># These would be the same no matter whether we used S or T
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Array</span><span class="p">{</span><span class="n">Array</span><span class="p">{</span><span class="n">S</span><span class="p">}</span><span class="p">}</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Array</span><span class="p">{</span><span class="n">Array</span><span class="p">}</span><span>
</span><span class="go">true
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Array</span><span class="p">{</span><span class="n">Array</span><span class="p">{</span><span class="n">S</span><span class="p">}</span><span class="p">}</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Array</span><span class="p">{</span><span class="n">Array</span><span class="p">{</span><span class="n">S</span><span class="p">}</span><span class="p">}</span><span>
</span><span class="go">true
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Array</span><span class="p">{</span><span class="n">Array</span><span class="p">}</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Array</span><span class="p">{</span><span class="n">Array</span><span class="p">{</span><span class="n">S</span><span class="p">}</span><span class="p">}</span><span>
</span><span class="go">true
</span><span class="go">
</span><span class="go"># For these cases, it matters
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Array</span><span class="p">{</span><span class="n">Array</span><span class="p">{</span><span class="kt">Int</span><span class="p">}</span><span class="p">}</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Array</span><span class="p">{</span><span class="n">Array</span><span class="p">}</span><span>
</span><span class="go">false
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Array</span><span class="p">{</span><span class="n">Array</span><span class="p">{</span><span class="kt">Int</span><span class="p">}</span><span class="p">}</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Array</span><span class="p">{</span><span class="n">Array</span><span class="p">{</span><span class="n">S</span><span class="p">}</span><span class="p">}</span><span>
</span><span class="go">false
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Array</span><span class="p">{</span><span class="n">Array</span><span class="p">{</span><span class="kt">Int</span><span class="p">}</span><span class="p">}</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Array</span><span class="p">{</span><span class="n">Array</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">}</span><span>
</span><span class="go">true
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>It&#39;s this latter construction that allows function declarations like</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">foo</span><span class="p">{</span><span class="n">T</span><span class="p">,</span><span class="n">N</span><span class="p">}</span><span class="p">(</span><span class="n">A</span><span class="p">:</span><span class="p">:</span><span class="n">Array</span><span class="p">{</span><span class="n">Array</span><span class="p">{</span><span class="n">T</span><span class="p">,</span><span class="n">N</span><span class="p">}</span><span class="p">}</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">T</span><span class="p">,</span><span class="n">N</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>to match despite the invariance of Julia&#39;s type parameters.</p><a id="TypeNames-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>TypeNames</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The following two <a href="../stdlib/arrays.html#Core.Array"><code>Array</code></a> types are functionally equivalent, yet print differently via <code>jl_()</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">TV</span><span class="p">,</span><span> </span><span class="n">NV</span><span> </span><span class="o">=</span><span> </span><span class="n">TypeVar</span><span class="p">(</span><span class="p">:</span><span class="n">T</span><span class="p">)</span><span class="p">,</span><span> </span><span class="n">TypeVar</span><span class="p">(</span><span class="p">:</span><span class="n">N</span><span class="p">)</span><span>
</span><span class="go">(T,N)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">jl_</span><span class="p">(</span><span class="n">Array</span><span class="p">)</span><span>
</span><span class="go">Array
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">jl_</span><span class="p">(</span><span class="n">Array</span><span class="p">{</span><span class="n">TV</span><span class="p">,</span><span class="n">NV</span><span class="p">}</span><span class="p">)</span><span>
</span><span class="go">Array{T&lt;:Any, N&lt;:Any}
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>These can be distinguished by examining the <code>name</code> field of the type, which is an object of type <code>TypeName</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">dump</span><span class="p">(</span><span class="n">Array</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span>
</span><span class="go">TypeName
</span><span class="go">  name: Symbol Array
</span><span class="go">  module: Module Core
</span><span class="go">  names: empty SimpleVector
</span><span class="go">  primary: Array{T,N} &lt;: DenseArray{T,N}
</span><span class="go">  cache: SimpleVector
</span><span class="go">    ...
</span><span class="go">  linearcache: SimpleVector
</span><span class="go">    ...
</span><span class="go">  uid: Int64 47
</span><span class="go">  mt: MethodTable
</span><span class="go">    name: Symbol Array
</span><span class="go">    defs: Void nothing
</span><span class="go">    cache: Void nothing
</span><span class="go">    max_args: Int64 0
</span><span class="go">    kwsorter: #undef
</span><span class="go">    module: Module Core
</span><span class="go">    : Int64 0
</span><span class="go">    : Int64 0
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In this case, the relevant field is <code>primary</code>, which holds a reference to the &quot;primary&quot; instance of the type:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">pointer_from_objref</span><span class="p">(</span><span class="n">Array</span><span class="p">)</span><span>
</span><span class="go">Ptr{Void} @0x00007fcc7de64850
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">pointer_from_objref</span><span class="p">(</span><span class="n">Array</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">primary</span><span class="p">)</span><span>
</span><span class="go">Ptr{Void} @0x00007fcc7de64850
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">pointer_from_objref</span><span class="p">(</span><span class="n">Array</span><span class="p">{</span><span class="n">TV</span><span class="p">,</span><span class="n">NV</span><span class="p">}</span><span class="p">)</span><span>
</span><span class="go">Ptr{Void} @0x00007fcc80c4d930
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">pointer_from_objref</span><span class="p">(</span><span class="n">Array</span><span class="p">{</span><span class="n">TV</span><span class="p">,</span><span class="n">NV</span><span class="p">}</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">primary</span><span class="p">)</span><span>
</span><span class="go">Ptr{Void} @0x00007fcc7de64850
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The <code>primary</code> field of <a href="../stdlib/arrays.html#Core.Array"><code>Array</code></a> points to itself, but for <code>Array{TV,NV}</code> it points back to the default definition of the type.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>What about the other fields? <code>uid</code> assigns a unique integer to each type.  To examine the <code>cache</code> field, it&#39;s helpful to pick a type that is less heavily used than Array. Let&#39;s first create our own type:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="k">type</span><span class="nc"> </span><span class="nc">MyType</span><span class="p">{</span><span class="n">T</span><span class="p">,</span><span class="n">N</span><span class="p">}</span><span> </span><span class="k">end</span><span>
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">MyType</span><span class="p">{</span><span class="kt">Int</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span><span>
</span><span class="go">MyType{Int64,2}
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">MyType</span><span class="p">{</span><span class="kt">Float32</span><span class="p">,</span><span> </span><span class="mi">5</span><span class="p">}</span><span>
</span><span class="go">MyType{Float32,5}
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">MyType</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">cache</span><span>
</span><span class="go">svec(MyType{Float32,5},MyType{Int64,2},#undef,#undef,#undef,#undef,#undef,#undef)
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>(The cache is pre-allocated to have length 8, but only the first two entries are populated.) Consequently, when you instantiate a parametric type, each concrete type gets saved in a type-cache.  However, instances with <code>TypeVar</code> parameters are not cached.</p><a id="Tuple-types-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Tuple-types</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Tuple-types constitute an interesting special case.  For dispatch to work on declarations like <code>x::Tuple</code>, the type has to be able to be able to accommodate any tuple.  Let&#39;s check the parameters:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Tuple</span><span>
</span><span class="go">Tuple
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Tuple</span><span class="o">.</span><span class="n">parameters</span><span>
</span><span class="go">svec(Vararg{Any,N})
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>It&#39;s worth noting that the parameter is a type, <code>Any</code>, rather than a <code>TypeVar T&lt;:Any</code>: compare</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">jl_</span><span class="p">(</span><span class="n">Tuple</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span><span>
</span><span class="go">svec(Vararg{Any, N&lt;:Any})
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">jl_</span><span class="p">(</span><span class="n">Array</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span><span>
</span><span class="go">svec(T&lt;:Any, N&lt;:Any)
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Unlike other types, tuple-types are covariant in their parameters, so this definition permits <code>Tuple</code> to match any type of tuple.  This is therefore equivalent to having an unbound <code>TypeVar</code> but distinct from a bound <code>TypeVar</code></p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">typeintersect</span><span class="p">(</span><span class="n">Tuple</span><span class="p">,</span><span> </span><span class="n">Tuple</span><span class="p">{</span><span class="kt">Int</span><span class="p">,</span><span class="kt">Float64</span><span class="p">}</span><span class="p">)</span><span>
</span><span class="go">Tuple{Int64,Float64}
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">typeintersect</span><span class="p">(</span><span class="n">Tuple</span><span class="p">{</span><span class="n">Vararg</span><span class="p">{</span><span class="kt">Any</span><span class="p">}</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">Tuple</span><span class="p">{</span><span class="kt">Int</span><span class="p">,</span><span class="kt">Float64</span><span class="p">}</span><span class="p">)</span><span>
</span><span class="go">Tuple{Int64,Float64}
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">T</span><span> </span><span class="o">=</span><span> </span><span class="n">TypeVar</span><span class="p">(</span><span class="p">:</span><span class="n">T</span><span class="p">,</span><span class="n">false</span><span class="p">)</span><span>
</span><span class="go">T
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">typeintersect</span><span class="p">(</span><span class="n">Tuple</span><span class="p">{</span><span class="n">Vararg</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">Tuple</span><span class="p">{</span><span class="kt">Int</span><span class="p">,</span><span class="kt">Float64</span><span class="p">}</span><span class="p">)</span><span>
</span><span class="go">Tuple{Int64,Float64}
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">T</span><span> </span><span class="o">=</span><span> </span><span class="n">TypeVar</span><span class="p">(</span><span class="p">:</span><span class="n">T</span><span class="p">,</span><span class="n">true</span><span class="p">)</span><span>
</span><span class="go">T
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">typeintersect</span><span class="p">(</span><span class="n">Tuple</span><span class="p">{</span><span class="n">Vararg</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">Tuple</span><span class="p">{</span><span class="kt">Int</span><span class="p">,</span><span class="kt">Float64</span><span class="p">}</span><span class="p">)</span><span>
</span><span class="go">Union{}
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Finally, it&#39;s worth noting that <code>Tuple{}</code> is distinct</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Tuple</span><span class="p">{</span><span class="p">}</span><span>
</span><span class="go">Tuple{}
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Tuple</span><span class="p">{</span><span class="p">}</span><span class="o">.</span><span class="n">parameters</span><span>
</span><span class="go">svec()
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">typeintersect</span><span class="p">(</span><span class="n">Tuple</span><span class="p">{</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">Tuple</span><span class="p">{</span><span class="kt">Int</span><span class="p">}</span><span class="p">)</span><span>
</span><span class="go">Union{}
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>What is the &quot;primary&quot; tuple-type?</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">pointer_from_objref</span><span class="p">(</span><span class="n">Tuple</span><span class="p">)</span><span>
</span><span class="go">Ptr{Void} @0x00007f5998a04370
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">pointer_from_objref</span><span class="p">(</span><span class="n">Tuple</span><span class="p">{</span><span class="p">}</span><span class="p">)</span><span>
</span><span class="go">Ptr{Void} @0x00007f5998a570d0
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">pointer_from_objref</span><span class="p">(</span><span class="n">Tuple</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">primary</span><span class="p">)</span><span>
</span><span class="go">Ptr{Void} @0x00007f5998a04370
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">pointer_from_objref</span><span class="p">(</span><span class="n">Tuple</span><span class="p">{</span><span class="p">}</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">primary</span><span class="p">)</span><span>
</span><span class="go">Ptr{Void} @0x00007f5998a04370
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>so <code>Tuple == Tuple{Vararg{Any}}</code> is indeed the primary type.</p><a id="Introduction-to-the-internal-machinery:-jltypes.c-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Introduction to the internal machinery: <code>jltypes.c</code></h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Many operations for dealing with types are found in the file <code>jltypes.c</code>. A good way to start is to watch type intersection in action.  Build Julia with <code>make debug</code> and fire up Julia within a debugger. <a href="debuggingtips.html#gdb-debugging-tips-1">gdb debugging tips</a> has some tips which may be useful.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Because the type intersection and matching code is used heavily in the REPL itselfâ€“and hence breakpoints in this code get triggered oftenâ€“it will be easiest if you make the following definition:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="k">function</span><span class="nf"> </span><span class="nf">myintersect</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span><span>
</span><span class="gt">
           ccall(:jl_breakpoint, Void, (Any,), nothing)
</span><span></span><span class="gt">
           typeintersect(a, b)
</span><span></span><span class="gt">
       end
</span><span></span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>and then set a breakpoint in <code>jl_breakpoint</code>.  Once this breakpoint gets triggered, you can set breakpoints in other functions.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>As a warm-up, try the following:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">myintersect</span><span class="p">(</span><span class="n">Tuple</span><span class="p">{</span><span class="n">Integer</span><span class="p">,</span><span class="kt">Float64</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">Tuple</span><span class="p">{</span><span class="kt">Int</span><span class="p">,</span><span class="n">Real</span><span class="p">}</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Set a breakpoint in <code>intersect_tuple</code> and continue until it enters this function.  You should be able to see something like this:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">Breakpoint 2, intersect_tuple (a=0x7ffdf7409150, b=0x7ffdf74091b0, penv=0x7fffffffcc90, eqc=0x7fffffffcc70, var=covariant) at jltypes.c:405
405     {
(gdb) call jl_(a)
Tuple{Integer, Float64}
(gdb) call jl_(b)
Tuple{Int64, Real}</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The <code>var</code> argument is either <code>covariant</code> or <code>invariant</code>, the latter being used if you&#39;re matching the type parameters of <code>Array{T1}</code> against <code>Array{T2}</code>.  The other two inputs to this function (<code>penv</code> and <code>eqc</code>) may be currently mysterious, but we&#39;ll discuss them in a moment.  For now, step through the code until you get into the loop over the different entries in the tuple types <code>a</code> and <code>b</code>.  The key call is:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">ce</span><span> </span><span class="o">=</span><span> </span><span class="n">jl_type_intersect</span><span class="p">(</span><span class="n">ae</span><span class="p">,</span><span class="n">be</span><span class="p">,</span><span class="n">penv</span><span class="p">,</span><span class="n">eqc</span><span class="p">,</span><span class="n">var</span><span class="p">)</span><span class="p">;</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>which, if you examine <code>ae</code>, <code>be</code>, and <code>ce</code>, you&#39;ll see is just type intersection performed on these entries.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>We can make it more interesting by trying a more complex case:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">T</span><span> </span><span class="o">=</span><span> </span><span class="n">TypeVar</span><span class="p">(</span><span class="p">:</span><span class="n">T</span><span class="p">,</span><span> </span><span class="n">true</span><span class="p">)</span><span>
</span><span class="go">T
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">myintersect</span><span class="p">(</span><span class="n">Tuple</span><span class="p">{</span><span class="n">Array</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">T</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">Tuple</span><span class="p">{</span><span class="n">Array</span><span class="p">{</span><span class="kt">Int</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span><span class="p">,</span><span> </span><span class="kt">Int8</span><span class="p">}</span><span class="p">)</span><span>
</span><span class="go">
</span><span class="go">Breakpoint 1, jl_breakpoint (v=0x7ffdf35e8010) at builtins.c:1559
</span><span class="go">1559    {
</span><span class="go">(gdb) b intersect_tuple
</span><span class="go">Breakpoint 3 at 0x7ffff6dcb07d: file jltypes.c, line 405.
</span><span class="go">(gdb) c
</span><span class="go">Continuing.
</span><span class="go">
</span><span class="go">Breakpoint 3, intersect_tuple (a=0x7ffdf74d7a90, b=0x7ffdf74d7af0, penv=0x7fffffffcc90, eqc=0x7fffffffcc70, var=covariant) at jltypes.c:405
</span><span class="go">405     {
</span><span class="go">(gdb) call jl_(a)
</span><span class="go">Tuple{Array{ï¼ƒT&lt;:Any, N&lt;:Any}, ï¼ƒT&lt;:Any}
</span><span class="go">(gdb) call jl_(b)
</span><span class="go">Tuple{Array{Int64, 2}, Int8}
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Let&#39;s watch how this bound <code>TypeVar</code> gets handled.  To follow this, you&#39;ll need to examine the variables <code>penv</code> and <code>eqc</code>, which are defined as:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">typedef struct {
    jl_value_t **data;
    size_t n;
    jl_svec_t *tvars;
} cenv_t;</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>These start out empty (with <code>penv-&gt;n == eqc-&gt;n == 0</code>).  Once we get into the loop and make the first call to <code>jl_type_intersect</code>, <code>eqc</code> (which stands for &quot;equality constraints&quot;) has the following value:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">(gdb) p eqc-&gt;n
$4 = 2
(gdb) call jl_(eqc-&gt;data[0])
ï¼ƒT&lt;:Any
(gdb) call jl_(eqc-&gt;data[1])
Int64</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This is just a <code>var</code>, <code>value</code> list of pairs, indicating that <code>T</code> now has the value <code>Int64</code>.  If you now allow <code>intersect_tuple</code> to finish and keep progressing, you&#39;ll eventually get to <code>type_intersection_matching</code>.  This function contains a call to <code>solve_tvar_constraints</code>.  Roughly speaking, <code>eqc</code> defines <code>T = Int64</code>, but <code>env</code> defines it as <code>Int8</code>; this conflict is detected in <code>solve_tvar_constraints</code> and the resulting return is <code>jl_bottom_type</code>, aka <code>Union{}</code>.</p><a id="Subtyping-and-method-sorting-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Subtyping and method sorting</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Armed with this knowledge, you may find yourself surprised by the following:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">typeintersect</span><span class="p">(</span><span class="n">Tuple</span><span class="p">{</span><span class="n">Array</span><span class="p">{</span><span class="kt">Int</span><span class="p">}</span><span class="p">,</span><span class="kt">Float64</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">Tuple</span><span class="p">{</span><span class="n">Array</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">,</span><span class="n">T</span><span class="p">}</span><span class="p">)</span><span>
</span><span class="go">Union{}
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Tuple</span><span class="p">{</span><span class="n">Array</span><span class="p">{</span><span class="kt">Int</span><span class="p">}</span><span class="p">,</span><span class="kt">Float64</span><span class="p">}</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Tuple</span><span class="p">{</span><span class="n">Array</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">,</span><span class="n">T</span><span class="p">}</span><span>
</span><span class="go">true
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>where <code>T</code> is a bound <code>TypeVar</code>.  In other words, <code>A &lt;: B</code> does not imply that <code>typeintersect(A, B) == A</code>.  A little bit of digging reveals the reason why: <code>jl_subtype_le</code> does not use the <code>cenv_t</code> constraints that we just saw in <code>typeintersect</code>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p><code>jltypes.c</code> contains three closely related collections of functions for testing how types <code>a</code> and <code>b</code> are ordered:</p><div class="mdnote debug">Base.Markdown.List</div><ul><li><p>The <code>subtype</code> functions implement <code>a &lt;: b</code>. Among other uses, they serve in matching function arguments against method signatures in the function cache.</p></li><li><p>The <code>type_morespecific</code> functions are used for imposing a partial order on functions in method tables (from most-to-least specific). Note that <code>jl_type_morespecific(a,b,0)</code> really means &quot;is <code>a</code> at least as specific as <code>b</code>?&quot; and not &quot;is <code>a</code> strictly more specific than <code>b</code>?&quot;</p></li><li><p>The <code>type_match</code> functions are similar to <code>type_morespecific</code>, but additionally accept (and employ) an environment to constrain typevars. The related <code>type_match_morespecific</code> functions call <code>type_match</code> with an argument <code>morespecific=1</code></p></li></ul><div class="mdnote debug">Base.Markdown.Paragraph</div><p>All three of these take an argument, <code>invariant</code>, which is set to 1 when comparing type parameters and otherwise is 0.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The rules for these are somewhat different. <code>subtype</code> is sensitive to the number arguments, but <code>type_morespecific</code> may not be. In particular, <code>Tuple{Int,AbstractFloat}</code> is more specific than <code>Tuple{Integer}</code>, even though it is not a subtype.  (Of <code>Tuple{Int,AbstractFloat}</code> and <code>Tuple{Integer,Float64}</code>, neither is more specific than the other.)  Likewise, <code>Tuple{Int,Vararg{Int}}</code> is not a subtype of <code>Tuple{Integer}</code>, but it is considered more specific. However, <code>morespecific</code> does get a bonus for length: in particular, <code>Tuple{Int,Int}</code> is more specific than <code>Tuple{Int,Vararg{Int}}</code>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>If you&#39;re debugging how methods get sorted, it can be convenient to define the function:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">args_morespecific</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span> </span><span class="n">b</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="k">ccall</span><span class="p">(</span><span class="p">:</span><span class="n">jl_args_morespecific</span><span class="p">,</span><span> </span><span class="n">Cint</span><span class="p">,</span><span> </span><span class="p">(</span><span class="kt">Any</span><span class="p">,</span><span class="kt">Any</span><span class="p">)</span><span class="p">,</span><span> </span><span class="n">a</span><span class="p">,</span><span> </span><span class="n">b</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>which allows you to test whether arg-tuple <code>a</code> is more specific than arg-tuple <code>b</code>.</p><footer><hr/><a class="previous" href="sysimg.html"><span class="direction">Previous</span><span class="title">System Image Building</span></a><a class="next" href="valgrind.html"><span class="direction">Next</span><span class="title">Using Valgrind with Julia</span></a></footer></article></body></html>
