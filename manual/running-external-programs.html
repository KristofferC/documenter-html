<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Documenter.jl</title><link href="../normalize.css" rel="stylesheet" type="text/css"/><link href="../style.css" rel="stylesheet" type="text/css"/><link href="../highlight.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="../require.js" data-main="../documenter.js"></script><script src="../search-index.js"></script></head><body><nav class="toc"><a href="http://julialang.org/"><img class="logo" src="http://docs.julialang.org/en/release-0.4/_static/julia-logo.svg" alt="\$pkgname.jl logo"/></a><h1>$pkgname.jl</h1><input type="text" placeholder="Search docs"/><ul><li><a class="toctext" href="../index.html">Overview</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../man/guide.html">Guide</a></li><li><a class="toctext" href="../man/examples.html">Examples</a></li><li><a class="toctext" href="../man/syntax.html">Syntax</a></li><li><a class="toctext" href="../man/doctests.html">Doctests</a></li><li><a class="toctext" href="../man/hosting.html">Hosting Documentation</a></li><li><a class="toctext" href="../man/latex.html"><span>$\LaTeX$</span> syntax</a></li><li><a class="toctext" href="../man/internals.html">Package Internals</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../lib/public.html">Public Documentation</a></li><li><a class="toctext" href="../lib/internals.html">Internal Documentation</a></li></ul></li><li><span class="toctext">Dynamic pages</span><ul><li><a class="toctext" href="../dynamic/code.html">Code examples</a></li><li><a class="toctext" href="../dynamic/admonitions.html">Admonitions &amp; Co</a></li><li><a class="toctext" href="../dynamic/styles.html">Demonstrating <em>styles</em> of MD elements</a></li><li><a class="toctext" href="../dynamic/bugs.html">Some existing bugs</a></li></ul></li><li><span class="toctext">JuliaDocs - Manual</span><ul><li><a class="toctext" href="arrays.html">Multi-dimensional Arrays</a></li><li><a class="toctext" href="calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="toctext" href="complex-and-rational-numbers.html">Complex and Rational Numbers</a></li><li><a class="toctext" href="constructors.html">Constructors</a></li><li><a class="toctext" href="control-flow.html">Control Flow</a></li><li><a class="toctext" href="conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="toctext" href="dates.html">Date and DateTime</a></li><li><a class="toctext" href="documentation.html">Documentation</a></li><li><a class="toctext" href="embedding.html">Embedding Julia</a></li><li><a class="toctext" href="faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="functions.html">Functions</a></li><li><a class="toctext" href="getting-started.html">Getting Started</a></li><li><a class="toctext" href="handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="index.html">The Julia Manual</a></li><li><a class="toctext" href="integers-and-floating-point-numbers.html">Integers and Floating-Point Numbers</a></li><li><a class="toctext" href="interacting-with-julia.html">Interacting With Julia</a></li><li><a class="toctext" href="interfaces.html">Interfaces</a></li><li><a class="toctext" href="introduction.html">Introduction</a></li><li><a class="toctext" href="linear-algebra.html">Linear algebra</a></li><li><a class="toctext" href="mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="metaprogramming.html">Metaprogramming</a></li><li><a class="toctext" href="methods.html">Methods</a></li><li><a class="toctext" href="modules.html">Modules</a></li><li><a class="toctext" href="networking-and-streams.html">Networking and Streams</a></li><li><a class="toctext" href="noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="packages.html">Packages</a></li><li><a class="toctext" href="parallel-computing.html">Parallel Computing</a></li><li><a class="toctext" href="performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="profile.html">Profiling</a></li><li class="current"><a class="toctext" href="running-external-programs.html">Running External Programs</a><ul class="internal"><li><a class="toctext" href="#Interpolation-1">Interpolation</a></li><li><a class="toctext" href="#Quoting-1">Quoting</a></li><li><a class="toctext" href="#Pipelines-1">Pipelines</a></li></ul></li><li><a class="toctext" href="stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="strings.html">Strings</a></li><li><a class="toctext" href="style-guide.html">Style Guide</a></li><li><a class="toctext" href="types.html">Types</a></li><li><a class="toctext" href="unicode-input.html">Unicode Input</a></li><li><a class="toctext" href="variables-and-scoping.html">Scope of Variables</a></li><li><a class="toctext" href="variables.html">Variables</a></li><li><a class="toctext" href="workflow-tips.html">Workflow Tips</a></li></ul></li><li><span class="toctext">JuliaDocs - Standard Libary</span><ul><li><a class="toctext" href="../stdlib/arrays.html">Arrays</a></li><li><a class="toctext" href="../stdlib/base.html">Essentials</a></li><li><a class="toctext" href="../stdlib/c.html">C Interface</a></li><li><a class="toctext" href="../stdlib/collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="../stdlib/constants.html">Constants</a></li><li><a class="toctext" href="../stdlib/dates.html">Dates and Time</a></li><li><a class="toctext" href="../stdlib/file.html">Filesystem</a></li><li><a class="toctext" href="../stdlib/index.html">The Julia Standard Library</a></li><li><a class="toctext" href="../stdlib/io-network.html">I/O and Network</a></li><li><a class="toctext" href="../stdlib/libc.html">C Standard Library</a></li><li><a class="toctext" href="../stdlib/libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="../stdlib/linalg.html">Linear Algebra</a></li><li><a class="toctext" href="../stdlib/math.html">Mathematics</a></li><li><a class="toctext" href="../stdlib/numbers.html">Numbers</a></li><li><a class="toctext" href="../stdlib/parallel.html">Tasks and Parallel Computing</a></li><li><a class="toctext" href="../stdlib/pkg.html">Package Manager Functions</a></li><li><a class="toctext" href="../stdlib/profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/punctuation.html">Punctuation</a></li><li><a class="toctext" href="../stdlib/simd-types.html">SIMD Support</a></li><li><a class="toctext" href="../stdlib/sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="../stdlib/stacktraces.html">StackTraces</a></li><li><a class="toctext" href="../stdlib/strings.html">Strings</a></li><li><a class="toctext" href="../stdlib/test.html">Unit Testing</a></li></ul></li><li><span class="toctext">JuliaDocs - DevDocs</span><ul><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/C.html">Developing/debugging Julia&#39;s C code</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../devdocs/julia.html">Documentation of Julia&#39;s Internals</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/promote-op.html">Operator-sensitive promotion</a></li><li><a class="toctext" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/types.html">More about types</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>JuliaDocs - Manual</li><li><a href="running-external-programs.html">Running External Programs</a></li></ul><a class="edit-page" href="https://github.com/"><span class="fa">ï‚›</span> Edit on GitHub</a></nav><hr/></header><a id="Running-External-Programs-1"></a><div class="mdnote debug">Base.Markdown.Header{1}</div><h1>Running External Programs</h1><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Julia borrows backtick notation for commands from the shell, Perl, and Ruby. However, in Julia, writing</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="sb">`echo hello`</span><span>
</span><span class="go">`echo hello`
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>differs in several aspects from the behavior in various shells, Perl, or Ruby:</p><div class="mdnote debug">Base.Markdown.List</div><ul><li><p>Instead of immediately running the command, backticks create a <code>Cmd</code> object to represent the command. You can use this object to connect the command to others via pipes, run it, and read or write to it.</p></li><li><p>When the command is run, Julia does not capture its output unless you specifically arrange for it to. Instead, the output of the command by default goes to <a href="../stdlib/io-network.html#Base.STDOUT"><code>STDOUT</code></a> as it would using <code>libc</code>&#39;s <code>system</code> call.</p></li><li><p>The command is never run with a shell. Instead, Julia parses the command syntax directly, appropriately interpolating variables and splitting on words as the shell would, respecting shell quoting syntax. The command is run as <code>julia</code>&#39;s immediate child process, using <code>fork</code> and <code>exec</code> calls.</p></li></ul><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Here&#39;s a simple example of running an external program:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">run</span><span class="p">(</span><span class="sb">`echo hello`</span><span class="p">)</span><span>
</span><span class="go">hello
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The <code>hello</code> is the output of the <code>echo</code> command, sent to <a href="../stdlib/io-network.html#Base.STDOUT"><code>STDOUT</code></a>. The run method itself returns <code>nothing</code>, and throws an <a href="../stdlib/base.html#Core.ErrorException"><code>ErrorException</code></a> if the external command fails to run successfully.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>If you want to read the output of the external command, <a href="../stdlib/io-network.html#Base.readstring"><code>readstring()</code></a> can be used instead:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">a</span><span class="o">=</span><span class="n">readstring</span><span class="p">(</span><span class="sb">`echo hello`</span><span class="p">)</span><span>
</span><span class="go">&quot;hello\n&quot;
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="p">(</span><span class="n">chomp</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="p">)</span><span> </span><span class="o">==</span><span> </span><span class="s">&quot;</span><span class="s">hello</span><span class="s">&quot;</span><span>
</span><span class="go">true
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>More generally, you can use <a href="../stdlib/io-network.html#Base.open"><code>open()</code></a> to read from or write to an external command.</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">open</span><span class="p">(</span><span class="sb">`less`</span><span class="p">,</span><span> </span><span class="s">&quot;</span><span class="s">w</span><span class="s">&quot;</span><span class="p">,</span><span> </span><span class="n">STDOUT</span><span class="p">)</span><span> </span><span class="k">do</span><span> </span><span class="n">io</span><span>
</span><span class="gt">
           for i = 1:3
</span><span></span><span class="gt">
               println(io, i)
</span><span></span><span class="gt">
           end
</span><span></span><span class="gt">
       end
</span><span></span><span class="go">1
</span><span class="go">2
</span><span class="go">3
</span></code></pre><a id="Interpolation-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Interpolation</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Suppose you want to do something a bit more complicated and use the name of a file in the variable <code>file</code> as an argument to a command. You can use <code>$</code> for interpolation much as you would in a string literal (see <a href="@ref">Strings</a>):</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">file</span><span> </span><span class="o">=</span><span> </span><span class="s">&quot;</span><span class="s">/etc/passwd</span><span class="s">&quot;</span><span>
</span><span class="go">&quot;/etc/passwd&quot;
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="sb">`sort $file`</span><span>
</span><span class="go">`sort /etc/passwd`
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>A common pitfall when running external programs via a shell is that if a file name contains characters that are special to the shell, they may cause undesirable behavior. Suppose, for example, rather than <code>/etc/passwd</code>, we wanted to sort the contents of the file <code>/Volumes/External HD/data.csv</code>. Let&#39;s try it:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">file</span><span> </span><span class="o">=</span><span> </span><span class="s">&quot;</span><span class="s">/Volumes/External HD/data.csv</span><span class="s">&quot;</span><span>
</span><span class="go">&quot;/Volumes/External HD/data.csv&quot;
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="sb">`sort $file`</span><span>
</span><span class="go">`sort &#39;/Volumes/External HD/data.csv&#39;`
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>How did the file name get quoted? Julia knows that <code>file</code> is meant to be interpolated as a single argument, so it quotes the word for you. Actually, that is not quite accurate: the value of <code>file</code> is never interpreted by a shell, so there&#39;s no need for actual quoting; the quotes are inserted only for presentation to the user. This will even work if you interpolate a value as part of a shell word:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">path</span><span> </span><span class="o">=</span><span> </span><span class="s">&quot;</span><span class="s">/Volumes/External HD</span><span class="s">&quot;</span><span>
</span><span class="go">&quot;/Volumes/External HD&quot;
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">name</span><span> </span><span class="o">=</span><span> </span><span class="s">&quot;</span><span class="s">data</span><span class="s">&quot;</span><span>
</span><span class="go">&quot;data&quot;
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">ext</span><span> </span><span class="o">=</span><span> </span><span class="s">&quot;</span><span class="s">csv</span><span class="s">&quot;</span><span>
</span><span class="go">&quot;csv&quot;
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="sb">`sort $path/$name.$ext`</span><span>
</span><span class="go">`sort &#39;/Volumes/External HD/data.csv&#39;`
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>As you can see, the space in the <code>path</code> variable is appropriately escaped. But what if you <em>want</em> to interpolate multiple words? In that case, just use an array (or any other iterable container):</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">files</span><span> </span><span class="o">=</span><span> </span><span class="p">[</span><span class="s">&quot;</span><span class="s">/etc/passwd</span><span class="s">&quot;</span><span class="p">,</span><span class="s">&quot;</span><span class="s">/Volumes/External HD/data.csv</span><span class="s">&quot;</span><span class="p">]</span><span>
</span><span class="go">2-element Array{String,1}:
</span><span class="go"> &quot;/etc/passwd&quot;
</span><span class="go"> &quot;/Volumes/External HD/data.csv&quot;
</span><span class="go">
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="sb">`grep foo $files`</span><span>
</span><span class="go">`grep foo /etc/passwd &#39;/Volumes/External HD/data.csv&#39;`
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>If you interpolate an array as part of a shell word, Julia emulates the shell&#39;s <code>{a,b,c}</code> argument generation:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">names</span><span> </span><span class="o">=</span><span> </span><span class="p">[</span><span class="s">&quot;</span><span class="s">foo</span><span class="s">&quot;</span><span class="p">,</span><span class="s">&quot;</span><span class="s">bar</span><span class="s">&quot;</span><span class="p">,</span><span class="s">&quot;</span><span class="s">baz</span><span class="s">&quot;</span><span class="p">]</span><span>
</span><span class="go">3-element Array{String,1}:
</span><span class="go"> &quot;foo&quot;
</span><span class="go"> &quot;bar&quot;
</span><span class="go"> &quot;baz&quot;
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="sb">`grep xylophone $names.txt`</span><span>
</span><span class="go">`grep xylophone foo.txt bar.txt baz.txt`
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Moreover, if you interpolate multiple arrays into the same word, the shell&#39;s Cartesian product generation behavior is emulated:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">names</span><span> </span><span class="o">=</span><span> </span><span class="p">[</span><span class="s">&quot;</span><span class="s">foo</span><span class="s">&quot;</span><span class="p">,</span><span class="s">&quot;</span><span class="s">bar</span><span class="s">&quot;</span><span class="p">,</span><span class="s">&quot;</span><span class="s">baz</span><span class="s">&quot;</span><span class="p">]</span><span>
</span><span class="go">3-element Array{String,1}:
</span><span class="go"> &quot;foo&quot;
</span><span class="go"> &quot;bar&quot;
</span><span class="go"> &quot;baz&quot;
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">exts</span><span> </span><span class="o">=</span><span> </span><span class="p">[</span><span class="s">&quot;</span><span class="s">aux</span><span class="s">&quot;</span><span class="p">,</span><span class="s">&quot;</span><span class="s">log</span><span class="s">&quot;</span><span class="p">]</span><span>
</span><span class="go">2-element Array{String,1}:
</span><span class="go"> &quot;aux&quot;
</span><span class="go"> &quot;log&quot;
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="sb">`rm -f $names.$exts`</span><span>
</span><span class="go">`rm -f foo.aux foo.log bar.aux bar.log baz.aux baz.log`
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Since you can interpolate literal arrays, you can use this generative functionality without needing to create temporary array objects first:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="sb">`rm -rf $[&quot;foo&quot;,&quot;bar&quot;,&quot;baz&quot;,&quot;qux&quot;].$[&quot;aux&quot;,&quot;log&quot;,&quot;pdf&quot;]`</span><span>
</span><span class="go">`rm -rf foo.aux foo.log foo.pdf bar.aux bar.log bar.pdf baz.aux baz.log baz.pdf qux.aux qux.log qux.pdf`
</span></code></pre><a id="Quoting-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Quoting</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Inevitably, one wants to write commands that aren&#39;t quite so simple, and it becomes necessary to use quotes. Here&#39;s a simple example of a Perl one-liner at a shell prompt:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">sh$ perl -le &#39;$|=1; for (0..3) { print }&#39;
0
1
2
3</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The Perl expression needs to be in single quotes for two reasons: so that spaces don&#39;t break the expression into multiple shell words, and so that uses of Perl variables like <code>$|</code> (yes, that&#39;s the name of a variable in Perl), don&#39;t cause interpolation. In other instances, you may want to use double quotes so that interpolation <em>does</em> occur:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">sh$ first=&quot;A&quot;
sh$ second=&quot;B&quot;
sh$ perl -le &#39;$|=1; print for @ARGV&#39; &quot;1: $first&quot; &quot;2: $second&quot;
1: A
2: B</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In general, the Julia backtick syntax is carefully designed so that you can just cut-and-paste shell commands as is into backticks and they will work: the escaping, quoting, and interpolation behaviors are the same as the shell&#39;s. The only difference is that the interpolation is integrated and aware of Julia&#39;s notion of what is a single string value, and what is a container for multiple values. Let&#39;s try the above two examples in Julia:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="sb">`perl -le &#39;$|=1; for (0..3) { print }&#39;`</span><span>
</span><span class="go">`perl -le &#39;$|=1; for (0..3) { print }&#39;`
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">run</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span><span>
</span><span class="go">0
</span><span class="go">1
</span><span class="go">2
</span><span class="go">3
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">first</span><span> </span><span class="o">=</span><span> </span><span class="s">&quot;</span><span class="s">A</span><span class="s">&quot;</span><span class="p">;</span><span> </span><span class="n">second</span><span> </span><span class="o">=</span><span> </span><span class="s">&quot;</span><span class="s">B</span><span class="s">&quot;</span><span class="p">;</span><span>
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="sb">`perl -le &#39;print for @ARGV&#39; &quot;1: $first&quot; &quot;2: $second&quot;`</span><span>
</span><span class="go">`perl -le &#39;print for @ARGV&#39; &#39;1: A&#39; &#39;2: B&#39;`
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">run</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span><span>
</span><span class="go">1: A
</span><span class="go">2: B
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The results are identical, and Julia&#39;s interpolation behavior mimics the shell&#39;s with some improvements due to the fact that Julia supports first-class iterable objects while most shells use strings split on spaces for this, which introduces ambiguities. When trying to port shell commands to Julia, try cut and pasting first. Since Julia shows commands to you before running them, you can easily and safely just examine its interpretation without doing any damage.</p><a id="Pipelines-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Pipelines</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Shell metacharacters, such as <code>|</code>, <code>&amp;</code>, and <code>&gt;</code>, are not special inside of Julia&#39;s backticks: unlike in the shell, inside of Julia&#39;s backticks, a pipe is always just a pipe:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">run</span><span class="p">(</span><span class="sb">`echo hello | sort`</span><span class="p">)</span><span>
</span><span class="go">hello | sort
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This expression invokes the <code>echo</code> command with three words as arguments: &quot;hello&quot;, &quot;|&quot;, and &quot;sort&quot;. The result is that a single line is printed: &quot;hello | sort&quot;. Inside of backticks, a &quot;|&quot; is just a literal pipe character. How, then, does one construct a pipeline? Instead of using &quot;|&quot; inside of backticks, one uses <a href="../stdlib/base.html#Base.pipeline"><code>pipeline()</code></a>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">run</span><span class="p">(</span><span class="n">pipeline</span><span class="p">(</span><span class="sb">`echo hello`</span><span class="p">,</span><span> </span><span class="sb">`sort`</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="go">hello
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This pipes the output of the <code>echo</code> command to the <code>sort</code> command. Of course, this isn&#39;t terribly interesting since there&#39;s only one line to sort, but we can certainly do much more interesting things:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">run</span><span class="p">(</span><span class="n">pipeline</span><span class="p">(</span><span class="sb">`cut -d: -f3 /etc/passwd`</span><span class="p">,</span><span> </span><span class="sb">`sort -n`</span><span class="p">,</span><span> </span><span class="sb">`tail -n5`</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="go">210
</span><span class="go">211
</span><span class="go">212
</span><span class="go">213
</span><span class="go">214
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This prints the highest five user IDs on a UNIX system. The <code>cut</code>, <code>sort</code> and <code>tail</code> commands are all spawned as immediate children of the current <code>julia</code> process, with no intervening shell process. Julia itself does the work to setup pipes and connect file descriptors that is normally done by the shell. Since Julia does this itself, it retains better control and can do some things that shells cannot.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Julia can run multiple commands in parallel:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">run</span><span class="p">(</span><span class="sb">`echo hello`</span><span> </span><span class="o">&amp;</span><span> </span><span class="sb">`echo world`</span><span class="p">)</span><span>
</span><span class="go">world
</span><span class="go">hello
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The order of the output here is non-deterministic because the two <code>echo</code> processes are started nearly simultaneously, and race to make the first write to the <a href="../stdlib/io-network.html#Base.STDOUT"><code>STDOUT</code></a> descriptor they share with each other and the <code>julia</code> parent process. Julia lets you pipe the output from both of these processes to another program:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">run</span><span class="p">(</span><span class="n">pipeline</span><span class="p">(</span><span class="sb">`echo world`</span><span> </span><span class="o">&amp;</span><span> </span><span class="sb">`echo hello`</span><span class="p">,</span><span> </span><span class="sb">`sort`</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="go">hello
</span><span class="go">world
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In terms of UNIX plumbing, what&#39;s happening here is that a single UNIX pipe object is created and written to by both <code>echo</code> processes, and the other end of the pipe is read from by the <code>sort</code> command.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>IO redirection can be accomplished by passing keyword arguments stdin, stdout, and stderr to the <code>pipeline</code> function:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">pipeline</span><span class="p">(</span><span class="sb">`do_work`</span><span class="p">,</span><span> </span><span class="n">stdout</span><span class="o">=</span><span class="n">pipeline</span><span class="p">(</span><span class="sb">`sort`</span><span class="p">,</span><span> </span><span class="s">&quot;</span><span class="s">out.txt</span><span class="s">&quot;</span><span class="p">)</span><span class="p">,</span><span> </span><span class="n">stderr</span><span class="o">=</span><span class="s">&quot;</span><span class="s">errs.txt</span><span class="s">&quot;</span><span class="p">)</span><span>
</span></code></pre><a id="Avoiding-Deadlock-in-Pipelines-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>Avoiding Deadlock in Pipelines</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>When reading and writing to both ends of a pipeline from a single process, it is important to avoid forcing the kernel to buffer all of the data.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>For example, when reading all of the output from a command, call <code>readstring(out)</code>, not <code>wait(process)</code>, since the former will actively consume all of the data written by the process, whereas the latter will attempt to store the data in the kernel&#39;s buffers while waiting for a reader to be connected.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Another common solution is to separate the reader and writer of the pipeline into separate Tasks:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">writer</span><span> </span><span class="o">=</span><span> </span><span class="p">@</span><span class="n">async</span><span> </span><span class="n">writeall</span><span class="p">(</span><span class="n">process</span><span class="p">,</span><span> </span><span class="s">&quot;</span><span class="s">data</span><span class="s">&quot;</span><span class="p">)</span><span>
</span><span class="n">reader</span><span> </span><span class="o">=</span><span> </span><span class="p">@</span><span class="n">async</span><span> </span><span class="n">do_compute</span><span class="p">(</span><span class="n">readstring</span><span class="p">(</span><span class="n">process</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="n">wait</span><span class="p">(</span><span class="n">process</span><span class="p">)</span><span>
</span><span class="n">fetch</span><span class="p">(</span><span class="n">reader</span><span class="p">)</span><span>
</span></code></pre><a id="Complex-Example-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>Complex Example</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The combination of a high-level programming language, a first-class command abstraction, and automatic setup of pipes between processes is a powerful one. To give some sense of the complex pipelines that can be created easily, here are some more sophisticated examples, with apologies for the excessive use of Perl one-liners:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">prefixer</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span><span> </span><span class="n">sleep</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="sb">`perl -nle &#39;$|=1; print &quot;&#39;$prefix&#39; &quot;, $_; sleep &#39;$sleep&#39;;&#39;`</span><span class="p">;</span><span>
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">run</span><span class="p">(</span><span class="n">pipeline</span><span class="p">(</span><span class="sb">`perl -le &#39;$|=1; for(0..9){ print; sleep 1 }&#39;`</span><span class="p">,</span><span> </span><span class="n">prefixer</span><span class="p">(</span><span class="s">&quot;</span><span class="s">A</span><span class="s">&quot;</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span> </span><span class="o">&amp;</span><span> </span><span class="n">prefixer</span><span class="p">(</span><span class="s">&quot;</span><span class="s">B</span><span class="s">&quot;</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="go">A 0
</span><span class="go">B 1
</span><span class="go">A 2
</span><span class="go">B 3
</span><span class="go">A 4
</span><span class="go">B 5
</span><span class="go">A 6
</span><span class="go">B 7
</span><span class="go">A 8
</span><span class="go">B 9
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This is a classic example of a single producer feeding two concurrent consumers: one <code>perl</code> process generates lines with the numbers 0 through 9 on them, while two parallel processes consume that output, one prefixing lines with the letter &quot;A&quot;, the other with the letter &quot;B&quot;. Which consumer gets the first line is non-deterministic, but once that race has been won, the lines are consumed alternately by one process and then the other. (Setting <code>$|=1</code> in Perl causes each print statement to flush the <a href="../stdlib/io-network.html#Base.STDOUT"><code>STDOUT</code></a> handle, which is necessary for this example to work. Otherwise all the output is buffered and printed to the pipe at once, to be read by just one consumer process.)</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Here is an even more complex multi-stage producer-consumer example:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">run</span><span class="p">(</span><span class="n">pipeline</span><span class="p">(</span><span class="sb">`perl -le &#39;$|=1; for(0..9){ print; sleep 1 }&#39;`</span><span class="p">,</span><span>
</span><span class="gt">
           prefixer(&quot;X&quot;,3) &amp; prefixer(&quot;Y&quot;,3) &amp; prefixer(&quot;Z&quot;,3),
</span><span></span><span class="gt">
           prefixer(&quot;A&quot;,2) &amp; prefixer(&quot;B&quot;,2)))
</span><span></span><span class="go">A X 0
</span><span class="go">B Y 1
</span><span class="go">A Z 2
</span><span class="go">B X 3
</span><span class="go">A Y 4
</span><span class="go">B Z 5
</span><span class="go">A X 6
</span><span class="go">B Y 7
</span><span class="go">A Z 8
</span><span class="go">B X 9
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This example is similar to the previous one, except there are two stages of consumers, and the stages have different latency so they use a different number of parallel workers, to maintain saturated throughput.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>We strongly encourage you to try all these examples to see how they work.</p><footer><hr/><a class="previous" href="profile.html"><span class="direction">Previous</span><span class="title">Profiling</span></a><a class="next" href="stacktraces.html"><span class="direction">Next</span><span class="title">Stack Traces</span></a></footer></article></body></html>
