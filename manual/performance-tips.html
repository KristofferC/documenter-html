<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Documenter.jl</title><link href="../normalize.css" rel="stylesheet" type="text/css"/><link href="../style.css" rel="stylesheet" type="text/css"/><link href="../highlight.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="../require.js" data-main="../documenter.js"></script><script src="../search-index.js"></script></head><body><nav class="toc"><a href="http://julialang.org/"><img class="logo" src="http://docs.julialang.org/en/release-0.4/_static/julia-logo.svg" alt="\$pkgname.jl logo"/></a><h1>$pkgname.jl</h1><input type="text" placeholder="Search docs"/><ul><li><a class="toctext" href="../index.html">Overview</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../man/guide.html">Guide</a></li><li><a class="toctext" href="../man/examples.html">Examples</a></li><li><a class="toctext" href="../man/syntax.html">Syntax</a></li><li><a class="toctext" href="../man/doctests.html">Doctests</a></li><li><a class="toctext" href="../man/hosting.html">Hosting Documentation</a></li><li><a class="toctext" href="../man/latex.html"><span>$\LaTeX$</span> syntax</a></li><li><a class="toctext" href="../man/internals.html">Package Internals</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../lib/public.html">Public Documentation</a></li><li><a class="toctext" href="../lib/internals.html">Internal Documentation</a></li></ul></li><li><span class="toctext">Dynamic pages</span><ul><li><a class="toctext" href="../dynamic/code.html">Code examples</a></li><li><a class="toctext" href="../dynamic/admonitions.html">Admonitions &amp; Co</a></li><li><a class="toctext" href="../dynamic/styles.html">Demonstrating <em>styles</em> of MD elements</a></li><li><a class="toctext" href="../dynamic/bugs.html">Some existing bugs</a></li></ul></li><li><span class="toctext">JuliaDocs - Manual</span><ul><li><a class="toctext" href="arrays.html">Multi-dimensional Arrays</a></li><li><a class="toctext" href="calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="toctext" href="complex-and-rational-numbers.html">Complex and Rational Numbers</a></li><li><a class="toctext" href="constructors.html">Constructors</a></li><li><a class="toctext" href="control-flow.html">Control Flow</a></li><li><a class="toctext" href="conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="toctext" href="dates.html">Date and DateTime</a></li><li><a class="toctext" href="documentation.html">Documentation</a></li><li><a class="toctext" href="embedding.html">Embedding Julia</a></li><li><a class="toctext" href="faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="functions.html">Functions</a></li><li><a class="toctext" href="getting-started.html">Getting Started</a></li><li><a class="toctext" href="handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="index.html">The Julia Manual</a></li><li><a class="toctext" href="integers-and-floating-point-numbers.html">Integers and Floating-Point Numbers</a></li><li><a class="toctext" href="interacting-with-julia.html">Interacting With Julia</a></li><li><a class="toctext" href="interfaces.html">Interfaces</a></li><li><a class="toctext" href="introduction.html">Introduction</a></li><li><a class="toctext" href="linear-algebra.html">Linear algebra</a></li><li><a class="toctext" href="mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="metaprogramming.html">Metaprogramming</a></li><li><a class="toctext" href="methods.html">Methods</a></li><li><a class="toctext" href="modules.html">Modules</a></li><li><a class="toctext" href="networking-and-streams.html">Networking and Streams</a></li><li><a class="toctext" href="noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="packages.html">Packages</a></li><li><a class="toctext" href="parallel-computing.html">Parallel Computing</a></li><li class="current"><a class="toctext" href="performance-tips.html">Performance Tips</a><ul class="internal"><li><a class="toctext" href="#Avoid-global-variables-1">Avoid global variables</a></li><li><a class="toctext" href="#Measure-performance-with-[@time](@ref)-and-pay-attention-to-memory-allocation-1">Measure performance with <a href="@ref"><code>@time</code></a> and pay attention to memory allocation</a></li><li><a class="toctext" href="#Tools-1">Tools</a></li><li><a class="toctext" href="#Avoid-containers-with-abstract-type-parameters-1">Avoid containers with abstract type parameters</a></li><li><a class="toctext" href="#Type-declarations-1">Type declarations</a></li><li><a class="toctext" href="#Break-functions-into-multiple-definitions-1">Break functions into multiple definitions</a></li><li><a class="toctext" href="#Write-\"type-stable\"-functions-1">Write &quot;type-stable&quot; functions</a></li><li><a class="toctext" href="#Avoid-changing-the-type-of-a-variable-1">Avoid changing the type of a variable</a></li><li><a class="toctext" href="#Separate-kernel-functions-(aka,-function-barriers)-1">Separate kernel functions (aka, function barriers)</a></li><li><a class="toctext" href="#Types-with-values-as-parameters-1">Types with values-as-parameters</a></li><li><a class="toctext" href="#The-dangers-of-abusing-multiple-dispatch-(aka,-more-on-types-with-values-as-parameters)-1">The dangers of abusing multiple dispatch (aka, more on types with values-as-parameters)</a></li><li><a class="toctext" href="#Access-arrays-in-memory-order,-along-columns-1">Access arrays in memory order, along columns</a></li><li><a class="toctext" href="#Pre-allocating-outputs-1">Pre-allocating outputs</a></li><li><a class="toctext" href="#Avoid-string-interpolation-for-I/O-1">Avoid string interpolation for I/O</a></li><li><a class="toctext" href="#Optimize-network-I/O-during-parallel-execution-1">Optimize network I/O during parallel execution</a></li><li><a class="toctext" href="#Fix-deprecation-warnings-1">Fix deprecation warnings</a></li><li><a class="toctext" href="#Tweaks-1">Tweaks</a></li><li><a class="toctext" href="#Performance-Annotations-1">Performance Annotations</a></li><li><a class="toctext" href="#Treat-Subnormal-Numbers-as-Zeros-1">Treat Subnormal Numbers as Zeros</a></li><li><a class="toctext" href="#[@code_warntype](@ref)-1"><a href="@ref"><code>@code_warntype</code></a></a></li></ul></li><li><a class="toctext" href="profile.html">Profiling</a></li><li><a class="toctext" href="running-external-programs.html">Running External Programs</a></li><li><a class="toctext" href="stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="strings.html">Strings</a></li><li><a class="toctext" href="style-guide.html">Style Guide</a></li><li><a class="toctext" href="types.html">Types</a></li><li><a class="toctext" href="unicode-input.html">Unicode Input</a></li><li><a class="toctext" href="variables-and-scoping.html">Scope of Variables</a></li><li><a class="toctext" href="variables.html">Variables</a></li><li><a class="toctext" href="workflow-tips.html">Workflow Tips</a></li></ul></li><li><span class="toctext">JuliaDocs - Standard Libary</span><ul><li><a class="toctext" href="../stdlib/arrays.html">Arrays</a></li><li><a class="toctext" href="../stdlib/base.html">Essentials</a></li><li><a class="toctext" href="../stdlib/c.html">C Interface</a></li><li><a class="toctext" href="../stdlib/collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="../stdlib/constants.html">Constants</a></li><li><a class="toctext" href="../stdlib/dates.html">Dates and Time</a></li><li><a class="toctext" href="../stdlib/file.html">Filesystem</a></li><li><a class="toctext" href="../stdlib/index.html">The Julia Standard Library</a></li><li><a class="toctext" href="../stdlib/io-network.html">I/O and Network</a></li><li><a class="toctext" href="../stdlib/libc.html">C Standard Library</a></li><li><a class="toctext" href="../stdlib/libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="../stdlib/linalg.html">Linear Algebra</a></li><li><a class="toctext" href="../stdlib/math.html">Mathematics</a></li><li><a class="toctext" href="../stdlib/numbers.html">Numbers</a></li><li><a class="toctext" href="../stdlib/parallel.html">Tasks and Parallel Computing</a></li><li><a class="toctext" href="../stdlib/pkg.html">Package Manager Functions</a></li><li><a class="toctext" href="../stdlib/profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/punctuation.html">Punctuation</a></li><li><a class="toctext" href="../stdlib/simd-types.html">SIMD Support</a></li><li><a class="toctext" href="../stdlib/sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="../stdlib/stacktraces.html">StackTraces</a></li><li><a class="toctext" href="../stdlib/strings.html">Strings</a></li><li><a class="toctext" href="../stdlib/test.html">Unit Testing</a></li></ul></li><li><span class="toctext">JuliaDocs - DevDocs</span><ul><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/C.html">Developing/debugging Julia&#39;s C code</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../devdocs/julia.html">Documentation of Julia&#39;s Internals</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/promote-op.html">Operator-sensitive promotion</a></li><li><a class="toctext" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/types.html">More about types</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>JuliaDocs - Manual</li><li><a href="performance-tips.html">Performance Tips</a></li></ul><a class="edit-page" href="https://github.com/"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><a id="Performance-Tips-1"></a><div class="mdnote debug">Base.Markdown.Header{1}</div><h1>Performance Tips</h1><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In the following sections, we briefly go through a few techniques that can help make your Julia code run as fast as possible.</p><a id="Avoid-global-variables-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Avoid global variables</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>A global variable might have its value, and therefore its type, change at any point. This makes it difficult for the compiler to optimize code using global variables. Variables should be local, or passed as arguments to functions, whenever possible.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Any code that is performance critical or being benchmarked should be inside a function.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>We find that global names are frequently constants, and declaring them as such greatly improves performance:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="kd">const</span><span> </span><span class="n">DEFAULT_VAL</span><span> </span><span class="o">=</span><span> </span><span class="mi">0</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Uses of non-constant globals can be optimized by annotating their types at the point of use:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="kd">global</span><span> </span><span class="n">x</span><span>
</span><span class="n">y</span><span> </span><span class="o">=</span><span> </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="kt">Int</span><span> </span><span class="o">+</span><span> </span><span class="mi">1</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Writing functions is better style. It leads to more reusable code and clarifies what steps are being done, and what their inputs and outputs are.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p><strong>NOTE:</strong>  All code in the REPL is evaluated in global scope, so a variable defined and assigned at toplevel will be a <strong>global</strong> variable.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In the following REPL session:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">x</span><span> </span><span class="o">=</span><span> </span><span class="mf">1.0</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>is equivalent to:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="kd">global</span><span> </span><span class="n">x</span><span> </span><span class="o">=</span><span> </span><span class="mf">1.0</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>so all the performance issues discussed previously apply.</p><a id="Measure-performance-with-[@time](@ref)-and-pay-attention-to-memory-allocation-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Measure performance with <a href="@ref"><code>@time</code></a> and pay attention to memory allocation</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The most useful tool for measuring performance is the <a href="../stdlib/base.html#Base.@time"><code>@time</code></a> macro. The following example illustrates good working style:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="k">function</span><span class="nf"> </span><span class="nf">f</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span>
</span><span class="gt">
           s = 0
</span><span></span><span class="gt">
           for i = 1:n
</span><span></span><span class="gt">
               s += i/2
</span><span></span><span class="gt">
           end
</span><span></span><span class="gt">
           s
</span><span></span><span class="gt">
       end
</span><span></span><span class="go">f (generic function with 1 method)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="p">@</span><span class="n">time</span><span> </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span>
</span><span class="go">elapsed time: 0.004710563 seconds (93504 bytes allocated)
</span><span class="go">0.5
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="p">@</span><span class="n">time</span><span> </span><span class="n">f</span><span class="p">(</span><span class="mi">10</span><span class="o">^</span><span class="mi">6</span><span class="p">)</span><span>
</span><span class="go">elapsed time: 0.04123202 seconds (32002136 bytes allocated)
</span><span class="go">2.5000025e11
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>On the first call (<code>@time f(1)</code>), <code>f</code> gets compiled.  (If you&#39;ve not yet used <a href="../stdlib/base.html#Base.@time"><code>@time</code></a> in this session, it will also compile functions needed for timing.)  You should not take the results of this run seriously. For the second run, note that in addition to reporting the time, it also indicated that a large amount of memory was allocated. This is the single biggest advantage of <a href="../stdlib/base.html#Base.@time"><code>@time</code></a> vs. functions like <a href="../stdlib/base.html#Base.tic"><code>tic()</code></a> and <a href="../stdlib/base.html#Base.toc"><code>toc()</code></a>, which only report time.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Unexpected memory allocation is almost always a sign of some problem with your code, usually a problem with type-stability. Consequently, in addition to the allocation itself, it&#39;s very likely that the code generated for your function is far from optimal. Take such indications seriously and follow the advice below.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>As a teaser, note that an improved version of this function allocates no memory (except to pass back the result back to the REPL) and has an order of magnitude faster execution after the first call:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="p">@</span><span class="n">time</span><span> </span><span class="n">f_improved</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span>   </span><span class="c"># first call</span><span>
</span><span class="go">elapsed time: 0.003702172 seconds (78944 bytes allocated)
</span><span class="go">0.5
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="p">@</span><span class="n">time</span><span> </span><span class="n">f_improved</span><span class="p">(</span><span class="mi">10</span><span class="o">^</span><span class="mi">6</span><span class="p">)</span><span>
</span><span class="go">elapsed time: 0.004313644 seconds (112 bytes allocated)
</span><span class="go">2.5000025e11
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Below you&#39;ll learn how to spot the problem with <code>f</code> and how to fix it.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In some situations, your function may need to allocate memory as part of its operation, and this can complicate the simple picture above. In such cases, consider using one of the <a href="@ref">tools</a> below to diagnose problems, or write a version of your function that separates allocation from its algorithmic aspects (see <a href="performance-tips.html#Pre-allocating-outputs-1">Pre-allocating outputs</a>).</p><a id="Tools-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Tools</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Julia and its package ecosystem includes tools that may help you diagnose problems and improve the performance of your code:</p><div class="mdnote debug">Base.Markdown.List</div><ul><li><p><a href="@ref">Profiling</a> allows you to measure the performance of your running code and identify lines that serve as bottlenecks.  For complex projects, the <a href="https://github.com/timholy/ProfileView.jl">ProfileView</a> package can help you visualize your profiling results.</p></li><li><p>Unexpectedly-large memory allocations–as reported by <a href="../stdlib/base.html#Base.@time"><code>@time</code></a>, <a href="../stdlib/base.html#Base.@allocated"><code>@allocated</code></a>, or the profiler (through calls to the garbage-collection routines)–hint that there might be issues with your code.  If you don&#39;t see another reason for the allocations, suspect a type problem.  You can also start Julia with the <code>--track-allocation=user</code> option and examine the resulting <code>*.mem</code> files to see information about where those allocations occur.  See <a href="profile.html#Memory-allocation-analysis-1">Memory allocation analysis</a>.</p></li><li><p><code>@code_warntype</code> generates a representation of your code that can be helpful in finding expressions that result in type uncertainty. See <a href="@ref">@code_warntype</a> below.</p></li><li><p>The <a href="https://github.com/tonyhffong/Lint.jl">Lint</a> and <a href="https://github.com/astrieanna/TypeCheck.jl">TypeCheck</a> packages can also warn you of certain types of programming errors.</p></li></ul><a id="Avoid-containers-with-abstract-type-parameters-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Avoid containers with abstract type parameters</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>When working with parameterized types, including arrays, it is best to avoid parameterizing with abstract types where possible.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Consider the following:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">a</span><span> </span><span class="o">=</span><span> </span><span class="n">Real</span><span class="p">[</span><span class="p">]</span><span>    </span><span class="c"># typeof(a) = Array{Real,1}</span><span>
</span><span class="k">if</span><span> </span><span class="p">(</span><span class="n">f</span><span> </span><span class="o">=</span><span> </span><span class="n">rand</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span> </span><span class="o">&lt;</span><span> </span><span class="o">.</span><span class="mi">8</span><span>
</span><span>    </span><span class="n">push!</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span> </span><span class="n">f</span><span class="p">)</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Because <code>a</code> is a an array of abstract type <code>Real</code>, it must be able to hold any Real value.  Since <code>Real</code> objects can be of arbitrary size and structure, <code>a</code> must be represented as an array of pointers to individually allocated <code>Real</code> objects.  Because <code>f</code> will always be a <a href="../stdlib/numbers.html#Core.Float64"><code>Float64</code></a>, we should instead, use:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">a</span><span> </span><span class="o">=</span><span> </span><span class="kt">Float64</span><span class="p">[</span><span class="p">]</span><span> </span><span class="c"># typeof(a) = Array{Float64,1}</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>which will create a contiguous block of 64-bit floating-point values that can be manipulated efficiently.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>See also the discussion under <a href="types.html#Parametric-Types-1">Parametric Types</a>.</p><a id="Type-declarations-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Type declarations</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In many languages with optional type declarations, adding declarations is the principal way to make code run faster. This is <em>not</em> the case in Julia. In Julia, the compiler generally knows the types of all function arguments, local variables, and expressions. However, there are a few specific instances where declarations are helpful.</p><a id="Avoid-fields-with-abstract-type-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>Avoid fields with abstract type</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Types can be declared without specifying the types of their fields:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="k">type</span><span class="nc"> </span><span class="nc">MyAmbiguousType</span><span>
</span><span class="gt">
           a
</span><span></span><span class="gt">
       end
</span><span></span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This allows <code>a</code> to be of any type. This can often be useful, but it does have a downside: for objects of type <code>MyAmbiguousType</code>, the compiler will not be able to generate high-performance code.  The reason is that the compiler uses the types of objects, not their values, to determine how to build code. Unfortunately, very little can be inferred about an object of type <code>MyAmbiguousType</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">b</span><span> </span><span class="o">=</span><span> </span><span class="n">MyAmbiguousType</span><span class="p">(</span><span class="s">&quot;</span><span class="s">Hello</span><span class="s">&quot;</span><span class="p">)</span><span>
</span><span class="go">MyAmbiguousType(&quot;Hello&quot;)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">c</span><span> </span><span class="o">=</span><span> </span><span class="n">MyAmbiguousType</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span><span>
</span><span class="go">MyAmbiguousType(17)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span>
</span><span class="go">MyAmbiguousType
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span>
</span><span class="go">MyAmbiguousType
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p><code>b</code> and <code>c</code> have the same type, yet their underlying representation of data in memory is very different. Even if you stored just numeric values in field <code>a</code>, the fact that the memory representation of a <code>UInt8</code> differs from a <code>Float64</code> also means that the CPU needs to handle them using two different kinds of instructions.  Since the required information is not available in the type, such decisions have to be made at run-time. This slows performance.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>You can do better by declaring the type of <code>a</code>. Here, we are focused on the case where <code>a</code> might be any one of several types, in which case the natural solution is to use parameters. For example:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="k">type</span><span class="nc"> </span><span class="nc">MyType</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">AbstractFloat</span><span class="p">}</span><span>
</span><span class="gt">
         a::T
</span><span></span><span class="gt">
       end
</span><span></span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This is a better choice than</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="k">type</span><span class="nc"> </span><span class="nc">MyStillAmbiguousType</span><span>
</span><span class="gt">
         a::AbstractFloat
</span><span></span><span class="gt">
       end
</span><span></span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>because the first version specifies the type of <code>a</code> from the type of the wrapper object.  For example:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">m</span><span> </span><span class="o">=</span><span> </span><span class="n">MyType</span><span class="p">(</span><span class="mf">3.2</span><span class="p">)</span><span>
</span><span class="go">MyType{Float64}(3.2)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">t</span><span> </span><span class="o">=</span><span> </span><span class="n">MyStillAmbiguousType</span><span class="p">(</span><span class="mf">3.2</span><span class="p">)</span><span>
</span><span class="go">MyStillAmbiguousType(3.2)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span>
</span><span class="go">MyType{Float64}
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span>
</span><span class="go">MyStillAmbiguousType
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The type of field <code>a</code> can be readily determined from the type of <code>m</code>, but not from the type of <code>t</code>.  Indeed, in <code>t</code> it&#39;s possible to change the type of field <code>a</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">a</span><span class="p">)</span><span>
</span><span class="go">Float64
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">t</span><span class="o">.</span><span class="n">a</span><span> </span><span class="o">=</span><span> </span><span class="mf">4.5f0</span><span>
</span><span class="go">4.5f0
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">a</span><span class="p">)</span><span>
</span><span class="go">Float32
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In contrast, once <code>m</code> is constructed, the type of <code>m.a</code> cannot change:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">m</span><span class="o">.</span><span class="n">a</span><span> </span><span class="o">=</span><span> </span><span class="mf">4.5f0</span><span>
</span><span class="go">4.5f0
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">a</span><span class="p">)</span><span>
</span><span class="go">Float64
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The fact that the type of <code>m.a</code> is known from <code>m</code>&#39;s type–coupled with the fact that its type cannot change mid-function–allows the compiler to generate highly-optimized code for objects like <code>m</code> but not for objects like <code>t</code>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Of course, all of this is true only if we construct <code>m</code> with a concrete type.  We can break this by explicitly constructing it with an abstract type:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">m</span><span> </span><span class="o">=</span><span> </span><span class="n">MyType</span><span class="p">{</span><span class="n">AbstractFloat</span><span class="p">}</span><span class="p">(</span><span class="mf">3.2</span><span class="p">)</span><span>
</span><span class="go">MyType{AbstractFloat}(3.2)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">a</span><span class="p">)</span><span>
</span><span class="go">Float64
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">m</span><span class="o">.</span><span class="n">a</span><span> </span><span class="o">=</span><span> </span><span class="mf">4.5f0</span><span>
</span><span class="go">4.5f0
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">a</span><span class="p">)</span><span>
</span><span class="go">Float32
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>For all practical purposes, such objects behave identically to those of <code>MyStillAmbiguousType</code>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>It&#39;s quite instructive to compare the sheer amount code generated for a simple function</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">func</span><span class="p">(</span><span class="n">m</span><span class="p">:</span><span class="p">:</span><span class="n">MyType</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">m</span><span class="o">.</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>using</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">code_llvm</span><span class="p">(</span><span class="n">func</span><span class="p">,</span><span class="p">(</span><span class="n">MyType</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span><span class="p">,</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="n">code_llvm</span><span class="p">(</span><span class="n">func</span><span class="p">,</span><span class="p">(</span><span class="n">MyType</span><span class="p">{</span><span class="n">AbstractFloat</span><span class="p">}</span><span class="p">,</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="n">code_llvm</span><span class="p">(</span><span class="n">func</span><span class="p">,</span><span class="p">(</span><span class="n">MyType</span><span class="p">,</span><span class="p">)</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>For reasons of length the results are not shown here, but you may wish to try this yourself. Because the type is fully-specified in the first case, the compiler doesn&#39;t need to generate any code to resolve the type at run-time.  This results in shorter and faster code.</p><a id="Avoid-fields-with-abstract-containers-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>Avoid fields with abstract containers</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The same best practices also work for container types:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="k">type</span><span class="nc"> </span><span class="nc">MySimpleContainer</span><span class="p">{</span><span class="n">A</span><span class="o">&lt;:</span><span class="n">AbstractVector</span><span class="p">}</span><span>
</span><span class="gt">
         a::A
</span><span></span><span class="gt">
       end
</span><span></span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="k">type</span><span class="nc"> </span><span class="nc">MyAmbiguousContainer</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span>
</span><span class="gt">
         a::AbstractVector{T}
</span><span></span><span class="gt">
       end
</span><span></span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>For example:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">c</span><span> </span><span class="o">=</span><span> </span><span class="n">MySimpleContainer</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">)</span><span class="p">;</span><span>
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span>
</span><span class="go">MySimpleContainer{UnitRange{Int64}}
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">c</span><span> </span><span class="o">=</span><span> </span><span class="n">MySimpleContainer</span><span class="p">(</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">;</span><span class="p">]</span><span class="p">)</span><span class="p">;</span><span>
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span>
</span><span class="go">MySimpleContainer{Array{Int64,1}}
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">b</span><span> </span><span class="o">=</span><span> </span><span class="n">MyAmbiguousContainer</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">)</span><span class="p">;</span><span>
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span>
</span><span class="go">MyAmbiguousContainer{Int64}
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">b</span><span> </span><span class="o">=</span><span> </span><span class="n">MyAmbiguousContainer</span><span class="p">(</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">;</span><span class="p">]</span><span class="p">)</span><span class="p">;</span><span>
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span>
</span><span class="go">MyAmbiguousContainer{Int64}
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>For <code>MySimpleContainer</code>, the object is fully-specified by its type and parameters, so the compiler can generate optimized functions. In most instances, this will probably suffice.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>While the compiler can now do its job perfectly well, there are cases where <em>you</em> might wish that your code could do different things depending on the <em>element type</em> of <code>a</code>.  Usually the best way to achieve this is to wrap your specific operation (here, <code>foo</code>) in a separate function:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">function</span><span class="nf"> </span><span class="nf">sumfoo</span><span class="p">(</span><span class="n">c</span><span class="p">:</span><span class="p">:</span><span class="n">MySimpleContainer</span><span class="p">)</span><span>
</span><span>    </span><span class="n">s</span><span> </span><span class="o">=</span><span> </span><span class="mi">0</span><span>
</span><span class="k">for</span><span> </span><span class="n">x</span><span> </span><span class="k">in</span><span> </span><span class="n">c</span><span class="o">.</span><span class="n">a</span><span>
</span><span>    </span><span class="n">s</span><span> </span><span class="o">+</span><span class="o">=</span><span> </span><span class="n">foo</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span>
</span><span class="k">end</span><span>
</span><span class="n">s</span><span>
</span><span class="k">end</span><span>
</span><span>
</span><span class="n">foo</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">Integer</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">x</span><span>
</span><span class="n">foo</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">AbstractFloat</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">round</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This keeps things simple, while allowing the compiler to generate optimized code in all cases.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>However, there are cases where you may need to declare different versions of the outer function for different element types of <code>a</code>. You could do it like this:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">function myfun{T&lt;:AbstractFloat}(c::MySimpleContainer{Vector{T}})
    ...
end
function myfun{T&lt;:Integer}(c::MySimpleContainer{Vector{T}})
    ...
end</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This works fine for <code>Vector{T}</code>, but we&#39;d also have to write explicit versions for <code>UnitRange{T}</code> or other abstract types. To prevent such tedium, you can use two parameters in the declaration of <code>MyContainer</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span class="go">type MyContainer{T, A&lt;:AbstractVector}
</span><span class="go">    a::A
</span><span class="go">end
</span><span class="go">MyContainer(v::AbstractVector) = MyContainer{eltype(v), typeof(v)}(v)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">b</span><span> </span><span class="o">=</span><span> </span><span class="n">MyContainer</span><span class="p">(</span><span class="mf">1.3</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span><span class="p">;</span><span>
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span>
</span><span class="go">MyContainer{Float64,UnitRange{Float64}}
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Note the somewhat surprising fact that <code>T</code> doesn&#39;t appear in the declaration of field <code>a</code>, a point that we&#39;ll return to in a moment. With this approach, one can write functions such as:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span class="go">function myfunc{T&lt;:Integer, A&lt;:AbstractArray}(c::MyContainer{T,A})
</span><span class="go">    return c.a[1]+1
</span><span class="go">end
</span><span class="go"># Note: because we can only define MyContainer for
</span><span class="go"># A&lt;:AbstractArray, and any unspecified parameters are arbitrary,
</span><span class="go"># the previous could have been written more succinctly as
</span><span class="go">#     function myfunc{T&lt;:Integer}(c::MyContainer{T})
</span><span class="go">
</span><span class="go">function myfunc{T&lt;:AbstractFloat}(c::MyContainer{T})
</span><span class="go">    return c.a[1]+2
</span><span class="go">end
</span><span class="go">
</span><span class="go">function myfunc{T&lt;:Integer}(c::MyContainer{T,Vector{T}})
</span><span class="go">    return c.a[1]+3
</span><span class="go">end
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">myfunc</span><span class="p">(</span><span class="n">MyContainer</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="go">2
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">myfunc</span><span class="p">(</span><span class="n">MyContainer</span><span class="p">(</span><span class="mf">1.0</span><span class="p">:</span><span class="mi">3</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="go">3.0
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">myfunc</span><span class="p">(</span><span class="n">MyContainer</span><span class="p">(</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="go">4
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>As you can see, with this approach it&#39;s possible to specialize on both the element type <code>T</code> and the array type <code>A</code>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>However, there&#39;s one remaining hole: we haven&#39;t enforced that <code>A</code> has element type <code>T</code>, so it&#39;s perfectly possible to construct an object like this:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">b</span><span> </span><span class="o">=</span><span> </span><span class="n">MyContainer</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span> </span><span class="n">UnitRange</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span><span class="p">}</span><span class="p">(</span><span class="mf">1.3</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span><span class="p">;</span><span>
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span>
</span><span class="go">MyContainer{Int64,UnitRange{Float64}}
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>To prevent this, we can add an inner constructor:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span class="go">type MyBetterContainer{T&lt;:Real, A&lt;:AbstractVector}
</span><span class="go">    a::A
</span><span class="go">
</span><span class="go">    MyBetterContainer(v::AbstractVector{T}) = new(v)
</span><span class="go">end
</span><span class="go">MyBetterContainer(v::AbstractVector) = MyBetterContainer{eltype(v),typeof(v)}(v)
</span><span class="go">
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">b</span><span> </span><span class="o">=</span><span> </span><span class="n">MyBetterContainer</span><span class="p">(</span><span class="mf">1.3</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span><span class="p">;</span><span>
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span>
</span><span class="go">MyBetterContainer{Float64,UnitRange{Float64}}
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">b</span><span> </span><span class="o">=</span><span> </span><span class="n">MyBetterContainer</span><span class="p">{</span><span class="kt">Int64</span><span class="p">,</span><span> </span><span class="n">UnitRange</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span><span class="p">}</span><span class="p">(</span><span class="mf">1.3</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span><span class="p">;</span><span>
</span><span class="go">ERROR: no method MyBetterContainer(UnitRange{Float64},)
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The inner constructor requires that the element type of <code>A</code> be <code>T</code>.</p><a id="Annotate-values-taken-from-untyped-locations-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>Annotate values taken from untyped locations</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>It is often convenient to work with data structures that may contain values of any type (arrays of type <code>Array{Any}</code>). But, if you&#39;re using one of these structures and happen to know the type of an element, it helps to share this knowledge with the compiler:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">function foo(a::Array{Any,1})
    x = a[1]::Int32
    b = x+1
    ...
end</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Here, we happened to know that the first element of <code>a</code> would be an <code>Int32</code>. Making an annotation like this has the added benefit that it will raise a run-time error if the value is not of the expected type, potentially catching certain bugs earlier.</p><a id="Declare-types-of-keyword-arguments-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>Declare types of keyword arguments</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Keyword arguments can have declared types:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">function with_keyword(x; name::Int = 1)
    ...
end</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Functions are specialized on the types of keyword arguments, so these declarations will not affect performance of code inside the function. However, they will reduce the overhead of calls to the function that include keyword arguments.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Functions with keyword arguments have near-zero overhead for call sites that pass only positional arguments.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Passing dynamic lists of keyword arguments, as in <code>f(x; keywords...)</code>, can be slow and should be avoided in performance-sensitive code.</p><a id="Break-functions-into-multiple-definitions-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Break functions into multiple definitions</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Writing a function as many small definitions allows the compiler to directly call the most applicable code, or even inline it.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Here is an example of a &quot;compound function&quot; that should really be written as multiple definitions:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">function</span><span class="nf"> </span><span class="nf">norm</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span>
</span><span>    </span><span class="k">if</span><span> </span><span class="nb">isa</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span> </span><span class="n">Vector</span><span class="p">)</span><span>
</span><span>        </span><span class="k">return</span><span> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">real</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">A</span><span class="p">)</span><span class="p">)</span><span class="p">)</span><span>
</span><span>    </span><span class="k">elseif</span><span> </span><span class="nb">isa</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span> </span><span class="n">Matrix</span><span class="p">)</span><span>
</span><span>        </span><span class="k">return</span><span> </span><span class="n">max</span><span class="p">(</span><span class="n">svd</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="p">)</span><span>
</span><span>    </span><span class="k">else</span><span>
</span><span>        </span><span class="nb">error</span><span class="p">(</span><span class="s">&quot;</span><span class="s">norm: invalid argument</span><span class="s">&quot;</span><span class="p">)</span><span>
</span><span>    </span><span class="k">end</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This can be written more concisely and efficiently as:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">Vector</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">real</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">)</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span><span class="p">:</span><span class="p">:</span><span class="n">Matrix</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">max</span><span class="p">(</span><span class="n">svd</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="p">)</span><span>
</span></code></pre><a id="Write-\"type-stable\"-functions-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Write &quot;type-stable&quot; functions</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>When possible, it helps to ensure that a function always returns a value of the same type. Consider the following definition:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">pos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">x</span><span> </span><span class="o">&lt;</span><span> </span><span class="mi">0</span><span> </span><span class="o">?</span><span> </span><span class="mi">0</span><span> </span><span class="p">:</span><span> </span><span class="n">x</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Although this seems innocent enough, the problem is that <code>0</code> is an integer (of type <code>Int</code>) and <code>x</code> might be of any type. Thus, depending on the value of <code>x</code>, this function might return a value of either of two types. This behavior is allowed, and may be desirable in some cases. But it can easily be fixed as follows:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">pos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">x</span><span> </span><span class="o">&lt;</span><span> </span><span class="mi">0</span><span> </span><span class="o">?</span><span> </span><span class="n">zero</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span> </span><span class="p">:</span><span> </span><span class="n">x</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>There is also a <a href="../stdlib/numbers.html#Base.one"><code>one()</code></a> function, and a more general <a href="../stdlib/base.html#Base.oftype"><code>oftype(x,y)</code></a> function, which returns <code>y</code> converted to the type of <code>x</code>.</p><a id="Avoid-changing-the-type-of-a-variable-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Avoid changing the type of a variable</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>An analogous &quot;type-stability&quot; problem exists for variables used repeatedly within a function:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">function</span><span class="nf"> </span><span class="nf">foo</span><span class="p">(</span><span class="p">)</span><span>
</span><span>    </span><span class="n">x</span><span> </span><span class="o">=</span><span> </span><span class="mi">1</span><span>
</span><span>    </span><span class="k">for</span><span> </span><span class="n">i</span><span> </span><span class="o">=</span><span> </span><span class="mi">1</span><span class="p">:</span><span class="mi">10</span><span>
</span><span>        </span><span class="n">x</span><span> </span><span class="o">=</span><span> </span><span class="n">x</span><span class="o">/</span><span class="n">bar</span><span class="p">(</span><span class="p">)</span><span>
</span><span>    </span><span class="k">end</span><span>
</span><span>    </span><span class="k">return</span><span> </span><span class="n">x</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Local variable <code>x</code> starts as an integer, and after one loop iteration becomes a floating-point number (the result of <a href="../stdlib/math.html#Base./"><code>/</code></a> operator). This makes it more difficult for the compiler to optimize the body of the loop. There are several possible fixes:</p><div class="mdnote debug">Base.Markdown.List</div><ul><li><p>Initialize <code>x</code> with <code>x = 1.0</code></p></li><li><p>Declare the type of <code>x</code>: <code>x::Float64 = 1</code></p></li><li><p>Use an explicit conversion: <code>x = one(T)</code></p></li></ul><a id="Separate-kernel-functions-(aka,-function-barriers)-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Separate kernel functions (aka, function barriers)</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Many functions follow a pattern of performing some set-up work, and then running many iterations to perform a core computation. Where possible, it is a good idea to put these core computations in separate functions. For example, the following contrived function returns an array of a randomly-chosen type:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">function</span><span class="nf"> </span><span class="nf">strange_twos</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span>
</span><span>    </span><span class="n">a</span><span> </span><span class="o">=</span><span> </span><span class="n">Array</span><span class="p">(</span><span class="n">rand</span><span class="p">(</span><span class="kt">Bool</span><span class="p">)</span><span> </span><span class="o">?</span><span> </span><span class="kt">Int64</span><span> </span><span class="p">:</span><span> </span><span class="kt">Float64</span><span class="p">,</span><span> </span><span class="n">n</span><span class="p">)</span><span>
</span><span>    </span><span class="k">for</span><span> </span><span class="n">i</span><span> </span><span class="o">=</span><span> </span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span>
</span><span>        </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span> </span><span class="o">=</span><span> </span><span class="mi">2</span><span>
</span><span>    </span><span class="k">end</span><span>
</span><span>    </span><span class="k">return</span><span> </span><span class="n">a</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This should be written as:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">function</span><span class="nf"> </span><span class="nf">fill_twos</span><span class="o">!</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span>
</span><span>    </span><span class="k">for</span><span> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">length</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span>
</span><span>        </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span> </span><span class="o">=</span><span> </span><span class="mi">2</span><span>
</span><span>    </span><span class="k">end</span><span>
</span><span class="k">end</span><span>
</span><span>
</span><span class="k">function</span><span class="nf"> </span><span class="nf">strange_twos</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span>
</span><span>    </span><span class="n">a</span><span> </span><span class="o">=</span><span> </span><span class="n">Array</span><span class="p">(</span><span class="n">rand</span><span class="p">(</span><span class="kt">Bool</span><span class="p">)</span><span> </span><span class="o">?</span><span> </span><span class="kt">Int64</span><span> </span><span class="p">:</span><span> </span><span class="kt">Float64</span><span class="p">,</span><span> </span><span class="n">n</span><span class="p">)</span><span>
</span><span>    </span><span class="n">fill_twos!</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span>
</span><span>    </span><span class="k">return</span><span> </span><span class="n">a</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Julia&#39;s compiler specializes code for argument types at function boundaries, so in the original implementation it does not know the type of <code>a</code> during the loop (since it is chosen randomly). Therefore the second version is generally faster since the inner loop can be recompiled as part of <code>fill_twos!</code> for different types of <code>a</code>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The second form is also often better style and can lead to more code reuse.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This pattern is used in several places in the standard library. For example, see <code>hvcat_fill</code> in <a href="https://github.com/JuliaLang/julia/blob/master/base/abstractarray.jl">abstractarray.jl</a>, or the <code>fill!</code> function, which we could have used instead of writing our own <code>fill_twos!</code>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Functions like <code>strange_twos</code> occur when dealing with data of uncertain type, for example data loaded from an input file that might contain either integers, floats, strings, or something else.</p><a id="Types-with-values-as-parameters-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Types with values-as-parameters</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Let&#39;s say you want to create an <code>N</code>-dimensional array that has size 3 along each axis.  Such arrays can be created like this:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">A</span><span> </span><span class="o">=</span><span> </span><span class="n">fill</span><span class="p">(</span><span class="mf">5.0</span><span class="p">,</span><span> </span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span> </span><span class="mi">3</span><span class="p">)</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This approach works very well: the compiler can figure out that <code>A</code> is an <code>Array{Float64,2}</code> because it knows the type of the fill value (<code>5.0::Float64</code>) and the dimensionality (<code>(3, 3)::NTuple{2,Int}</code>). This implies that the compiler can generate very efficient code for any future usage of <code>A</code> in the same function.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>But now let&#39;s say you want to write a function that creates a 3×3×... array in arbitrary dimensions; you might be tempted to write a function</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">function</span><span class="nf"> </span><span class="nf">array3</span><span class="p">(</span><span class="n">fillval</span><span class="p">,</span><span> </span><span class="n">N</span><span class="p">)</span><span>
</span><span>    </span><span class="n">fill</span><span class="p">(</span><span class="n">fillval</span><span class="p">,</span><span> </span><span class="nb">ntuple</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="mi">3</span><span class="p">,</span><span> </span><span class="n">N</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This works, but (as you can verify for yourself using <code>@code_warntype array3(5.0, 2)</code>) the problem is that the output type cannot be inferred: the argument <code>N</code> is a <em>value</em> of type <code>Int</code>, and type-inference does not (and cannot) predict its value in advance. This means that code using the output of this function has to be conservative, checking the type on each access of <code>A</code>; such code will be very slow.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Now, one very good way to solve such problems is by using the <a href="@ref">function-barrier technique</a>. However, in some cases you might want to eliminate the type-instability altogether.  In such cases, one approach is to pass the dimensionality as a parameter, for example through <code>Val{T}</code> (see <a href="types.html#\"Value-types\"-1">&quot;Value types&quot;</a>):</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">function</span><span class="nf"> </span><span class="nf">array3</span><span class="p">{</span><span class="n">N</span><span class="p">}</span><span class="p">(</span><span class="n">fillval</span><span class="p">,</span><span> </span><span class="p">:</span><span class="p">:</span><span class="n">Type</span><span class="p">{</span><span class="n">Val</span><span class="p">{</span><span class="n">N</span><span class="p">}</span><span class="p">}</span><span class="p">)</span><span>
</span><span>    </span><span class="n">fill</span><span class="p">(</span><span class="n">fillval</span><span class="p">,</span><span> </span><span class="nb">ntuple</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="mi">3</span><span class="p">,</span><span> </span><span class="n">Val</span><span class="p">{</span><span class="n">N</span><span class="p">}</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Julia has a specialized version of <code>ntuple</code> that accepts a <code>Val{::Int}</code> as the second parameter; by passing <code>N</code> as a type-parameter, you make its &quot;value&quot; known to the compiler. Consequently, this version of <code>array3</code> allows the compiler to predict the return type.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>However, making use of such techniques can be surprisingly subtle. For example, it would be of no help if you called <code>array3</code> from a function like this:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">function</span><span class="nf"> </span><span class="nf">call_array3</span><span class="p">(</span><span class="n">fillval</span><span class="p">,</span><span> </span><span class="n">n</span><span class="p">)</span><span>
</span><span>    </span><span class="n">A</span><span> </span><span class="o">=</span><span> </span><span class="n">array3</span><span class="p">(</span><span class="n">fillval</span><span class="p">,</span><span> </span><span class="n">Val</span><span class="p">{</span><span class="n">n</span><span class="p">}</span><span class="p">)</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Here, you&#39;ve created the same problem all over again: the compiler can&#39;t guess the type of <code>n</code>, so it doesn&#39;t know the type of <code>Val{n}</code>.  Attempting to use <code>Val</code>, but doing so incorrectly, can easily make performance <em>worse</em> in many situations.  (Only in situations where you&#39;re effectively combining <code>Val</code> with the function-barrier trick, to make the kernel function more efficient, should code like the above be used.)</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>An example of correct usage of <code>Val</code> would be:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">function</span><span class="nf"> </span><span class="nf">filter3</span><span class="p">{</span><span class="n">T</span><span class="p">,</span><span class="n">N</span><span class="p">}</span><span class="p">(</span><span class="n">A</span><span class="p">:</span><span class="p">:</span><span class="n">AbstractArray</span><span class="p">{</span><span class="n">T</span><span class="p">,</span><span class="n">N</span><span class="p">}</span><span class="p">)</span><span>
</span><span>    </span><span class="n">kernel</span><span> </span><span class="o">=</span><span> </span><span class="n">array3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span> </span><span class="n">Val</span><span class="p">{</span><span class="n">N</span><span class="p">}</span><span class="p">)</span><span>
</span><span>    </span><span class="n">filter</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span> </span><span class="n">kernel</span><span class="p">)</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In this example, <code>N</code> is passed as a parameter, so its &quot;value&quot; is known to the compiler.  Essentially, <code>Val{T}</code> works only when <code>T</code> is either hard-coded (<code>Val{3}</code>) or already specified in the type-domain.</p><a id="The-dangers-of-abusing-multiple-dispatch-(aka,-more-on-types-with-values-as-parameters)-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>The dangers of abusing multiple dispatch (aka, more on types with values-as-parameters)</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Once one learns to appreciate multiple dispatch, there&#39;s an understandable tendency to go crazy and try to use it for everything. For example, you might imagine using it to store information, e.g.</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">immutable Car{Make,Model}
    year::Int
    ...more fields...
end</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>and then dispatch on objects like <code>Car{:Honda,:Accord}(year, args...)</code>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This might be worthwhile when the following are true:</p><div class="mdnote debug">Base.Markdown.List</div><ul><li><p>You require CPU-intensive processing on each <code>Car</code>, and it becomes vastly more efficient if you know the <code>Make</code> and <code>Model</code> at compile time.</p></li><li><p>You have homogenous lists of the same type of <code>Car</code> to process, so that you can store them all in an <code>Array{Car{:Honda,:Accord},N}</code>.</p></li></ul><div class="mdnote debug">Base.Markdown.Paragraph</div><p>When the latter holds, a function processing such a homogenous array can be productively specialized: Julia knows the type of each element in advance (all objects in the container have the same concrete type), so Julia can &quot;look up&quot; the correct method calls when the function is being compiled (obviating the need to check at run-time) and thereby emit efficient code for processing the whole list.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>When these do not hold, then it&#39;s likely that you&#39;ll get no benefit; worse, the resulting &quot;combinatorial explosion of types&quot; will be counterproductive.  If <code>items[i+1]</code> has a different type than <code>item[i]</code>, Julia has to look up the type at run-time, search for the appropriate method in method tables, decide (via type intersection) which one matches, determine whether it has been JIT-compiled yet (and do so if not), and then make the call. In essence, you&#39;re asking the full type- system and JIT-compilation machinery to basically execute the equivalent of a switch statement or dictionary lookup in your own code.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Some run-time benchmarks comparing (1) type dispatch, (2) dictionary lookup, and (3) a &quot;switch&quot; statement can be found <a href="https://groups.google.com/d/msg/julia-users/jUMu9A3QKQQ/qjgVWr7vAwAJ">on the mailing list</a>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Perhaps even worse than the run-time impact is the compile-time impact: Julia will compile specialized functions for each different <code>Car{Make, Model}</code>; if you have hundreds or thousands of such types, then every function that accepts such an object as a parameter (from a custom <code>get_year</code> function you might write yourself, to the generic <code>push!</code> function in the standard library) will have hundreds or thousands of variants compiled for it.  Each of these increases the size of the cache of compiled code, the length of internal lists of methods, etc.  Excess enthusiasm for values-as-parameters can easily waste enormous resources.</p><a id="Access-arrays-in-memory-order,-along-columns-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Access arrays in memory order, along columns</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Multidimensional arrays in Julia are stored in column-major order. This means that arrays are stacked one column at a time. This can be verified using the <code>vec</code> function or the syntax <code>[:]</code> as shown below (notice that the array is ordered <code>[1 3 2 4]</code>, not <code>[1 2 3 4]</code>):</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">x</span><span> </span><span class="o">=</span><span> </span><span class="p">[</span><span class="mi">1</span><span> </span><span class="mi">2</span><span class="p">;</span><span> </span><span class="mi">3</span><span> </span><span class="mi">4</span><span class="p">]</span><span>
</span><span class="go">2×2 Array{Int64,2}:
</span><span class="go"> 1  2
</span><span class="go"> 3  4
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">x</span><span class="p">[</span><span class="p">:</span><span class="p">]</span><span>
</span><span class="go">4-element Array{Int64,1}:
</span><span class="go"> 1
</span><span class="go"> 3
</span><span class="go"> 2
</span><span class="go"> 4
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This convention for ordering arrays is common in many languages like Fortran, Matlab, and R (to name a few). The alternative to column-major ordering is row-major ordering, which is the convention adopted by C and Python (<code>numpy</code>) among other languages. Remembering the ordering of arrays can have significant performance effects when looping over arrays. A rule of thumb to keep in mind is that with column-major arrays, the first index changes most rapidly. Essentially this means that looping will be faster if the inner-most loop index is the first to appear in a slice expression.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Consider the following contrived example. Imagine we wanted to write a function that accepts a <code>Vector</code> and returns a square <code>Matrix</code> with either the rows or the columns filled with copies of the input vector. Assume that it is not important whether rows or columns are filled with these copies (perhaps the rest of the code can be easily adapted accordingly). We could conceivably do this in at least four ways (in addition to the recommended call to the built-in <a href="../stdlib/linalg.html#Base.repmat"><code>repmat()</code></a>):</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">function</span><span class="nf"> </span><span class="nf">copy_cols</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">Vector</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">)</span><span>
</span><span>    </span><span class="n">n</span><span> </span><span class="o">=</span><span> </span><span class="n">size</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span> </span><span class="mi">1</span><span class="p">)</span><span>
</span><span>    </span><span class="n">out</span><span> </span><span class="o">=</span><span> </span><span class="n">Array</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span> </span><span class="n">n</span><span class="p">)</span><span>
</span><span>    </span><span class="k">for</span><span> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span>
</span><span>        </span><span class="n">out</span><span class="p">[</span><span class="p">:</span><span class="p">,</span><span> </span><span class="n">i</span><span class="p">]</span><span> </span><span class="o">=</span><span> </span><span class="n">x</span><span>
</span><span>    </span><span class="k">end</span><span>
</span><span>    </span><span class="n">out</span><span>
</span><span class="k">end</span><span>
</span><span>
</span><span class="k">function</span><span class="nf"> </span><span class="nf">copy_rows</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">Vector</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">)</span><span>
</span><span>    </span><span class="n">n</span><span> </span><span class="o">=</span><span> </span><span class="n">size</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span> </span><span class="mi">1</span><span class="p">)</span><span>
</span><span>    </span><span class="n">out</span><span> </span><span class="o">=</span><span> </span><span class="n">Array</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span> </span><span class="n">n</span><span class="p">)</span><span>
</span><span>    </span><span class="k">for</span><span> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span>
</span><span>        </span><span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span> </span><span class="p">:</span><span class="p">]</span><span> </span><span class="o">=</span><span> </span><span class="n">x</span><span>
</span><span>    </span><span class="k">end</span><span>
</span><span>    </span><span class="n">out</span><span>
</span><span class="k">end</span><span>
</span><span>
</span><span class="k">function</span><span class="nf"> </span><span class="nf">copy_col_row</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">Vector</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">)</span><span>
</span><span>    </span><span class="n">n</span><span> </span><span class="o">=</span><span> </span><span class="n">size</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span> </span><span class="mi">1</span><span class="p">)</span><span>
</span><span>    </span><span class="n">out</span><span> </span><span class="o">=</span><span> </span><span class="n">Array</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span> </span><span class="n">n</span><span class="p">)</span><span>
</span><span>    </span><span class="k">for</span><span> </span><span class="n">col</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">,</span><span> </span><span class="n">row</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span>
</span><span>        </span><span class="n">out</span><span class="p">[</span><span class="n">row</span><span class="p">,</span><span> </span><span class="n">col</span><span class="p">]</span><span> </span><span class="o">=</span><span> </span><span class="n">x</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span>
</span><span>    </span><span class="k">end</span><span>
</span><span>    </span><span class="n">out</span><span>
</span><span class="k">end</span><span>
</span><span>
</span><span class="k">function</span><span class="nf"> </span><span class="nf">copy_row_col</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">Vector</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">)</span><span>
</span><span>    </span><span class="n">n</span><span> </span><span class="o">=</span><span> </span><span class="n">size</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span> </span><span class="mi">1</span><span class="p">)</span><span>
</span><span>    </span><span class="n">out</span><span> </span><span class="o">=</span><span> </span><span class="n">Array</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span> </span><span class="n">n</span><span class="p">)</span><span>
</span><span>    </span><span class="k">for</span><span> </span><span class="n">row</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">,</span><span> </span><span class="n">col</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span>
</span><span>        </span><span class="n">out</span><span class="p">[</span><span class="n">row</span><span class="p">,</span><span> </span><span class="n">col</span><span class="p">]</span><span> </span><span class="o">=</span><span> </span><span class="n">x</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span>
</span><span>    </span><span class="k">end</span><span>
</span><span>    </span><span class="n">out</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Now we will time each of these functions using the same random <code>10000</code> by <code>1</code> input vector:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">x</span><span> </span><span class="o">=</span><span> </span><span class="n">randn</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span><span class="p">;</span><span>
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">fmt</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">println</span><span class="p">(</span><span class="n">rpad</span><span class="p">(</span><span class="n">string</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">*</span><span class="s">&quot;</span><span class="s">: </span><span class="s">&quot;</span><span class="p">,</span><span> </span><span class="mi">14</span><span class="p">,</span><span> </span><span class="sc">&#39; &#39;</span><span class="p">)</span><span class="p">,</span><span> </span><span class="p">@</span><span class="n">elapsed</span><span> </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">map</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span><span> </span><span class="kt">Any</span><span class="p">[</span><span class="n">copy_cols</span><span class="p">,</span><span> </span><span class="n">copy_rows</span><span class="p">,</span><span> </span><span class="n">copy_col_row</span><span class="p">,</span><span> </span><span class="n">copy_row_col</span><span class="p">]</span><span class="p">)</span><span class="p">;</span><span>
</span><span class="go">copy_cols:    0.331706323
</span><span class="go">copy_rows:    1.799009911
</span><span class="go">copy_col_row: 0.415630047
</span><span class="go">copy_row_col: 1.721531501
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Notice that <code>copy_cols</code> is much faster than <code>copy_rows</code>. This is expected because <code>copy_cols</code> respects the column-based memory layout of the <code>Matrix</code> and fills it one column at a time. Additionally, <code>copy_col_row</code> is much faster than <code>copy_row_col</code> because it follows our rule of thumb that the first element to appear in a slice expression should be coupled with the inner-most loop.</p><a id="Pre-allocating-outputs-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Pre-allocating outputs</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>If your function returns an Array or some other complex type, it may have to allocate memory.  Unfortunately, oftentimes allocation and its converse, garbage collection, are substantial bottlenecks.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Sometimes you can circumvent the need to allocate memory on each function call by preallocating the output.  As a trivial example, compare</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">function</span><span class="nf"> </span><span class="nf">xinc</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span>
</span><span>    </span><span class="k">return</span><span> </span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span> </span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span> </span><span class="n">x</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span><span>
</span><span class="k">end</span><span>
</span><span>
</span><span class="k">function</span><span class="nf"> </span><span class="nf">loopinc</span><span class="p">(</span><span class="p">)</span><span>
</span><span>    </span><span class="n">y</span><span> </span><span class="o">=</span><span> </span><span class="mi">0</span><span>
</span><span>    </span><span class="k">for</span><span> </span><span class="n">i</span><span> </span><span class="o">=</span><span> </span><span class="mi">1</span><span class="p">:</span><span class="mi">10</span><span class="o">^</span><span class="mi">7</span><span>
</span><span>        </span><span class="n">ret</span><span> </span><span class="o">=</span><span> </span><span class="n">xinc</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span>
</span><span>        </span><span class="n">y</span><span> </span><span class="o">+</span><span class="o">=</span><span> </span><span class="n">ret</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span>
</span><span>    </span><span class="k">end</span><span>
</span><span>    </span><span class="n">y</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>with</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">function</span><span class="nf"> </span><span class="nf">xinc</span><span class="o">!</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">(</span><span class="n">ret</span><span class="p">:</span><span class="p">:</span><span class="n">AbstractVector</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">T</span><span class="p">)</span><span>
</span><span>    </span><span class="n">ret</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span> </span><span class="o">=</span><span> </span><span class="n">x</span><span>
</span><span>    </span><span class="n">ret</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span> </span><span class="o">=</span><span> </span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span>
</span><span>    </span><span class="n">ret</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span> </span><span class="o">=</span><span> </span><span class="n">x</span><span class="o">+</span><span class="mi">2</span><span>
</span><span>    </span><span class="n">nothing</span><span>
</span><span class="k">end</span><span>
</span><span>
</span><span class="k">function</span><span class="nf"> </span><span class="nf">loopinc_prealloc</span><span class="p">(</span><span class="p">)</span><span>
</span><span>    </span><span class="n">ret</span><span> </span><span class="o">=</span><span> </span><span class="n">Array</span><span class="p">{</span><span class="kt">Int</span><span class="p">}</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span>
</span><span>    </span><span class="n">y</span><span> </span><span class="o">=</span><span> </span><span class="mi">0</span><span>
</span><span>    </span><span class="k">for</span><span> </span><span class="n">i</span><span> </span><span class="o">=</span><span> </span><span class="mi">1</span><span class="p">:</span><span class="mi">10</span><span class="o">^</span><span class="mi">7</span><span>
</span><span>        </span><span class="n">xinc!</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span><span> </span><span class="n">i</span><span class="p">)</span><span>
</span><span>        </span><span class="n">y</span><span> </span><span class="o">+</span><span class="o">=</span><span> </span><span class="n">ret</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span>
</span><span>    </span><span class="k">end</span><span>
</span><span>    </span><span class="n">y</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Timing results:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="p">@</span><span class="n">time</span><span> </span><span class="n">loopinc</span><span class="p">(</span><span class="p">)</span><span>
</span><span class="go">elapsed time: 1.955026528 seconds (1279975584 bytes allocated)
</span><span class="go">50000015000000
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="p">@</span><span class="n">time</span><span> </span><span class="n">loopinc_prealloc</span><span class="p">(</span><span class="p">)</span><span>
</span><span class="go">elapsed time: 0.078639163 seconds (144 bytes allocated)
</span><span class="go">50000015000000
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Preallocation has other advantages, for example by allowing the caller to control the &quot;output&quot; type from an algorithm.  In the example above, we could have passed a <code>SubArray</code> rather than an <a href="../stdlib/arrays.html#Core.Array"><code>Array</code></a>, had we so desired.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Taken to its extreme, pre-allocation can make your code uglier, so performance measurements and some judgment may be required.   However, for &quot;vectorized&quot; (element-wise) functions, the convenient syntax <code>x .= f.(y)</code> can be used for in-place operations with fused loops and no temporary arrays (dot-vectorizing).</p><a id="Avoid-string-interpolation-for-I/O-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Avoid string interpolation for I/O</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>When writing data to a file (or other I/O device), forming extra intermediate strings is a source of overhead. Instead of:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">println</span><span class="p">(</span><span class="n">file</span><span class="p">,</span><span> </span><span class="s">&quot;</span><span class="si">$</span><span class="s">a </span><span class="si">$</span><span class="s">b</span><span class="s">&quot;</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>use:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">println</span><span class="p">(</span><span class="n">file</span><span class="p">,</span><span> </span><span class="n">a</span><span class="p">,</span><span> </span><span class="s">&quot;</span><span class="s"> </span><span class="s">&quot;</span><span class="p">,</span><span> </span><span class="n">b</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The first version of the code forms a string, then writes it to the file, while the second version writes values directly to the file. Also notice that in some cases string interpolation can be harder to read. Consider:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">println</span><span class="p">(</span><span class="n">file</span><span class="p">,</span><span> </span><span class="s">&quot;</span><span class="si">$</span><span class="s">(f(a))</span><span class="si">$</span><span class="s">(f(b))</span><span class="s">&quot;</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>versus:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">println</span><span class="p">(</span><span class="n">file</span><span class="p">,</span><span> </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="p">,</span><span> </span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="p">)</span><span>
</span></code></pre><a id="Optimize-network-I/O-during-parallel-execution-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Optimize network I/O during parallel execution</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>When executing a remote function in parallel:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">responses</span><span> </span><span class="o">=</span><span> </span><span class="n">Vector</span><span class="p">{</span><span class="kt">Any</span><span class="p">}</span><span class="p">(</span><span class="n">nworkers</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="p">@</span><span class="n">sync</span><span> </span><span class="k">begin</span><span>
</span><span>    </span><span class="k">for</span><span> </span><span class="p">(</span><span class="n">idx</span><span class="p">,</span><span> </span><span class="n">pid</span><span class="p">)</span><span> </span><span class="k">in</span><span> </span><span class="n">enumerate</span><span class="p">(</span><span class="n">workers</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span>
</span><span>        </span><span class="p">@</span><span class="n">async</span><span> </span><span class="n">responses</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span> </span><span class="o">=</span><span> </span><span class="n">remotecall_fetch</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span><span> </span><span class="n">foo</span><span class="p">,</span><span> </span><span class="n">args</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="p">)</span><span>
</span><span>    </span><span class="k">end</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>is faster than:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">refs</span><span> </span><span class="o">=</span><span> </span><span class="n">Vector</span><span class="p">{</span><span class="kt">Any</span><span class="p">}</span><span class="p">(</span><span class="n">nworkers</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="k">for</span><span> </span><span class="p">(</span><span class="n">idx</span><span class="p">,</span><span> </span><span class="n">pid</span><span class="p">)</span><span> </span><span class="k">in</span><span> </span><span class="n">enumerate</span><span class="p">(</span><span class="n">workers</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span>
</span><span>    </span><span class="n">refs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span> </span><span class="o">=</span><span> </span><span class="p">@</span><span class="n">spawnat</span><span> </span><span class="n">pid</span><span> </span><span class="n">foo</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="p">)</span><span>
</span><span class="k">end</span><span>
</span><span class="n">responses</span><span> </span><span class="o">=</span><span> </span><span class="p">[</span><span class="n">fetch</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span> </span><span class="k">for</span><span> </span><span class="n">r</span><span> </span><span class="k">in</span><span> </span><span class="n">refs</span><span class="p">]</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The former results in a single network round-trip to every worker, while the latter results in two network calls - first by the <code>@spawnat</code> and the second due to the <code>fetch</code> (or even a <code>wait</code>). The <code>fetch</code>/<code>wait</code> is also being executed serially resulting in an overall poorer performance.</p><a id="Fix-deprecation-warnings-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Fix deprecation warnings</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>A deprecated function internally performs a lookup in order to print a relevant warning only once. This extra lookup can cause a significant slowdown, so all uses of deprecated functions should be modified as suggested by the warnings.</p><a id="Tweaks-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Tweaks</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>These are some minor points that might help in tight inner loops.</p><div class="mdnote debug">Base.Markdown.List</div><ul><li><p>Avoid unnecessary arrays. For example, instead of <a href="../stdlib/collections.html#Base.sum"><code>sum([x,y,z])</code></a> use <code>x+y+z</code>.</p></li><li><p>Use <a href="../stdlib/math.html#Base.abs2"><code>abs2(z)</code></a> instead of <a href="../stdlib/strings.html#Base.^"><code>abs(z)^2</code></a> for complex <code>z</code>. In general, try to rewrite code to use <a href="../stdlib/math.html#Base.abs2"><code>abs2()</code></a> instead of <a href="../stdlib/math.html#Base.abs"><code>abs()</code></a> for complex arguments.</p></li><li><p>Use <a href="../stdlib/math.html#Base.div"><code>div(x,y)</code></a> for truncating division of integers instead of <a href="../stdlib/dates.html#Base.trunc"><code>trunc(x/y)</code></a>, <a href="../stdlib/math.html#Base.fld"><code>fld(x,y)</code></a> instead of <a href="../stdlib/dates.html#Base.floor"><code>floor(x/y)</code></a>, and <a href="../stdlib/math.html#Base.cld"><code>cld(x,y)</code></a> instead of <a href="../stdlib/dates.html#Base.ceil"><code>ceil(x/y)</code></a>.</p></li></ul><a id="Performance-Annotations-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Performance Annotations</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Sometimes you can enable better optimization by promising certain program properties.</p><div class="mdnote debug">Base.Markdown.List</div><ul><li><p>Use <code>@inbounds</code> to eliminate array bounds checking within expressions. Be certain before doing this. If the subscripts are ever out of bounds, you may suffer crashes or silent corruption.</p></li><li><p>Use <code>@fastmath</code> to allow floating point optimizations that are correct for real numbers, but lead to differences for IEEE numbers. Be careful when doing this, as this may change numerical results. This corresponds to the <code>-ffast-math</code> option of clang.</p></li><li><p>Write <code>@simd</code> in front of <code>for</code> loops that are amenable to vectorization. <strong>This feature is experimental</strong> and could change or disappear in future versions of Julia.</p></li></ul><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Note: While <code>@simd</code> needs to be placed directly in front of a loop, both <code>@inbounds</code> and <code>@fastmath</code> can be applied to several statements at once, e.g. using <code>begin</code> ... <code>end</code>, or even to a whole function.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Here is an example with both <code>@inbounds</code> and <code>@simd</code> markup:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">function</span><span class="nf"> </span><span class="nf">inner</span><span class="p">(</span><span> </span><span class="n">x</span><span class="p">,</span><span> </span><span class="n">y</span><span> </span><span class="p">)</span><span>
</span><span>    </span><span class="n">s</span><span> </span><span class="o">=</span><span> </span><span class="n">zero</span><span class="p">(</span><span class="n">eltype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="p">)</span><span>
</span><span>    </span><span class="k">for</span><span> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">length</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span>
</span><span>        </span><span class="p">@</span><span class="n">inbounds</span><span> </span><span class="n">s</span><span> </span><span class="o">+</span><span class="o">=</span><span> </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span>
</span><span>    </span><span class="k">end</span><span>
</span><span>    </span><span class="n">s</span><span>
</span><span class="k">end</span><span>
</span><span>
</span><span class="k">function</span><span class="nf"> </span><span class="nf">innersimd</span><span class="p">(</span><span> </span><span class="n">x</span><span class="p">,</span><span> </span><span class="n">y</span><span> </span><span class="p">)</span><span>
</span><span>    </span><span class="n">s</span><span> </span><span class="o">=</span><span> </span><span class="n">zero</span><span class="p">(</span><span class="n">eltype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="p">)</span><span>
</span><span>    </span><span class="p">@</span><span class="n">simd</span><span> </span><span class="k">for</span><span> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">length</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span>
</span><span>        </span><span class="p">@</span><span class="n">inbounds</span><span> </span><span class="n">s</span><span> </span><span class="o">+</span><span class="o">=</span><span> </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span>
</span><span>    </span><span class="k">end</span><span>
</span><span>    </span><span class="n">s</span><span>
</span><span class="k">end</span><span>
</span><span>
</span><span class="k">function</span><span class="nf"> </span><span class="nf">timeit</span><span class="p">(</span><span> </span><span class="n">n</span><span class="p">,</span><span> </span><span class="n">reps</span><span> </span><span class="p">)</span><span>
</span><span>    </span><span class="n">x</span><span> </span><span class="o">=</span><span> </span><span class="n">rand</span><span class="p">(</span><span class="kt">Float32</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span>
</span><span>    </span><span class="n">y</span><span> </span><span class="o">=</span><span> </span><span class="n">rand</span><span class="p">(</span><span class="kt">Float32</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span>
</span><span>    </span><span class="n">s</span><span> </span><span class="o">=</span><span> </span><span class="n">zero</span><span class="p">(</span><span class="kt">Float64</span><span class="p">)</span><span>
</span><span>    </span><span class="n">time</span><span> </span><span class="o">=</span><span> </span><span class="p">@</span><span class="n">elapsed</span><span> </span><span class="k">for</span><span> </span><span class="n">j</span><span> </span><span class="k">in</span><span> </span><span class="mi">1</span><span class="p">:</span><span class="n">reps</span><span>
</span><span>        </span><span class="n">s</span><span class="o">+</span><span class="o">=</span><span class="n">inner</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span>
</span><span>    </span><span class="k">end</span><span>
</span><span>    </span><span class="n">println</span><span class="p">(</span><span class="s">&quot;</span><span class="s">GFlop        = </span><span class="s">&quot;</span><span class="p">,</span><span class="mf">2.0</span><span class="o">*</span><span class="n">n</span><span class="o">*</span><span class="n">reps</span><span class="o">/</span><span class="n">time</span><span class="o">*</span><span class="mf">1E-9</span><span class="p">)</span><span>
</span><span>    </span><span class="n">time</span><span> </span><span class="o">=</span><span> </span><span class="p">@</span><span class="n">elapsed</span><span> </span><span class="k">for</span><span> </span><span class="n">j</span><span> </span><span class="k">in</span><span> </span><span class="mi">1</span><span class="p">:</span><span class="n">reps</span><span>
</span><span>        </span><span class="n">s</span><span class="o">+</span><span class="o">=</span><span class="n">innersimd</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span>
</span><span>    </span><span class="k">end</span><span>
</span><span>    </span><span class="n">println</span><span class="p">(</span><span class="s">&quot;</span><span class="s">GFlop (SIMD) = </span><span class="s">&quot;</span><span class="p">,</span><span class="mf">2.0</span><span class="o">*</span><span class="n">n</span><span class="o">*</span><span class="n">reps</span><span class="o">/</span><span class="n">time</span><span class="o">*</span><span class="mf">1E-9</span><span class="p">)</span><span>
</span><span class="k">end</span><span>
</span><span>
</span><span class="n">timeit</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>On a computer with a 2.4GHz Intel Core i5 processor, this produces:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">GFlop        = 1.9467069505224963
GFlop (SIMD) = 17.578554163920018</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The range for a <code>@simd for</code> loop should be a one-dimensional range. A variable used for accumulating, such as <code>s</code> in the example, is called a <em>reduction variable</em>. By using <code>@simd</code>, you are asserting several properties of the loop:</p><div class="mdnote debug">Base.Markdown.List</div><ul><li><p>It is safe to execute iterations in arbitrary or overlapping order, with special consideration for reduction variables.</p></li><li><p>Floating-point operations on reduction variables can be reordered, possibly causing different results than without <code>@simd</code>.</p></li><li><p>No iteration ever waits on another iteration to make forward progress.</p></li></ul><div class="mdnote debug">Base.Markdown.Paragraph</div><p>A loop containing <code>break</code>, <code>continue</code>, or <code>@goto</code> will cause a compile-time error.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Using <code>@simd</code> merely gives the compiler license to vectorize. Whether it actually does so depends on the compiler. To actually benefit from the current implementation, your loop should have the following additional properties:</p><div class="mdnote debug">Base.Markdown.List</div><ul><li><p>The loop must be an innermost loop.</p></li><li><p>The loop body must be straight-line code. This is why <code>@inbounds</code> is currently needed for all array accesses. The compiler can sometimes turn short <code>&amp;&amp;</code>, <code>||</code>, and <code>?:</code> expressions into straight-line code, if it is safe to evaluate all operands unconditionally. Consider using <a href="../stdlib/base.html#Base.ifelse"><code>ifelse()</code></a> instead of <code>?:</code> in the loop if it is safe to do so.</p></li><li><p>Accesses must have a stride pattern and cannot be &quot;gathers&quot; (random-index reads) or &quot;scatters&quot; (random-index writes).</p></li><li><p>The stride should be unit stride.</p></li><li><p>In some simple cases, for example with 2-3 arrays accessed in a loop, the LLVM auto-vectorization may kick in automatically, leading to no further speedup with <code>@simd</code>.</p></li></ul><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Here is an example with all three kinds of markup. This program first calculates the finite difference of a one-dimensional array, and then evaluates the L2-norm of the result:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">function</span><span class="nf"> </span><span class="nf">init</span><span class="o">!</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span>
</span><span>    </span><span class="n">n</span><span> </span><span class="o">=</span><span> </span><span class="n">length</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span>
</span><span>    </span><span class="n">dx</span><span> </span><span class="o">=</span><span> </span><span class="mf">1.0</span><span> </span><span class="o">/</span><span> </span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span>
</span><span>    </span><span class="p">@</span><span class="n">fastmath</span><span> </span><span class="p">@</span><span class="n">inbounds</span><span> </span><span class="p">@</span><span class="n">simd</span><span> </span><span class="k">for</span><span> </span><span class="n">i</span><span> </span><span class="k">in</span><span> </span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span>
</span><span>        </span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span> </span><span class="o">=</span><span> </span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="nb">pi</span><span class="o">*</span><span class="n">dx</span><span class="o">*</span><span class="n">i</span><span class="p">)</span><span>
</span><span>    </span><span class="k">end</span><span>
</span><span class="k">end</span><span>
</span><span>
</span><span class="k">function</span><span class="nf"> </span><span class="nf">deriv</span><span class="o">!</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span> </span><span class="n">du</span><span class="p">)</span><span>
</span><span>    </span><span class="n">n</span><span> </span><span class="o">=</span><span> </span><span class="n">length</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span>
</span><span>    </span><span class="n">dx</span><span> </span><span class="o">=</span><span> </span><span class="mf">1.0</span><span> </span><span class="o">/</span><span> </span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span>
</span><span>    </span><span class="p">@</span><span class="n">fastmath</span><span> </span><span class="p">@</span><span class="n">inbounds</span><span> </span><span class="n">du</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span> </span><span class="o">=</span><span> </span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span> </span><span class="o">-</span><span> </span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="p">)</span><span> </span><span class="o">/</span><span> </span><span class="n">dx</span><span>
</span><span>    </span><span class="p">@</span><span class="n">fastmath</span><span> </span><span class="p">@</span><span class="n">inbounds</span><span> </span><span class="p">@</span><span class="n">simd</span><span> </span><span class="k">for</span><span> </span><span class="n">i</span><span> </span><span class="k">in</span><span> </span><span class="mi">2</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span>
</span><span>        </span><span class="n">du</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span> </span><span class="o">=</span><span> </span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span> </span><span class="o">-</span><span> </span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="p">)</span><span> </span><span class="o">/</span><span> </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">dx</span><span class="p">)</span><span>
</span><span>    </span><span class="k">end</span><span>
</span><span>    </span><span class="p">@</span><span class="n">fastmath</span><span> </span><span class="p">@</span><span class="n">inbounds</span><span> </span><span class="n">du</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span> </span><span class="o">=</span><span> </span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span> </span><span class="o">-</span><span> </span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="p">)</span><span> </span><span class="o">/</span><span> </span><span class="n">dx</span><span>
</span><span class="k">end</span><span>
</span><span>
</span><span class="k">function</span><span class="nf"> </span><span class="nf">norm</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span>
</span><span>    </span><span class="n">n</span><span> </span><span class="o">=</span><span> </span><span class="n">length</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span>
</span><span>    </span><span class="n">T</span><span> </span><span class="o">=</span><span> </span><span class="n">eltype</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span>
</span><span>    </span><span class="n">s</span><span> </span><span class="o">=</span><span> </span><span class="n">zero</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span>
</span><span>    </span><span class="p">@</span><span class="n">fastmath</span><span> </span><span class="p">@</span><span class="n">inbounds</span><span> </span><span class="p">@</span><span class="n">simd</span><span> </span><span class="k">for</span><span> </span><span class="n">i</span><span> </span><span class="k">in</span><span> </span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span>
</span><span>        </span><span class="n">s</span><span> </span><span class="o">+</span><span class="o">=</span><span> </span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">^</span><span class="mi">2</span><span>
</span><span>    </span><span class="k">end</span><span>
</span><span>    </span><span class="p">@</span><span class="n">fastmath</span><span> </span><span class="p">@</span><span class="n">inbounds</span><span> </span><span class="k">return</span><span> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">s</span><span class="o">/</span><span class="n">n</span><span class="p">)</span><span>
</span><span class="k">end</span><span>
</span><span>
</span><span class="k">function</span><span class="nf"> </span><span class="nf">main</span><span class="p">(</span><span class="p">)</span><span>
</span><span>    </span><span class="n">n</span><span> </span><span class="o">=</span><span> </span><span class="mi">2000</span><span>
</span><span>    </span><span class="n">u</span><span> </span><span class="o">=</span><span> </span><span class="n">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span>
</span><span>    </span><span class="n">init!</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span>
</span><span>    </span><span class="n">du</span><span> </span><span class="o">=</span><span> </span><span class="n">similar</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span>
</span><span>
</span><span>    </span><span class="n">deriv!</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span> </span><span class="n">du</span><span class="p">)</span><span>
</span><span>    </span><span class="n">nu</span><span> </span><span class="o">=</span><span> </span><span class="n">norm</span><span class="p">(</span><span class="n">du</span><span class="p">)</span><span>
</span><span>
</span><span>    </span><span class="p">@</span><span class="n">time</span><span> </span><span class="k">for</span><span> </span><span class="n">i</span><span> </span><span class="k">in</span><span> </span><span class="mi">1</span><span class="p">:</span><span class="mi">10</span><span class="o">^</span><span class="mi">6</span><span>
</span><span>        </span><span class="n">deriv!</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span> </span><span class="n">du</span><span class="p">)</span><span>
</span><span>        </span><span class="n">nu</span><span> </span><span class="o">=</span><span> </span><span class="n">norm</span><span class="p">(</span><span class="n">du</span><span class="p">)</span><span>
</span><span>    </span><span class="k">end</span><span>
</span><span>
</span><span>    </span><span class="n">println</span><span class="p">(</span><span class="n">nu</span><span class="p">)</span><span>
</span><span class="k">end</span><span>
</span><span>
</span><span class="n">main</span><span class="p">(</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>On a computer with a 2.7 GHz Intel Core i7 processor, this produces:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">$ julia wave.jl
elapsed time: 1.207814709 seconds (0 bytes allocated)
4.443986180758243

$ julia --math-mode=ieee wave.jl
elapsed time: 4.487083643 seconds (0 bytes allocated)
4.443986180758243</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Here, the option <code>--math-mode=ieee</code> disables the <code>@fastmath</code> macro, so that we can compare results.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In this case, the speedup due to <code>@fastmath</code> is a factor of about 3.7. This is unusually large – in general, the speedup will be smaller. (In this particular example, the working set of the benchmark is small enough to fit into the L1 cache of the processor, so that memory access latency does not play a role, and computing time is dominated by CPU usage. In many real world programs this is not the case.) Also, in this case this optimization does not change the result – in general, the result will be slightly different. In some cases, especially for numerically unstable algorithms, the result can be very different.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The annotation <code>@fastmath</code> re-arranges floating point expressions, e.g. changing the order of evaluation, or assuming that certain special cases (inf, nan) cannot occur. In this case (and on this particular computer), the main difference is that the expression <code>1 / (2*dx)</code> in the function <code>deriv</code> is hoisted out of the loop (i.e. calculated outside the loop), as if one had written <code>idx = 1 / (2*dx)</code>. In the loop, the expression <code>... / (2*dx)</code> then becomes <code>... * idx</code>, which is much faster to evaluate. Of course, both the actual optimization that is applied by the compiler as well as the resulting speedup depend very much on the hardware. You can examine the change in generated code by using Julia&#39;s <a href="../stdlib/base.html#Base.code_native"><code>code_native()</code></a> function.</p><a id="Treat-Subnormal-Numbers-as-Zeros-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Treat Subnormal Numbers as Zeros</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Subnormal numbers, formerly called <a href="https://en.wikipedia.org/wiki/Denormal_number">denormal numbers</a>, are useful in many contexts, but incur a performance penalty on some hardware. A call <a href="../stdlib/numbers.html#Base.Rounding.set_zero_subnormals"><code>set_zero_subnormals(true)</code></a> grants permission for floating-point operations to treat subnormal inputs or outputs as zeros, which may improve performance on some hardware. A call <a href="../stdlib/numbers.html#Base.Rounding.set_zero_subnormals"><code>set_zero_subnormals(false)</code></a> enforces strict IEEE behavior for subnormal numbers.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Below is an example where subnormals noticeably impact performance on some hardware:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">function</span><span class="nf"> </span><span class="nf">timestep</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">(</span><span> </span><span class="n">b</span><span class="p">:</span><span class="p">:</span><span class="n">Vector</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">a</span><span class="p">:</span><span class="p">:</span><span class="n">Vector</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">Δt</span><span class="p">:</span><span class="p">:</span><span class="n">T</span><span> </span><span class="p">)</span><span>
</span><span>    </span><span class="p">@</span><span class="nb">assert</span><span> </span><span class="n">length</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">==</span><span class="n">length</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span>
</span><span>    </span><span class="n">n</span><span> </span><span class="o">=</span><span> </span><span class="n">length</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span>
</span><span>    </span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span> </span><span class="o">=</span><span> </span><span class="mi">1</span><span>                            </span><span class="c"># Boundary condition</span><span>
</span><span>    </span><span class="k">for</span><span> </span><span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span>
</span><span>        </span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span> </span><span class="o">=</span><span> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span> </span><span class="o">+</span><span> </span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span> </span><span class="o">-</span><span> </span><span class="n">T</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span> </span><span class="o">+</span><span> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="p">)</span><span> </span><span class="o">*</span><span> </span><span class="n">Δt</span><span>
</span><span>    </span><span class="k">end</span><span>
</span><span>    </span><span class="n">b</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span> </span><span class="o">=</span><span> </span><span class="mi">0</span><span>                            </span><span class="c"># Boundary condition</span><span>
</span><span class="k">end</span><span>
</span><span>
</span><span class="k">function</span><span class="nf"> </span><span class="nf">heatflow</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">(</span><span> </span><span class="n">a</span><span class="p">:</span><span class="p">:</span><span class="n">Vector</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">nstep</span><span class="p">:</span><span class="p">:</span><span class="n">Integer</span><span> </span><span class="p">)</span><span>
</span><span>    </span><span class="n">b</span><span> </span><span class="o">=</span><span> </span><span class="n">similar</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span>
</span><span>    </span><span class="k">for</span><span> </span><span class="n">t</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">div</span><span class="p">(</span><span class="n">nstep</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span>                </span><span class="c"># Assume nstep is even</span><span>
</span><span>        </span><span class="n">timestep</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">T</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span><span class="p">)</span><span>
</span><span>        </span><span class="n">timestep</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">T</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span><span class="p">)</span><span>
</span><span>    </span><span class="k">end</span><span>
</span><span class="k">end</span><span>
</span><span>
</span><span class="n">heatflow</span><span class="p">(</span><span class="n">zeros</span><span class="p">(</span><span class="kt">Float32</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span>           </span><span class="c"># Force compilation</span><span>
</span><span class="k">for</span><span> </span><span class="n">trial</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">6</span><span>
</span><span>    </span><span class="n">a</span><span> </span><span class="o">=</span><span> </span><span class="n">zeros</span><span class="p">(</span><span class="kt">Float32</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span><span>
</span><span>    </span><span class="n">set_zero_subnormals</span><span class="p">(</span><span class="n">iseven</span><span class="p">(</span><span class="n">trial</span><span class="p">)</span><span class="p">)</span><span>  </span><span class="c"># Odd trials use strict IEEE arithmetic</span><span>
</span><span>    </span><span class="p">@</span><span class="n">time</span><span> </span><span class="n">heatflow</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This example generates many subnormal numbers because the values in <code>a</code> become an exponentially decreasing curve, which slowly flattens out over time.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Treating subnormals as zeros should be used with caution, because doing so breaks some identities, such as <code>x-y==0</code> implies <code>x==y</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">x</span><span class="o">=</span><span class="mf">3f-38</span><span class="p">;</span><span> </span><span class="n">y</span><span class="o">=</span><span class="mf">2f-38</span><span class="p">;</span><span>
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">set_zero_subnormals</span><span class="p">(</span><span class="n">false</span><span class="p">)</span><span class="p">;</span><span> </span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="o">==</span><span class="n">y</span><span class="p">)</span><span>
</span><span class="go">(1.0000001f-38,false)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">set_zero_subnormals</span><span class="p">(</span><span class="n">true</span><span class="p">)</span><span class="p">;</span><span> </span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="o">==</span><span class="n">y</span><span class="p">)</span><span>
</span><span class="go">(0.0f0,false)
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In some applications, an alternative to zeroing subnormal numbers is to inject a tiny bit of noise.  For example, instead of initializing <code>a</code> with zeros, initialize it with:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">a</span><span> </span><span class="o">=</span><span> </span><span class="n">rand</span><span class="p">(</span><span class="kt">Float32</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span><span> </span><span class="o">*</span><span> </span><span class="mf">1.f-9</span><span>
</span></code></pre><a id="[@code_warntype](@ref)-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2><a href="@ref"><code>@code_warntype</code></a></h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The macro <a href="../stdlib/base.html#Base.@code_warntype"><code>@code_warntype</code></a> (or its function variant <a href="../stdlib/base.html#Base.code_warntype"><code>code_warntype()</code></a>) can sometimes be helpful in diagnosing type-related problems. Here&#39;s an example:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span class="go">pos(x) = x &lt; 0 ? 0 : x
</span><span class="go">
</span><span class="go">function f(x)
</span><span class="go">    y = pos(x)
</span><span class="go">    sin(y*x+1)
</span><span class="go">end
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="p">@</span><span class="n">code_warntype</span><span> </span><span class="n">f</span><span class="p">(</span><span class="mf">3.2</span><span class="p">)</span><span>
</span><span class="go">Variables:
</span><span class="go">  x::Float64
</span><span class="go">  y::UNION(INT64,FLOAT64)
</span><span class="go">  _var0::Float64
</span><span class="go">  _var3::Tuple{Int64}
</span><span class="go">  _var4::UNION(INT64,FLOAT64)
</span><span class="go">  _var1::Float64
</span><span class="go">  _var2::Float64
</span><span class="go">
</span><span class="go">Body:
</span><span class="go">  begin  # none, line 2:
</span><span class="go">  end::Float64
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Interpreting the output of <a href="../stdlib/base.html#Base.@code_warntype"><code>@code_warntype</code></a>, like that of its cousins <a href="../stdlib/base.html#Base.@code_lowered"><code>@code_lowered</code></a>, <a href="../stdlib/base.html#Base.@code_typed"><code>@code_typed</code></a>, <a href="../stdlib/base.html#Base.@code_llvm"><code>@code_llvm</code></a>, and <a href="../stdlib/base.html#Base.@code_native"><code>@code_native</code></a>, takes a little practice. Your code is being presented in form that has been partially digested on its way to generating compiled machine code.  Most of the expressions are annotated by a type, indicated by the <code>::T</code> (where <code>T</code> might be <a href="../stdlib/numbers.html#Core.Float64"><code>Float64</code></a>, for example). The most important characteristic of <a href="../stdlib/base.html#Base.@code_warntype"><code>@code_warntype</code></a> is that non-concrete types are displayed in red; in the above example, such output is shown in all-caps.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The top part of the output summarizes the type information for the different variables internal to the function. You can see that <code>y</code>, one of the variables you created, is a <code>Union{Int64,Float64}</code>, due to the type-instability of <code>pos</code>.  There is another variable, <code>_var4</code>, which you can see also has the same type.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The next lines represent the body of <code>f</code>. The lines starting with a number followed by a colon (<code>1:</code>, <code>2:</code>) are labels, and represent targets for jumps (via <code>goto</code>) in your code.  Looking at the body, you can see that <code>pos</code> has been <em>inlined</em> into <code>f</code>–everything before <code>2:</code> comes from code defined in <code>pos</code>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Starting at <code>2:</code>, the variable <code>y</code> is defined, and again annotated as a <code>Union</code> type.  Next, we see that the compiler created the temporary variable <code>_var1</code> to hold the result of <code>y*x</code>. Because a <a href="../stdlib/numbers.html#Core.Float64"><code>Float64</code></a> times <em>either</em> an <code>Int64</code> or <a href="../stdlib/numbers.html#Core.Float64"><code>Float64</code></a> yields a <a href="../stdlib/numbers.html#Core.Float64"><code>Float64</code></a>, all type-instability ends here. The net result is that <code>f(x::Float64)</code> will not be type-unstable in its output, even if some of the intermediate computations are type-unstable.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>How you use this information is up to you. Obviously, it would be far and away best to fix <code>pos</code> to be type-stable: if you did so, all of the variables in <code>f</code> would be concrete, and its performance would be optimal.  However, there are circumstances where this kind of <em>ephemeral</em> type instability might not matter too much: for example, if <code>pos</code> is never used in isolation, the fact that <code>f</code>&#39;s output is type-stable (for <a href="../stdlib/numbers.html#Core.Float64"><code>Float64</code></a> inputs) will shield later code from the propagating effects of type instability.  This is particularly relevant in cases where fixing the type instability is difficult or impossible: for example, currently it&#39;s not possible to infer the return type of an anonymous function.  In such cases, the tips above (e.g., adding type annotations and/or breaking up functions) are your best tools to contain the &quot;damage&quot; from type instability.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The following examples may help you interpret expressions marked as containing non-leaf types:</p><div class="mdnote debug">Base.Markdown.List</div><ul><li><p>Function body ending in <code>end::Union{T1,T2})</code></p><ul><li><p>Interpretation: function with unstable return type</p></li><li><p>Suggestion: make the return value type-stable, even if you have to annotate it</p></li></ul></li><li><p><code>f(x::T)::Union{T1,T2}</code></p><ul><li><p>Interpretation: call to a type-unstable function</p></li><li><p>Suggestion: fix the function, or if necessary annotate the return value</p></li></ul></li><li><p><code>(top(arrayref))(A::Array{Any,1},1)::Any</code></p><ul><li><p>Interpretation: accessing elements of poorly-typed arrays</p></li><li><p>Suggestion: use arrays with better-defined types, or if necessary annotate the type of individual element accesses</p></li></ul></li><li><p><code>(top(getfield))(A::ArrayContainer{Float64},:data)::Array{Float64,N}</code></p><ul><li><p>Interpretation: getting a field that is of non-leaf type. In this case, <code>ArrayContainer</code> had a field <code>data::Array{T}</code>. But <code>Array</code> needs the dimension <code>N</code>, too, to be a concrete type.</p></li><li><p>Suggestion: use concrete types like <code>Array{T,3}</code> or <code>Array{T,N}</code>, where <code>N</code> is now a parameter of <code>ArrayContainer</code></p></li></ul></li></ul><footer><hr/><a class="previous" href="parallel-computing.html"><span class="direction">Previous</span><span class="title">Parallel Computing</span></a><a class="next" href="profile.html"><span class="direction">Next</span><span class="title">Profiling</span></a></footer></article></body></html>
