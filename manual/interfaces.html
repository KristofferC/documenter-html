<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Interfaces · Julia language documentation</title><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../assets/debug.js"></script></head><body><nav class="toc"><a href><img class="logo" src="../logo.png" alt="Julia language logo"/></a><h1>Julia language</h1><input id="search-query" type="text" placeholder="Search docs"/><ul><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="arrays.html">Multi-dimensional Arrays</a></li><li><a class="toctext" href="calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="toctext" href="complex-and-rational-numbers.html">Complex and Rational Numbers</a></li><li><a class="toctext" href="constructors.html">Constructors</a></li><li><a class="toctext" href="control-flow.html">Control Flow</a></li><li><a class="toctext" href="conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="toctext" href="dates.html">Date and DateTime</a></li><li><a class="toctext" href="documentation.html">Documentation</a></li><li><a class="toctext" href="embedding.html">Embedding Julia</a></li><li><a class="toctext" href="faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="functions.html">Functions</a></li><li><a class="toctext" href="getting-started.html">Getting Started</a></li><li><a class="toctext" href="handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="index.html">The Julia Manual</a></li><li><a class="toctext" href="integers-and-floating-point-numbers.html">Integers and Floating-Point Numbers</a></li><li><a class="toctext" href="interacting-with-julia.html">Interacting With Julia</a></li><li class="current"><a class="toctext" href="interfaces.html">Interfaces</a><ul class="internal"><li><a class="toctext" href="#Iteration-1">Iteration</a></li><li><a class="toctext" href="#Indexing-1">Indexing</a></li><li><a class="toctext" href="#Abstract-Arrays-1">Abstract Arrays</a></li></ul></li><li><a class="toctext" href="introduction.html">Introduction</a></li><li><a class="toctext" href="linear-algebra.html">Linear algebra</a></li><li><a class="toctext" href="mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="metaprogramming.html">Metaprogramming</a></li><li><a class="toctext" href="methods.html">Methods</a></li><li><a class="toctext" href="modules.html">Modules</a></li><li><a class="toctext" href="networking-and-streams.html">Networking and Streams</a></li><li><a class="toctext" href="noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="packages.html">Packages</a></li><li><a class="toctext" href="parallel-computing.html">Parallel Computing</a></li><li><a class="toctext" href="performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="profile.html">Profiling</a></li><li><a class="toctext" href="running-external-programs.html">Running External Programs</a></li><li><a class="toctext" href="stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="strings.html">Strings</a></li><li><a class="toctext" href="style-guide.html">Style Guide</a></li><li><a class="toctext" href="types.html">Types</a></li><li><a class="toctext" href="unicode-input.html">Unicode Input</a></li><li><a class="toctext" href="variables-and-scoping.html">Scope of Variables</a></li><li><a class="toctext" href="variables.html">Variables</a></li><li><a class="toctext" href="workflow-tips.html">Workflow Tips</a></li></ul></li><li><span class="toctext">Standard Libary</span><ul><li><a class="toctext" href="../stdlib/arrays.html">Arrays</a></li><li><a class="toctext" href="../stdlib/base.html">Essentials</a></li><li><a class="toctext" href="../stdlib/c.html">C Interface</a></li><li><a class="toctext" href="../stdlib/collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="../stdlib/constants.html">Constants</a></li><li><a class="toctext" href="../stdlib/dates.html">Dates and Time</a></li><li><a class="toctext" href="../stdlib/file.html">Filesystem</a></li><li><a class="toctext" href="../stdlib/index.html">The Julia Standard Library</a></li><li><a class="toctext" href="../stdlib/io-network.html">I/O and Network</a></li><li><a class="toctext" href="../stdlib/libc.html">C Standard Library</a></li><li><a class="toctext" href="../stdlib/libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="../stdlib/linalg.html">Linear Algebra</a></li><li><a class="toctext" href="../stdlib/math.html">Mathematics</a></li><li><a class="toctext" href="../stdlib/numbers.html">Numbers</a></li><li><a class="toctext" href="../stdlib/parallel.html">Tasks and Parallel Computing</a></li><li><a class="toctext" href="../stdlib/pkg.html">Package Manager Functions</a></li><li><a class="toctext" href="../stdlib/profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/punctuation.html">Punctuation</a></li><li><a class="toctext" href="../stdlib/simd-types.html">SIMD Support</a></li><li><a class="toctext" href="../stdlib/sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="../stdlib/stacktraces.html">StackTraces</a></li><li><a class="toctext" href="../stdlib/strings.html">Strings</a></li><li><a class="toctext" href="../stdlib/test.html">Unit Testing</a></li></ul></li><li><span class="toctext">DevDocs</span><ul><li><a class="toctext" href="../devdocs/C.html">Developing/debugging Julia&#39;s C code</a></li><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../devdocs/julia.html">Documentation of Julia&#39;s Internals</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/promote-op.html">Operator-sensitive promotion</a></li><li><a class="toctext" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/types.html">More about types</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li></ul></li><li><span class="toctext">Dynamic pages</span><ul><li><a class="toctext" href="../dynamic/code.html">Code examples</a></li><li><a class="toctext" href="../dynamic/admonitions.html">Admonitions &amp; Co</a></li><li><a class="toctext" href="../dynamic/styles.html">Demonstrating <em>styles</em> of MD elements</a></li><li><a class="toctext" href="../dynamic/latex.html">The <span>$\sin(x^2)$</span> project</a></li><li><a class="toctext" href="../dynamic/bugs.html">Some existing bugs</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="interfaces.html">Interfaces</a></li></ul><a class="edit-page" href="https://github.com/"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><a id="Interfaces-1"></a><h1>Interfaces</h1><p>A lot of the power and extensibility in Julia comes from a collection of informal interfaces.  By extending a few specific methods to work for a custom type, objects of that type not only receive those functionalities, but they are also able to be used in other methods that are written to generically build upon those behaviors.</p><a id="Iteration-1"></a><h2>Iteration</h2><table><tr><th>Required methods</th><th> </th><th>Brief description</th></tr><tr><td><code>start(iter)</code></td><td> </td><td>Returns the initial iteration state</td></tr><tr><td><code>next(iter, state)</code></td><td> </td><td>Returns the current item and the next state</td></tr><tr><td><code>done(iter, state)</code></td><td> </td><td>Tests if there are any items remaining</td></tr><tr><td><strong>Important optional methods</strong></td><td><strong>Default definition</strong></td><td><strong>Brief description</strong></td></tr><tr><td><code>iteratorsize(IterType)</code></td><td><code>HasLength()</code></td><td>One of <em>HasLength()</em>, <em>HasShape()</em>, <em>IsInfinite()</em>, or <em>SizeUnknown()</em> as appropriate</td></tr><tr><td><code>iteratoreltype(IterType)</code></td><td><code>HasEltype()</code></td><td>Either <em>EltypeUnknown()</em> or <em>HasEltype()</em> as appropriate</td></tr><tr><td><code>eltype(IterType)</code></td><td><code>Any</code></td><td>The type the items returned by <code>next()</code></td></tr><tr><td><code>length(iter)</code></td><td>(<em>undefined</em>)</td><td>The number of items, if known</td></tr><tr><td><code>size(iter, [dim...])</code></td><td>(<em>undefined</em>)</td><td>The number of items in each dimension, if known</td></tr></table><table><tr><th>Value returned by <code>iteratorsize(IterType)</code></th><th>Required Methods</th></tr><tr><td><em>HasLength()</em></td><td><code>length(iter)</code></td></tr><tr><td><em>HasShape()</em></td><td><code>length(iter)</code>  and <code>size(iter, [dim...])</code></td></tr><tr><td><em>IsInfinite()</em></td><td>(<em>none</em>)</td></tr><tr><td><em>SizeUnknown()</em></td><td>(<em>none</em>)</td></tr></table><table><tr><th>Value returned by <code>iteratoreltype(IterType)</code></th><th>Required Methods</th></tr><tr><td><em>HasEltype()</em></td><td><code>eltype(IterType)</code></td></tr><tr><td><em>EltypeUnknown()</em></td><td>(<em>none</em>)</td></tr></table><p>Sequential iteration is implemented by the methods <code>start()</code>, <code>done()</code>, and <code>next()</code>. Instead of mutating objects as they are iterated over, Julia provides these three methods to keep track of the iteration state externally from the object. The <code>start(iter)</code> method returns the initial state for the iterable object <code>iter</code>. That state gets passed along to <code>done(iter, state)</code>, which tests if there are any elements remaining, and <code>next(iter, state)</code>, which returns a tuple containing the current element and an updated <code>state</code>. The <code>state</code> object can be anything, and is generally considered to be an implementation detail private to the iterable object.</p><p>Any object defines these three methods is iterable and can be used in the <a href="@ref">many functions that rely upon iteration</a>. It can also be used directly in a <code>for</code> loop since the syntax:</p><pre><code class="language-julia">for i in iter   # or  &quot;for i = iter&quot;
    # body
end</code></pre><p>is translated into:</p><pre><code class="language-julia">state = start(iter)
while !done(iter, state)
    (i, state) = next(iter, state)
    # body
end</code></pre><p>A simple example is an iterable sequence of square numbers with a defined length:</p><pre><code class="language-jlcon">julia&gt; immutable Squares
           count::Int
       end
       Base.start(::Squares) = 1
       Base.next(S::Squares, state) = (state*state, state+1)
       Base.done(S::Squares, s) = s &gt; S.count;
       Base.eltype(::Type{Squares}) = Int # Note that this is defined for the type
       Base.length(S::Squares) = S.count;</code></pre><p>With only <code>start</code>, <code>next</code>, and <code>done</code> definitions, the <code>Squares</code> type is already pretty powerful. We can iterate over all the elements:</p><pre><code class="language-jlcon">julia&gt; for i in Squares(7)
           println(i)
       end
1
4
9
16
25
36
49</code></pre><p>We can use many of the builtin methods that work with iterables, like <code>in()</code>, <code>mean()</code> and <code>std()</code>:</p><pre><code class="language-jlcon">julia&gt; 25 in Squares(10)
true

julia&gt; mean(Squares(100)), std(Squares(100))
(3383.5,3024.355854282583)</code></pre><p>There are a few more methods we can extend to give Julia more information about this iterable collection.  We know that the elements in a <code>Squares</code> sequence will always be <code>Int</code>. By extending the <code>eltype()</code> method, we can give that information to Julia and help it make more specialized code in the more complicated methods. We also know the number of elements in our sequence, so we can extend <code>length()</code>, too.</p><p>Now, when we ask Julia to <code>collect()</code> all the elements into an array it can preallocate a <code>Vector{Int}</code> of the right size instead of blindly <code>push!</code>ing each element into a <code>Vector{Any}</code>:</p><pre><code class="language-jlcon">julia&gt; collect(Squares(100))&#39; # transposed to save space
1×100 Array{Int64,2}:
 1  4  9  16  25  36  49  64  81  100  …  9025  9216  9409  9604  9801  10000</code></pre><p>While we can rely upon generic implementations, we can also extend specific methods where we know there is a simpler algorithm.  For example, there&#39;s a formula to compute the sum of squares, so we can override the generic iterative version with a more performant solution:</p><pre><code class="language-jlcon">julia&gt; Base.sum(S::Squares) = (n = S.count; return n*(n+1)*(2n+1)÷6)
       sum(Squares(1803))
1955361914</code></pre><p>This is a very common pattern throughout the Julia standard library: a small set of required methods define an informal interface that enable many fancier behaviors.  In some cases, types will want to additionally specialize those extra behaviors when they know a more efficient algorithm can be used in their specific case.</p><a id="Indexing-1"></a><h2>Indexing</h2><table><tr><th>Methods to implement</th><th>Brief description</th></tr><tr><td><code>getindex(X, i)</code></td><td><code>X[i]</code>, indexed element access</td></tr><tr><td><code>setindex!(X, v, i)</code></td><td><code>X[i] = v</code>, indexed assignment</td></tr><tr><td><code>endof(X)</code></td><td>The last index, used in <code>X[end]</code></td></tr></table><p>For the <code>Squares</code> iterable above, we can easily compute the <code>i</code>th element of the sequence by squaring it.  We can expose this as an indexing expression <code>S[i]</code>.  To opt into this behavior, <code>Squares</code> simply needs to define <code>getindex()</code>:</p><pre><code class="language-jlcon">julia&gt; function Base.getindex(S::Squares, i::Int)
           1 &lt;= i &lt;= S.count || throw(BoundsError(S, i))
           return i*i
       end
       Squares(100)[23]
529</code></pre><p>Additionally, to support the syntax <code>S[end]</code>, we must define <code>endof()</code> to specify the last valid index:</p><pre><code class="language-jlcon">julia&gt; Base.endof(S::Squares) = length(S)
       Squares(23)[end]
529</code></pre><p>Note, though, that the above <em>only</em> defines <code>getindex()</code> with one integer index. Indexing with anything other than an <code>Int</code> will throw a <code>MethodError</code> saying that there was no matching method.  In order to support indexing with ranges or vectors of Ints, separate methods must be written:</p><pre><code class="language-jlcon">julia&gt; Base.getindex(S::Squares, i::Number) = S[convert(Int, i)]
       Base.getindex(S::Squares, I) = [S[i] for i in I]
       Squares(10)[[3,4.,5]]
3-element Array{Int64,1}:
  9
 16
 25</code></pre><p>While this is starting to support more of the <a href="@ref">indexing operations supported by some of the builtin types</a>, there&#39;s still quite a number of behaviors missing. This <code>Squares</code> sequence is starting to look more and more like a vector as we&#39;ve added behaviors to it. Instead of defining all these behaviors ourselves, we can officially define it as a subtype of an <code>AbstractArray</code>.</p><a id="Abstract-Arrays-1"></a><h2>Abstract Arrays</h2><table><tr><th>Methods to implement</th><th> </th><th>Brief description</th></tr><tr><td><code>size(A)</code></td><td> </td><td>Returns a tuple containing the dimensions of <code>A</code></td></tr><tr><td><code>getindex(A, i::Int)</code></td><td> </td><td>(if <code>LinearFast</code>) Linear scalar indexing</td></tr><tr><td><code>getindex(A, I::Vararg{Int, N})</code></td><td> </td><td>(if <code>LinearSlow</code>, where <code>N = ndims(A)</code>) N-dimensional scalar indexing</td></tr><tr><td><code>setindex!(A, v, i::Int)</code></td><td> </td><td>(if <code>LinearFast</code>) Scalar indexed assignment</td></tr><tr><td><code>setindex!(A, v, I::Vararg{Int, N})</code></td><td> </td><td>(if <code>LinearSlow</code>, where <code>N = ndims(A)</code>) N-dimensional scalar indexed assignment</td></tr><tr><td><strong>Optional methods</strong></td><td><strong>Default definition</strong></td><td><strong>Brief description</strong></td></tr><tr><td><code>Base.linearindexing(::Type)</code></td><td><code>Base.LinearSlow()</code></td><td>Returns either <code>Base.LinearFast()</code> or <code>Base.LinearSlow()</code>. See the description below.</td></tr><tr><td><code>getindex(A, I...)</code></td><td>defined in terms of scalar <code>getindex()</code></td><td><a href="@ref">Multidimensional and nonscalar indexing</a></td></tr><tr><td><code>setindex!(A, I...)</code></td><td>defined in terms of scalar <code>setindex!()</code></td><td><a href="@ref">Multidimensional and nonscalar indexed assignment</a></td></tr><tr><td><code>start()</code>/<code>next()</code>/<code>done()</code></td><td>defined in terms of scalar <code>getindex()</code></td><td>Iteration</td></tr><tr><td><code>length(A)</code></td><td><code>prod(size(A))</code></td><td>Number of elements</td></tr><tr><td><code>similar(A)</code></td><td><code>similar(A, eltype(A), size(A))</code></td><td>Return a mutable array with the same shape and element type</td></tr><tr><td><code>similar(A, ::Type{S})</code></td><td><code>similar(A, S, size(A))</code></td><td>Return a mutable array with the same shape and the specified element type</td></tr><tr><td><code>similar(A, dims::NTuple{Int})</code></td><td><code>similar(A, eltype(A), dims)</code></td><td>Return a mutable array with the same element type and size <em>dims</em></td></tr><tr><td><code>similar(A, ::Type{S}, dims::NTuple{Int})</code></td><td><code>Array{S}(dims)</code></td><td>Return a mutable array with the specified element type and size</td></tr><tr><td><strong>Non-traditional indices</strong></td><td><strong>Default definition</strong></td><td><strong>Brief description</strong></td></tr><tr><td><code>indices(A)</code></td><td><code>map(OneTo, size(A))</code></td><td>Return the <code>AbstractUnitRange</code> of valid indices</td></tr><tr><td><code>Base.similar(A, ::Type{S}, inds::NTuple{Ind})</code></td><td><code>similar(A, S, Base.to_shape(inds))</code></td><td>Return a mutable array with the specified indices <code>inds</code> (see below)</td></tr><tr><td><code>Base.similar(T::Union{Type,Function}, inds)</code></td><td><code>T(Base.to_shape(inds))</code></td><td>Return an array similar to <code>T</code> with the specified indices <code>inds</code> (see below)</td></tr></table><p>If a type is defined as a subtype of <code>AbstractArray</code>, it inherits a very large set of rich behaviors including iteration and multidimensional indexing built on top of single-element access.  See the <a href="@ref">arrays manual page</a> and <a href="@ref">standard library section</a> for more supported methods.</p><p>A key part in defining an <code>AbstractArray</code> subtype is <code>Base.linearindexing()</code>. Since indexing is such an important part of an array and often occurs in hot loops, it&#39;s important to make both indexing and indexed assignment as efficient as possible.  Array data structures are typically defined in one of two ways: either it most efficiently accesses its elements using just one index (linear indexing) or it intrinsically accesses the elements with indices specified for every dimension.  These two modalities are identified by Julia as <code>Base.LinearFast()</code> and <code>Base.LinearSlow()</code>.  Converting a linear index to multiple indexing subscripts is typically very expensive, so this provides a traits-based mechanism to enable efficient generic code for all array types.</p><p>This distinction determines which scalar indexing methods the type must define. <code>LinearFast()</code> arrays are simple: just define <code>getindex(A::ArrayType, i::Int)</code>.  When the array is subsequently indexed with a multidimensional set of indices, the fallback <code>getindex(A::AbstractArray, I...)()</code> efficiently converts the indices into one linear index and then calls the above method. <code>LinearSlow()</code> arrays, on the other hand, require methods to be defined for each supported dimensionality with <code>ndims(A)</code><code>Int</code> indices.  For example, the builtin <code>SparseMatrixCSC</code> type only supports two dimensions, so it just defines <code>getindex(A::SparseMatrixCSC, i::Int, j::Int)()</code>.  The same holds for <code>setindex!()</code>.</p><p>Returning to the sequence of squares from above, we could instead define it as a subtype of an <code>AbstractArray{Int, 1}</code>:</p><pre><code class="language-jlcon">julia&gt; immutable SquaresVector &lt;: AbstractArray{Int, 1}
           count::Int
       end
       Base.size(S::SquaresVector) = (S.count,)
       Base.linearindexing{T&lt;:SquaresVector}(::Type{T}) = Base.LinearFast()
       Base.getindex(S::SquaresVector, i::Int) = i*i;</code></pre><p>Note that it&#39;s very important to specify the two parameters of the <code>AbstractArray</code>; the first defines the <code>eltype()</code>, and the second defines the <code>ndims()</code>.  That supertype and those three methods are all it takes for <code>SquaresVector</code> to be an iterable, indexable, and completely functional array:</p><pre><code class="language-jlcon">julia&gt; s = SquaresVector(7)
7-element SquaresVector:
  1
  4
  9
 16
 25
 36
 49

julia&gt; s[s .&gt; 20]
3-element Array{Int64,1}:
 25
 36
 49

julia&gt; s \ rand(7,2)
1×2 Array{Float64,2}:
 0.0151876  0.0179393</code></pre><p>As a more complicated example, let&#39;s define our own toy N-dimensional sparse-like array type built on top of <code>Dict</code>:</p><pre><code class="language-jlcon">julia&gt; immutable SparseArray{T,N} &lt;: AbstractArray{T,N}
           data::Dict{NTuple{N,Int}, T}
           dims::NTuple{N,Int}
       end
       SparseArray{T}(::Type{T}, dims::Int...) = SparseArray(T, dims)
       SparseArray{T,N}(::Type{T}, dims::NTuple{N,Int}) = SparseArray{T,N}(Dict{NTuple{N,Int}, T}(), dims)
SparseArray{T,N}

julia&gt; Base.size(A::SparseArray) = A.dims
       Base.similar{T}(A::SparseArray, ::Type{T}, dims::Dims) = SparseArray(T, dims)
       # Define scalar indexing and indexed assignment
       Base.getindex{T,N}(A::SparseArray{T,N}, I::Vararg{Int,N})     = get(A.data, I, zero(T))
       Base.setindex!{T,N}(A::SparseArray{T,N}, v, I::Vararg{Int,N}) = (A.data[I] = v)</code></pre><p>Notice that this is a <code>LinearSlow</code> array, so we must manually define <code>getindex()</code> and <code>setindex!()</code> at the dimensionality of the array.  Unlike the <code>SquaresVector</code>, we are able to define <code>setindex!()</code>, and so we can mutate the array:</p><pre><code class="language-jlcon">julia&gt; A = SparseArray(Float64,3,3)
3×3 SparseArray{Float64,2}:
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0

julia&gt; rand!(A)
3×3 SparseArray{Float64,2}:
 0.28119   0.0203749  0.0769509
 0.209472  0.287702   0.640396
 0.251379  0.859512   0.873544

julia&gt; A[:] = 1:length(A); A
3×3 SparseArray{Float64,2}:
 1.0  4.0  7.0
 2.0  5.0  8.0
 3.0  6.0  9.0</code></pre><p>The result of indexing an <code>AbstractArray</code> can itself be an array (for instance when indexing by a <code>Range</code>). The <code>AbstractArray</code> fallback methods use <code>similar()</code> to allocate an <code>Array</code> of the appropriate size and element type, which is filled in using the basic indexing method described above. However, when implementing an array wrapper you often want the result to be wrapped as well:</p><pre><code class="language-jlcon">julia&gt; A[1:2,:]
2×3 SparseArray{Float64,2}:
 1.0  4.0  7.0
 2.0  5.0  8.0</code></pre><p>In this example it is accomplished by defining <code>Base.similar{T}(A::SparseArray, ::Type{T}, dims::Dims)</code> to create the appropriate wrapped array. (Note that while <code>similar</code> supports 1- and 2-argument forms, in most case you only need to specialize the 3-argument form.) For this to work it&#39;s important that <code>SparseArray</code> is mutable (supports <code>setindex!</code>). <code>similar()</code> is also used to allocate result arrays for arithmetic on <code>AbstractArrays</code>, for instance:</p><pre><code class="language-jlcon">julia&gt; A + 4
3×3 SparseArray{Float64,2}:
 5.0   8.0  11.0
 6.0   9.0  12.0
 7.0  10.0  13.0</code></pre><p>In addition to all the iterable and indexable methods from above, these types can also interact with each other and use all of the methods defined in the standard library for <code>AbstractArrays</code>:</p><pre><code class="language-jlcon">julia&gt; A[SquaresVector(3)]
3-element SparseArray{Float64,1}:
 1.0
 4.0
 9.0

julia&gt; dot(A[:,1],A[:,2])
32.0</code></pre><p>If you are defining an array type that allows non-traditional indexing (indices that start at something other than 1), you should specialize <code>indices</code>.  You should also specialize <code>similar</code> so that the <code>dims</code> argument (ordinarily a <code>Dims</code> size-tuple) can accept <code>AbstractUnitRange</code> objects, perhaps range-types <code>Ind</code> of your own design.  For more information, see <a href="../devdocs/offset-arrays.html#Arrays-with-custom-indices-1">Arrays with custom indices</a>.</p><footer><hr/><a class="previous" href="interacting-with-julia.html"><span class="direction">Previous</span><span class="title">Interacting With Julia</span></a><a class="next" href="introduction.html"><span class="direction">Next</span><span class="title">Introduction</span></a></footer></article></body></html>
