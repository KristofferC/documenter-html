<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Documenter.jl</title><link href="../normalize.css" rel="stylesheet" type="text/css"/><link href="../style.css" rel="stylesheet" type="text/css"/><link href="../highlight.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="../require.js" data-main="../documenter.js"></script><script src="../search-index.js"></script></head><body><nav class="toc"><a href="http://julialang.org/"><img class="logo" src="http://docs.julialang.org/en/release-0.4/_static/julia-logo.svg" alt="\$pkgname.jl logo"/></a><h1>$pkgname.jl</h1><input type="text" placeholder="Search docs"/><ul><li><a class="toctext" href="../index.html">Overview</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../man/guide.html">Guide</a></li><li><a class="toctext" href="../man/examples.html">Examples</a></li><li><a class="toctext" href="../man/syntax.html">Syntax</a></li><li><a class="toctext" href="../man/doctests.html">Doctests</a></li><li><a class="toctext" href="../man/hosting.html">Hosting Documentation</a></li><li><a class="toctext" href="../man/latex.html"><span>$\LaTeX$</span> syntax</a></li><li><a class="toctext" href="../man/internals.html">Package Internals</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../lib/public.html">Public Documentation</a></li><li><a class="toctext" href="../lib/internals.html">Internal Documentation</a></li></ul></li><li><span class="toctext">Dynamic pages</span><ul><li><a class="toctext" href="../dynamic/code.html">Code examples</a></li><li><a class="toctext" href="../dynamic/admonitions.html">Admonitions &amp; Co</a></li><li><a class="toctext" href="../dynamic/styles.html">Demonstrating <em>styles</em> of MD elements</a></li><li><a class="toctext" href="../dynamic/bugs.html">Some existing bugs</a></li></ul></li><li><span class="toctext">JuliaDocs - Manual</span><ul><li><a class="toctext" href="arrays.html">Multi-dimensional Arrays</a></li><li><a class="toctext" href="calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="toctext" href="complex-and-rational-numbers.html">Complex and Rational Numbers</a></li><li><a class="toctext" href="constructors.html">Constructors</a></li><li><a class="toctext" href="control-flow.html">Control Flow</a></li><li><a class="toctext" href="conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="toctext" href="dates.html">Date and DateTime</a></li><li><a class="toctext" href="documentation.html">Documentation</a></li><li><a class="toctext" href="embedding.html">Embedding Julia</a></li><li><a class="toctext" href="faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="functions.html">Functions</a></li><li><a class="toctext" href="getting-started.html">Getting Started</a></li><li><a class="toctext" href="handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="index.html">The Julia Manual</a></li><li><a class="toctext" href="integers-and-floating-point-numbers.html">Integers and Floating-Point Numbers</a></li><li><a class="toctext" href="interacting-with-julia.html">Interacting With Julia</a></li><li><a class="toctext" href="interfaces.html">Interfaces</a></li><li><a class="toctext" href="introduction.html">Introduction</a></li><li><a class="toctext" href="linear-algebra.html">Linear algebra</a></li><li><a class="toctext" href="mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="metaprogramming.html">Metaprogramming</a></li><li><a class="toctext" href="methods.html">Methods</a></li><li><a class="toctext" href="modules.html">Modules</a></li><li><a class="toctext" href="networking-and-streams.html">Networking and Streams</a></li><li><a class="toctext" href="noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="packages.html">Packages</a></li><li class="current"><a class="toctext" href="parallel-computing.html">Parallel Computing</a><ul class="internal"><li><a class="toctext" href="#Code-Availability-and-Loading-Packages-1">Code Availability and Loading Packages</a></li><li><a class="toctext" href="#Data-Movement-1">Data Movement</a></li><li><a class="toctext" href="#Parallel-Map-and-Loops-1">Parallel Map and Loops</a></li><li><a class="toctext" href="#Synchronization-With-Remote-References-1">Synchronization With Remote References</a></li><li><a class="toctext" href="#Scheduling-1">Scheduling</a></li><li><a class="toctext" href="#Channels-1">Channels</a></li><li><a class="toctext" href="#Remote-references-and-AbstractChannels-1">Remote references and AbstractChannels</a></li><li><a class="toctext" href="#Remote-References-and-Distributed-Garbage-Collection-1">Remote References and Distributed Garbage Collection</a></li><li><a class="toctext" href="#Shared-Arrays-1">Shared Arrays</a></li><li><a class="toctext" href="#Shared-Arrays-and-Distributed-Garbage-Collection-1">Shared Arrays and Distributed Garbage Collection</a></li><li><a class="toctext" href="#ClusterManagers-1">ClusterManagers</a></li><li><a class="toctext" href="#Cluster-Managers-with-custom-transports-1">Cluster Managers with custom transports</a></li><li><a class="toctext" href="#Network-requirements-for-LocalManager-and-SSHManager-1">Network requirements for LocalManager and SSHManager</a></li><li><a class="toctext" href="#Cluster-cookie-1">Cluster cookie</a></li><li><a class="toctext" href="#Specifying-network-topology-(Experimental)-1">Specifying network topology (Experimental)</a></li><li><a class="toctext" href="#Multi-threading-(Experimental)-1">Multi-threading (Experimental)</a></li></ul></li><li><a class="toctext" href="performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="profile.html">Profiling</a></li><li><a class="toctext" href="running-external-programs.html">Running External Programs</a></li><li><a class="toctext" href="stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="strings.html">Strings</a></li><li><a class="toctext" href="style-guide.html">Style Guide</a></li><li><a class="toctext" href="types.html">Types</a></li><li><a class="toctext" href="unicode-input.html">Unicode Input</a></li><li><a class="toctext" href="variables-and-scoping.html">Scope of Variables</a></li><li><a class="toctext" href="variables.html">Variables</a></li><li><a class="toctext" href="workflow-tips.html">Workflow Tips</a></li></ul></li><li><span class="toctext">JuliaDocs - Standard Libary</span><ul><li><a class="toctext" href="../stdlib/arrays.html">Arrays</a></li><li><a class="toctext" href="../stdlib/base.html">Essentials</a></li><li><a class="toctext" href="../stdlib/c.html">C Interface</a></li><li><a class="toctext" href="../stdlib/collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="../stdlib/constants.html">Constants</a></li><li><a class="toctext" href="../stdlib/dates.html">Dates and Time</a></li><li><a class="toctext" href="../stdlib/file.html">Filesystem</a></li><li><a class="toctext" href="../stdlib/index.html">The Julia Standard Library</a></li><li><a class="toctext" href="../stdlib/io-network.html">I/O and Network</a></li><li><a class="toctext" href="../stdlib/libc.html">C Standard Library</a></li><li><a class="toctext" href="../stdlib/libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="../stdlib/linalg.html">Linear Algebra</a></li><li><a class="toctext" href="../stdlib/math.html">Mathematics</a></li><li><a class="toctext" href="../stdlib/numbers.html">Numbers</a></li><li><a class="toctext" href="../stdlib/parallel.html">Tasks and Parallel Computing</a></li><li><a class="toctext" href="../stdlib/pkg.html">Package Manager Functions</a></li><li><a class="toctext" href="../stdlib/profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/punctuation.html">Punctuation</a></li><li><a class="toctext" href="../stdlib/simd-types.html">SIMD Support</a></li><li><a class="toctext" href="../stdlib/sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="../stdlib/stacktraces.html">StackTraces</a></li><li><a class="toctext" href="../stdlib/strings.html">Strings</a></li><li><a class="toctext" href="../stdlib/test.html">Unit Testing</a></li></ul></li><li><span class="toctext">JuliaDocs - DevDocs</span><ul><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/C.html">Developing/debugging Julia&#39;s C code</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../devdocs/julia.html">Documentation of Julia&#39;s Internals</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/promote-op.html">Operator-sensitive promotion</a></li><li><a class="toctext" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/types.html">More about types</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>JuliaDocs - Manual</li><li><a href="parallel-computing.html">Parallel Computing</a></li></ul><a class="edit-page" href="https://github.com/"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><a id="Parallel-Computing-1"></a><div class="mdnote debug">Base.Markdown.Header{1}</div><h1>Parallel Computing</h1><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Most modern computers possess more than one CPU, and several computers can be combined together in a cluster. Harnessing the power of these multiple CPUs allows many computations to be completed more quickly. There are two major factors that influence performance: the speed of the CPUs themselves, and the speed of their access to memory. In a cluster, it&#39;s fairly obvious that a given CPU will have fastest access to the RAM within the same computer (node). Perhaps more surprisingly, similar issues are relevant on a typical multicore laptop, due to differences in the speed of main memory and the <a href="http://www.akkadia.org/drepper/cpumemory.pdf">cache</a>. Consequently, a good multiprocessing environment should allow control over the &quot;ownership&quot; of a chunk of memory by a particular CPU. Julia provides a multiprocessing environment based on message passing to allow programs to run on multiple processes in separate memory domains at once.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Julia&#39;s implementation of message passing is different from other environments such as MPI <a href="#footnote-1">[1]</a>. Communication in Julia is generally &quot;one-sided&quot;, meaning that the programmer needs to explicitly manage only one process in a two-process operation. Furthermore, these operations typically do not look like &quot;message send&quot; and &quot;message receive&quot; but rather resemble higher-level operations like calls to user functions.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Parallel programming in Julia is built on two primitives: <em>remote references</em> and <em>remote calls</em>. A remote reference is an object that can be used from any process to refer to an object stored on a particular process. A remote call is a request by one process to call a certain function on certain arguments on another (possibly the same) process.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Remote references come in two flavors -<code>Future</code> and <code>RemoteChannel</code>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>A remote call returns a <code>Future</code> to its result. Remote calls return immediately; the process that made the call proceeds to its next operation while the remote call happens somewhere else. You can wait for a remote call to finish by calling <a href="../stdlib/parallel.html#Base.wait"><code>wait()</code></a> on the returned <em>Future</em>, and you can obtain the full value of the result using <a href="../stdlib/parallel.html#Base.fetch"><code>fetch()</code></a>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>On the other hand <code>RemoteChannel</code> s are rewritable. For example, multiple processes can co-ordinate their processing by referencing the same remote <code>Channel</code>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Let&#39;s try this out. Starting with <code>julia -p n</code> provides <code>n</code> worker processes on the local machine. Generally it makes sense for <code>n</code> to equal the number of CPU cores on the machine.</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span class="go">$ ./julia -p 2
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">r</span><span> </span><span class="o">=</span><span> </span><span class="n">remotecall</span><span class="p">(</span><span class="n">rand</span><span class="p">,</span><span> </span><span class="mi">2</span><span class="p">,</span><span> </span><span class="mi">2</span><span class="p">,</span><span> </span><span class="mi">2</span><span class="p">)</span><span>
</span><span class="go">Future(2,1,3,Nullable{Any}())
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">s</span><span> </span><span class="o">=</span><span> </span><span class="p">@</span><span class="n">spawnat</span><span> </span><span class="mi">2</span><span> </span><span class="mi">1</span><span> </span><span class="o">.</span><span class="o">+</span><span> </span><span class="n">fetch</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span>
</span><span class="go">Future(2,1,6,Nullable{Any}())
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">fetch</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span>
</span><span class="go">2×2 Array{Float64,2}:
</span><span class="go"> 1.60401  1.50111
</span><span class="go"> 1.17457  1.15741
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The first argument to <a href="../stdlib/parallel.html#Base.remotecall"><code>remotecall()</code></a> is the function to call. Most parallel programming in Julia does not reference specific processes or the number of processes available, but <a href="../stdlib/parallel.html#Base.remotecall"><code>remotecall()</code></a> is considered a low-level interface providing finer control. The second argument to <a href="../stdlib/parallel.html#Base.remotecall"><code>remotecall()</code></a> is the index of the process that will do the work, and the remaining arguments will be passed to the function being called.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>As you can see, in the first line we asked process 2 to construct a 2-by-2 random matrix, and in the second line we asked it to add 1 to it. The result of both calculations is available in the two futures, <code>r</code> and <code>s</code>. The <a href="../stdlib/parallel.html#Base.@spawnat"><code>@spawnat</code></a> macro evaluates the expression in the second argument on the process specified by the first argument.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Occasionally you might want a remotely-computed value immediately. This typically happens when you read from a remote object to obtain data needed by the next local operation. The function <a href="../stdlib/parallel.html#Base.remotecall_fetch"><code>remotecall_fetch()</code></a> exists for this purpose. It is equivalent to <code>fetch(remotecall(...))</code> but is more efficient.</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">remotecall_fetch</span><span class="p">(</span><span class="n">getindex</span><span class="p">,</span><span> </span><span class="mi">2</span><span class="p">,</span><span> </span><span class="n">r</span><span class="p">,</span><span> </span><span class="mi">1</span><span class="p">,</span><span> </span><span class="mi">1</span><span class="p">)</span><span>
</span><span class="go">0.10824216411304866
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Remember that <a href="../stdlib/collections.html#Base.getindex"><code>getindex(r,1,1)</code></a> is <a href="@ref">equivalent</a> to <code>r[1,1]</code>, so this call fetches the first element of the future <code>r</code>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The syntax of <a href="../stdlib/parallel.html#Base.remotecall"><code>remotecall()</code></a> is not especially convenient. The macro <a href="../stdlib/parallel.html#Base.@spawn"><code>@spawn</code></a> makes things easier. It operates on an expression rather than a function, and picks where to do the operation for you:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">r</span><span> </span><span class="o">=</span><span> </span><span class="p">@</span><span class="n">spawn</span><span> </span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span>
</span><span class="go">Future(2,1,4,Nullable{Any}())
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">s</span><span> </span><span class="o">=</span><span> </span><span class="p">@</span><span class="n">spawn</span><span> </span><span class="mi">1</span><span> </span><span class="o">.</span><span class="o">+</span><span> </span><span class="n">fetch</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span>
</span><span class="go">Future(3,1,5,Nullable{Any}())
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">fetch</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span>
</span><span class="go">1.10824216411304866 1.13798233877923116
</span><span class="go">1.12376292706355074 1.18750497916607167
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Note that we used <code>1 .+ fetch(r)</code> instead of <code>1 .+ r</code>. This is because we do not know where the code will run, so in general a <a href="../stdlib/parallel.html#Base.fetch"><code>fetch()</code></a> might be required to move <code>r</code> to the process doing the addition. In this case, <a href="../stdlib/parallel.html#Base.@spawn"><code>@spawn</code></a> is smart enough to perform the computation on the process that owns <code>r</code>, so the <a href="../stdlib/parallel.html#Base.fetch"><code>fetch()</code></a> will be a no-op.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>(It is worth noting that <a href="../stdlib/parallel.html#Base.@spawn"><code>@spawn</code></a> is not built-in but defined in Julia as a <a href="@ref">macro</a>. It is possible to define your own such constructs.)</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>An important thing to remember is that, once fetched, a <code>Future</code> will cache its value locally. Further <code>fetch</code> calls do not entail a network hop. Once all referencing Futures have fetched, the remote stored value is deleted.</p><a id="Code-Availability-and-Loading-Packages-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Code Availability and Loading Packages</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Your code must be available on any process that runs it. For example, type the following into the Julia prompt:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="k">function</span><span class="nf"> </span><span class="nf">rand2</span><span class="p">(</span><span class="n">dims</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="p">)</span><span>
</span><span class="gt">
         return 2*rand(dims...)
</span><span></span><span class="gt">
       end
</span><span></span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">rand2</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span>
</span><span class="go">2×2 Array{Float64,2}:
</span><span class="go"> 0.153756  0.368514
</span><span class="go"> 1.15119   0.918912
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">fetch</span><span class="p">(</span><span class="p">@</span><span class="n">spawn</span><span> </span><span class="n">rand2</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="go">ERROR: On worker 2:
</span><span class="go">function rand2 not defined on process 2
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Process 1 knew about the function <code>rand2</code>, but process 2 did not.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Most commonly you&#39;ll be loading code from files or packages, and you have a considerable amount of flexibility in controlling which processes load code.  Consider a file, <code>&quot;DummyModule.jl&quot;</code>, containing the following code:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">module</span><span> </span><span class="n">DummyModule</span><span>
</span><span>
</span><span class="k">export</span><span> </span><span class="n">MyType</span><span class="p">,</span><span> </span><span class="n">f</span><span>
</span><span>
</span><span class="k">type</span><span class="nc"> </span><span class="nc">MyType</span><span>
</span><span>    </span><span class="n">a</span><span class="p">:</span><span class="p">:</span><span class="kt">Int</span><span>
</span><span class="k">end</span><span>
</span><span>
</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span>
</span><span>
</span><span class="n">println</span><span class="p">(</span><span class="s">&quot;</span><span class="s">loaded</span><span class="s">&quot;</span><span class="p">)</span><span>
</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Starting Julia with <code>julia -p 2</code>, you can use this to verify the following:</p><div class="mdnote debug">Base.Markdown.List</div><ul><li><p><a href="@ref"><code>include(&quot;DummyModule.jl&quot;)</code></a> loads the file on just a single process (whichever one executes the statement).</p></li><li><p><code>using DummyModule</code> causes the module to be loaded on all processes; however, the module is brought into scope only on the one executing the statement.</p></li><li><p>As long as <code>DummyModule</code> is loaded on process 2, commands like</p><code>rr = RemoteChannel(2)
put!(rr, MyType(7))</code><p>allow you to store an object of type <code>MyType</code> on process 2 even if <code>DummyModule</code> is not in scope on process 2.</p></li></ul><div class="mdnote debug">Base.Markdown.Paragraph</div><p>You can force a command to run on all processes using the <a href="../stdlib/parallel.html#Base.@everywhere"><code>@everywhere</code></a> macro. For example, <a href="../stdlib/parallel.html#Base.@everywhere"><code>@everywhere</code></a> can also be used to directly define a function on all processes:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="p">@</span><span class="n">everywhere</span><span> </span><span class="n">id</span><span> </span><span class="o">=</span><span> </span><span class="n">myid</span><span class="p">(</span><span class="p">)</span><span>
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">remotecall_fetch</span><span class="p">(</span><span class="p">(</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span><span> </span><span class="mi">2</span><span class="p">)</span><span>
</span><span class="go">2
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>A file can also be preloaded on multiple processes at startup, and a driver script can be used to drive the computation:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">julia -p &lt;n&gt; -L file1.jl -L file2.jl driver.jl</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Each process has an associated identifier. The process providing the interactive Julia prompt always has an id equal to 1, as would the Julia process running the driver script in the example above. The processes used by default for parallel operations are referred to as &quot;workers&quot;. When there is only one process, process 1 is considered a worker. Otherwise, workers are considered to be all processes other than process 1.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The base Julia installation has in-built support for two types of clusters:</p><div class="mdnote debug">Base.Markdown.List</div><ul><li><p>A local cluster specified with the <code>-p</code> option as shown above.</p></li><li><p>A cluster spanning machines using the <code>--machinefile</code> option. This uses a passwordless <code>ssh</code> login to start Julia worker processes (from the same path as the current host) on the specified machines.</p></li></ul><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Functions <a href="../stdlib/parallel.html#Base.addprocs"><code>addprocs()</code></a>, <a href="../stdlib/parallel.html#Base.rmprocs"><code>rmprocs()</code></a>, <a href="../stdlib/parallel.html#Base.workers"><code>workers()</code></a>, and others are available as a programmatic means of adding, removing and querying the processes in a cluster.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Note that workers do not run a <code>.juliarc.jl</code> startup script, nor do they synchronize their global state (such as global variables, new method definitions, and loaded modules) with any of the other running processes.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Other types of clusters can be supported by writing your own custom <code>ClusterManager</code>, as described below in the <a href="parallel-computing.html#ClusterManagers-1">ClusterManagers</a> section.</p><a id="Data-Movement-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Data Movement</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Sending messages and moving data constitute most of the overhead in a parallel program. Reducing the number of messages and the amount of data sent is critical to achieving performance and scalability. To this end, it is important to understand the data movement performed by Julia&#39;s various parallel programming constructs.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p><a href="../stdlib/parallel.html#Base.fetch"><code>fetch()</code></a> can be considered an explicit data movement operation, since it directly asks that an object be moved to the local machine. <a href="../stdlib/parallel.html#Base.@spawn"><code>@spawn</code></a> (and a few related constructs) also moves data, but this is not as obvious, hence it can be called an implicit data movement operation. Consider these two approaches to constructing and squaring a random matrix:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none"># method 1
A = rand(1000,1000)
Bref = @spawn A^2
...
fetch(Bref)

# method 2
Bref = @spawn rand(1000,1000)^2
...
fetch(Bref)</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The difference seems trivial, but in fact is quite significant due to the behavior of <a href="../stdlib/parallel.html#Base.@spawn"><code>@spawn</code></a>. In the first method, a random matrix is constructed locally, then sent to another process where it is squared. In the second method, a random matrix is both constructed and squared on another process. Therefore the second method sends much less data than the first.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In this toy example, the two methods are easy to distinguish and choose from. However, in a real program designing data movement might require more thought and likely some measurement. For example, if the first process needs matrix <code>A</code> then the first method might be better. Or, if computing <code>A</code> is expensive and only the current process has it, then moving it to another process might be unavoidable. Or, if the current process has very little to do between the <a href="../stdlib/parallel.html#Base.@spawn"><code>@spawn</code></a> and <code>fetch(Bref)</code> then it might be better to eliminate the parallelism altogether. Or imagine <code>rand(1000,1000)</code> is replaced with a more expensive operation. Then it might make sense to add another <a href="../stdlib/parallel.html#Base.@spawn"><code>@spawn</code></a> statement just for this step.</p><a id="Parallel-Map-and-Loops-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Parallel Map and Loops</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Fortunately, many useful parallel computations do not require data movement. A common example is a Monte Carlo simulation, where multiple processes can handle independent simulation trials simultaneously. We can use <a href="../stdlib/parallel.html#Base.@spawn"><code>@spawn</code></a> to flip coins on two processes. First, write the following function in <code>count_heads.jl</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">function</span><span class="nf"> </span><span class="nf">count_heads</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span>
</span><span>    </span><span class="n">c</span><span class="p">:</span><span class="p">:</span><span class="kt">Int</span><span> </span><span class="o">=</span><span> </span><span class="mi">0</span><span>
</span><span>    </span><span class="k">for</span><span> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span>
</span><span>        </span><span class="n">c</span><span> </span><span class="o">+</span><span class="o">=</span><span> </span><span class="n">rand</span><span class="p">(</span><span class="kt">Bool</span><span class="p">)</span><span>
</span><span>    </span><span class="k">end</span><span>
</span><span>    </span><span class="n">c</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The function <code>count_heads</code> simply adds together <code>n</code> random bits. Here is how we can perform some trials on two machines, and add together the results:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="p">@</span><span class="n">everywhere</span><span> </span><span class="n">include</span><span class="p">(</span><span class="s">&quot;</span><span class="s">count_heads.jl</span><span class="s">&quot;</span><span class="p">)</span><span>
</span><span>
</span><span class="n">a</span><span> </span><span class="o">=</span><span> </span><span class="p">@</span><span class="n">spawn</span><span> </span><span class="n">count_heads</span><span class="p">(</span><span class="mi">100000000</span><span class="p">)</span><span>
</span><span class="n">b</span><span> </span><span class="o">=</span><span> </span><span class="p">@</span><span class="n">spawn</span><span> </span><span class="n">count_heads</span><span class="p">(</span><span class="mi">100000000</span><span class="p">)</span><span>
</span><span class="n">fetch</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">+</span><span class="n">fetch</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This example demonstrates a powerful and often-used parallel programming pattern. Many iterations run independently over several processes, and then their results are combined using some function. The combination process is called a <em>reduction</em>, since it is generally tensor-rank-reducing: a vector of numbers is reduced to a single number, or a matrix is reduced to a single row or column, etc. In code, this typically looks like the pattern <code>x = f(x,v[i])</code>, where <code>x</code> is the accumulator, <code>f</code> is the reduction function, and the <code>v[i]</code> are the elements being reduced. It is desirable for <code>f</code> to be associative, so that it does not matter what order the operations are performed in.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Notice that our use of this pattern with <code>count_heads</code> can be generalized. We used two explicit <a href="../stdlib/parallel.html#Base.@spawn"><code>@spawn</code></a> statements, which limits the parallelism to two processes. To run on any number of processes, we can use a <em>parallel for loop</em>, which can be written in Julia like this:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">nheads</span><span> </span><span class="o">=</span><span> </span><span class="p">@</span><span class="n">parallel</span><span> </span><span class="p">(</span><span class="o">+</span><span class="p">)</span><span> </span><span class="k">for</span><span> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">200000000</span><span>
</span><span>  </span><span class="kt">Int</span><span class="p">(</span><span class="n">rand</span><span class="p">(</span><span class="kt">Bool</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This construct implements the pattern of assigning iterations to multiple processes, and combining them with a specified reduction (in this case <code>(+)</code>). The result of each iteration is taken as the value of the last expression inside the loop. The whole parallel loop expression itself evaluates to the final answer.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Note that although parallel for loops look like serial for loops, their behavior is dramatically different. In particular, the iterations do not happen in a specified order, and writes to variables or arrays will not be globally visible since iterations run on different processes. Any variables used inside the parallel loop will be copied and broadcast to each process.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>For example, the following code will not work as intended:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">a</span><span> </span><span class="o">=</span><span> </span><span class="n">zeros</span><span class="p">(</span><span class="mi">100000</span><span class="p">)</span><span>
</span><span class="p">@</span><span class="n">parallel</span><span> </span><span class="k">for</span><span> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">100000</span><span>
</span><span>  </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span> </span><span class="o">=</span><span> </span><span class="n">i</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>However, this code will not initialize all of <code>a</code>, since each process will have a separate copy of it. Parallel for loops like these must be avoided. Fortunately,  <a href="@ref">Shared Arrays</a> can be used to get around this limitation:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">a</span><span> </span><span class="o">=</span><span> </span><span class="n">SharedArray</span><span class="p">(</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span><span>
</span><span class="p">@</span><span class="n">parallel</span><span> </span><span class="k">for</span><span> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">10</span><span>
</span><span>  </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span> </span><span class="o">=</span><span> </span><span class="n">i</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Using &quot;outside&quot; variables in parallel loops is perfectly reasonable if the variables are read-only:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">a</span><span> </span><span class="o">=</span><span> </span><span class="n">randn</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span><span>
</span><span class="p">@</span><span class="n">parallel</span><span> </span><span class="p">(</span><span class="o">+</span><span class="p">)</span><span> </span><span class="k">for</span><span> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">100000</span><span>
</span><span>  </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">rand</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="k">end</span><span class="p">)</span><span class="p">]</span><span class="p">)</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Here each iteration applies <code>f</code> to a randomly-chosen sample from a vector <code>a</code> shared by all processes.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>As you could see, the reduction operator can be omitted if it is not needed. In that case, the loop executes asynchronously, i.e. it spawns independent tasks on all available workers and returns an array of <a href="../stdlib/parallel.html#Base.Future"><code>Future</code></a> immediately without waiting for completion. The caller can wait for the <a href="../stdlib/parallel.html#Base.Future"><code>Future</code></a> completions at a later point by calling <a href="../stdlib/parallel.html#Base.fetch"><code>fetch()</code></a> on them, or wait for completion at the end of the loop by prefixing it with <a href="../stdlib/parallel.html#Base.@sync"><code>@sync</code></a>, like <code>@sync @parallel for</code>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In some cases no reduction operator is needed, and we merely wish to apply a function to all integers in some range (or, more generally, to all elements in some collection). This is another useful operation called <em>parallel map</em>, implemented in Julia as the <a href="../stdlib/parallel.html#Base.pmap"><code>pmap()</code></a> function. For example, we could compute the singular values of several large random matrices in parallel as follows:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">M</span><span> </span><span class="o">=</span><span> </span><span class="n">Matrix</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span><span class="p">[</span><span class="n">rand</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span><span> </span><span class="k">for</span><span> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span><span>
</span><span class="n">pmap</span><span class="p">(</span><span class="n">svd</span><span class="p">,</span><span> </span><span class="n">M</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Julia&#39;s <a href="../stdlib/parallel.html#Base.pmap"><code>pmap()</code></a> is designed for the case where each function call does a large amount of work. In contrast, <code>@parallel for</code> can handle situations where each iteration is tiny, perhaps merely summing two numbers. Only worker processes are used by both <a href="../stdlib/parallel.html#Base.pmap"><code>pmap()</code></a> and <code>@parallel for</code> for the parallel computation. In case of <code>@parallel for</code>, the final reduction is done on the calling process.</p><a id="Synchronization-With-Remote-References-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Synchronization With Remote References</h2><a id="Scheduling-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Scheduling</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Julia&#39;s parallel programming platform uses <a href="control-flow.html#Tasks-(aka-Coroutines)-1">Tasks (aka Coroutines)</a> to switch among multiple computations. Whenever code performs a communication operation like <a href="../stdlib/parallel.html#Base.fetch"><code>fetch()</code></a> or <a href="../stdlib/parallel.html#Base.wait"><code>wait()</code></a>, the current task is suspended and a scheduler picks another task to run. A task is restarted when the event it is waiting for completes.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>For many problems, it is not necessary to think about tasks directly. However, they can be used to wait for multiple events at the same time, which provides for <em>dynamic scheduling</em>. In dynamic scheduling, a program decides what to compute or where to compute it based on when other jobs finish. This is needed for unpredictable or unbalanced workloads, where we want to assign more work to processes only when they finish their current tasks.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>As an example, consider computing the singular values of matrices of different sizes:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">M</span><span> </span><span class="o">=</span><span> </span><span class="n">Matrix</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span><span class="p">[</span><span class="n">rand</span><span class="p">(</span><span class="mi">800</span><span class="p">,</span><span class="mi">800</span><span class="p">)</span><span class="p">,</span><span> </span><span class="n">rand</span><span class="p">(</span><span class="mi">600</span><span class="p">,</span><span class="mi">600</span><span class="p">)</span><span class="p">,</span><span> </span><span class="n">rand</span><span class="p">(</span><span class="mi">800</span><span class="p">,</span><span class="mi">800</span><span class="p">)</span><span class="p">,</span><span> </span><span class="n">rand</span><span class="p">(</span><span class="mi">600</span><span class="p">,</span><span class="mi">600</span><span class="p">)</span><span class="p">]</span><span>
</span><span class="n">pmap</span><span class="p">(</span><span class="n">svd</span><span class="p">,</span><span> </span><span class="n">M</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>If one process handles both 800×800 matrices and another handles both 600×600 matrices, we will not get as much scalability as we could. The solution is to make a local task to &quot;feed&quot; work to each process when it completes its current task. For example, consider a simple <a href="../stdlib/parallel.html#Base.pmap"><code>pmap()</code></a> implementation:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">function</span><span class="nf"> </span><span class="nf">pmap</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span> </span><span class="n">lst</span><span class="p">)</span><span>
</span><span>    </span><span class="n">np</span><span> </span><span class="o">=</span><span> </span><span class="n">nprocs</span><span class="p">(</span><span class="p">)</span><span>  </span><span class="c"># determine the number of processes available</span><span>
</span><span>    </span><span class="n">n</span><span> </span><span class="o">=</span><span> </span><span class="n">length</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span><span>
</span><span>    </span><span class="n">results</span><span> </span><span class="o">=</span><span> </span><span class="n">Vector</span><span class="p">{</span><span class="kt">Any</span><span class="p">}</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span>
</span><span>    </span><span class="n">i</span><span> </span><span class="o">=</span><span> </span><span class="mi">1</span><span>
</span><span>    </span><span class="c"># function to produce the next work item from the queue.</span><span>
</span><span>    </span><span class="c"># in this case it&#39;s just an index.</span><span>
</span><span>    </span><span class="n">nextidx</span><span class="p">(</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="p">(</span><span class="n">idx</span><span class="o">=</span><span class="n">i</span><span class="p">;</span><span> </span><span class="n">i</span><span class="o">+</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span> </span><span class="n">idx</span><span class="p">)</span><span>
</span><span>    </span><span class="p">@</span><span class="n">sync</span><span> </span><span class="k">begin</span><span>
</span><span>        </span><span class="k">for</span><span> </span><span class="n">p</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">np</span><span>
</span><span>            </span><span class="k">if</span><span> </span><span class="n">p</span><span> </span><span class="o">!=</span><span> </span><span class="n">myid</span><span class="p">(</span><span class="p">)</span><span> </span><span class="o">||</span><span> </span><span class="n">np</span><span> </span><span class="o">==</span><span> </span><span class="mi">1</span><span>
</span><span>                </span><span class="p">@</span><span class="n">async</span><span> </span><span class="k">begin</span><span>
</span><span>                    </span><span class="k">while</span><span> </span><span class="n">true</span><span>
</span><span>                        </span><span class="n">idx</span><span> </span><span class="o">=</span><span> </span><span class="n">nextidx</span><span class="p">(</span><span class="p">)</span><span>
</span><span>                        </span><span class="k">if</span><span> </span><span class="n">idx</span><span> </span><span class="o">&gt;</span><span> </span><span class="n">n</span><span>
</span><span>                            </span><span class="k">break</span><span>
</span><span>                        </span><span class="k">end</span><span>
</span><span>                        </span><span class="n">results</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span> </span><span class="o">=</span><span> </span><span class="n">remotecall_fetch</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span> </span><span class="n">p</span><span class="p">,</span><span> </span><span class="n">lst</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="p">)</span><span>
</span><span>                    </span><span class="k">end</span><span>
</span><span>                </span><span class="k">end</span><span>
</span><span>            </span><span class="k">end</span><span>
</span><span>        </span><span class="k">end</span><span>
</span><span>    </span><span class="k">end</span><span>
</span><span>    </span><span class="n">results</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p><a href="../stdlib/parallel.html#Base.@async"><code>@async</code></a> is similar to <a href="../stdlib/parallel.html#Base.@spawn"><code>@spawn</code></a>, but only runs tasks on the local process. We use it to create a &quot;feeder&quot; task for each process. Each task picks the next index that needs to be computed, then waits for its process to finish, then repeats until we run out of indexes. Note that the feeder tasks do not begin to execute until the main task reaches the end of the <a href="../stdlib/parallel.html#Base.@sync"><code>@sync</code></a> block, at which point it surrenders control and waits for all the local tasks to complete before returning from the function. The feeder tasks are able to share state via <code>nextidx()</code> because they all run on the same process. No locking is required, since the threads are scheduled cooperatively and not preemptively. This means context switches only occur at well-defined points: in this case, when <a href="../stdlib/parallel.html#Base.remotecall_fetch"><code>remotecall_fetch()</code></a> is called.</p><a id="Channels-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Channels</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Channels provide for a fast means of inter-task communication. A <code>Channel{T}(n::Int)</code> is a shared queue of maximum length <code>n</code> holding objects of type <code>T</code>. Multiple readers can read off the channel via <code>fetch</code> and <code>take!</code>. Multiple writers can add to the channel via <code>put!</code>. <code>isready</code> tests for the presence of any object in the channel, while <code>wait</code> waits for an object to become available. <code>close</code> closes a Channel. On a closed channel, <code>put!</code> will fail, while <code>take!</code> and <code>fetch</code> successfully return any existing values till it is emptied.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>A Channel can be used as an iterable object in a <code>for</code> loop, in which case the loop runs as long as the channel has data or is open. The loop variable takes on all values added to the channel. An empty, closed channel causes the <code>for</code> loop to terminate.</p><a id="Remote-references-and-AbstractChannels-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Remote references and AbstractChannels</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Remote references always refer to an implementation of an <code>AbstractChannel</code></p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>A concrete implementation of an <code>AbstractChannel</code> (like <code>Channel</code>), is required to implement <code>put!</code>, <code>take!</code>, <code>fetch</code>, <code>isready</code> and <code>wait</code>. The remote object referred to by a <code>Future</code> is stored in a <code>Channel{Any}(1)</code>, i.e., a channel of size 1 capable of holding objects of <code>Any</code> type.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p><code>RemoteChannel</code>, which is rewritable, can point to any type and size of channels, or any other implementation of an <code>AbstractChannel</code>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The constructor <code>RemoteChannel(f::Function, pid)</code> allows us to construct references to channels holding more than one value of a specific type. <code>f()</code> is a function executed on <code>pid</code> and it must return an <code>AbstractChannel</code>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>For example, <code>RemoteChannel(()-&gt;Channel{Int}(10), pid)</code>, will return a reference to a channel of type <code>Int</code> and size 10. The channel exists on worker <code>pid</code>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Methods <code>put!</code>, <code>take!</code>, <code>fetch</code>, <code>isready</code> and <code>wait</code> on a <code>RemoteChannel</code> are proxied onto the backing store on the remote process.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p><code>RemoteChannel</code> can thus be used to refer to user implemented <code>AbstractChannel</code> objects. A simple example of this is provided in <code>examples/dictchannel.jl</code> which uses a dictionary as its remote store.</p><a id="Remote-References-and-Distributed-Garbage-Collection-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Remote References and Distributed Garbage Collection</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Objects referred to by remote references can be freed only when <em>all</em> held references in the cluster are deleted.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The node where the value is stored keeps track of which of the workers have a reference to it. Every time a <code>RemoteChannel</code> or a (unfetched) <code>Future</code> is serialized to a worker, the node pointed to by the reference is notified. And every time a <code>RemoteChannel</code> or a (unfetched) <code>Future</code> is garbage collected locally, the node owning the value is again notified.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The notifications are done via sending of &quot;tracking&quot; messages - an &quot;add reference&quot; message when a reference is serialized to a different process and a &quot;delete reference&quot; message when a reference is locally garbage collected.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Since <code>Future</code>s are write-once and cached locally, the act of <code>fetch</code>ing a <code>Future</code> also updates reference tracking information on the node owning the value.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The node which owns the value frees it once all references to it are cleared.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>With <code>Future</code>s, serializing an already fetched <code>Future</code> to a different node also sends the value since the original remote store may have collected the value by this time.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>It is important to note that <em>when</em> an object is locally garbage collected depends on the size of the object and the current memory pressure in the system.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In case of remote references, the size of the local reference object is quite small, while the value stored on the remote node may be quite large. Since the local object may not be collected immediately, it is a good practice to explicitly call <code>finalize</code> on local instances of a <code>RemoteChannel</code>, or on unfetched <code>Future</code>s. Since calling <code>fetch</code> on a <code>Future</code> also removes its reference from the remote store, this is not required on fetched <code>Future</code>s. Explicitly calling <code>finalize</code> results in an immediate message sent to the remote node to go ahead and remove its reference to the value.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Once finalized, a reference becomes invalid and cannot be used in any further calls.</p><a id="Shared-Arrays-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Shared Arrays</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Shared Arrays use system shared memory to map the same array across many processes.  While there are some similarities to a <a href="https://github.com/JuliaParallel/DistributedArrays.jl">DArray</a>, the behavior of a <a href="../stdlib/parallel.html#Base.SharedArray"><code>SharedArray</code></a> is quite different. In a <a href="https://github.com/JuliaParallel/DistributedArrays.jl">DArray</a>, each process has local access to just a chunk of the data, and no two processes share the same chunk; in contrast, in a <a href="../stdlib/parallel.html#Base.SharedArray"><code>SharedArray</code></a> each &quot;participating&quot; process has access to the entire array.  A <a href="../stdlib/parallel.html#Base.SharedArray"><code>SharedArray</code></a> is a good choice when you want to have a large amount of data jointly accessible to two or more processes on the same machine.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p><a href="../stdlib/parallel.html#Base.SharedArray"><code>SharedArray</code></a> indexing (assignment and accessing values) works just as with regular arrays, and is efficient because the underlying memory is available to the local process.  Therefore, most algorithms work naturally on <a href="../stdlib/parallel.html#Base.SharedArray"><code>SharedArray</code></a>s, albeit in single-process mode.  In cases where an algorithm insists on an <a href="../stdlib/arrays.html#Core.Array"><code>Array</code></a> input, the underlying array can be retrieved from a <a href="../stdlib/parallel.html#Base.SharedArray"><code>SharedArray</code></a> by calling <a href="../stdlib/parallel.html#Base.sdata"><code>sdata()</code></a>. For other <code>AbstractArray</code> types, <code>sdata</code> just returns the object itself, so it&#39;s safe to use <a href="../stdlib/parallel.html#Base.sdata"><code>sdata()</code></a> on any Array-type object.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The constructor for a shared array is of the form:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">SharedArray</span><span class="p">(</span><span class="n">T</span><span class="p">:</span><span class="p">:</span><span class="n">Type</span><span class="p">,</span><span> </span><span class="n">dims</span><span class="p">:</span><span class="p">:</span><span class="n">NTuple</span><span class="p">;</span><span> </span><span class="n">init</span><span class="o">=</span><span class="n">false</span><span class="p">,</span><span> </span><span class="n">pids</span><span class="o">=</span><span class="kt">Int</span><span class="p">[</span><span class="p">]</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>which creates a shared array of a bitstype <code>T</code> and size <code>dims</code> across the processes specified by <code>pids</code>.  Unlike distributed arrays, a shared array is accessible only from those participating workers specified by the <code>pids</code> named argument (and the creating process too, if it is on the same host).</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>If an <code>init</code> function, of signature <code>initfn(S::SharedArray)</code>, is specified, it is called on all the participating workers.  You can arrange it so that each worker runs the <code>init</code> function on a distinct portion of the array, thereby parallelizing initialization.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Here&#39;s a brief example:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">addprocs</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span>
</span><span class="go">3-element Array{Int64,1}:
</span><span class="go"> 2
</span><span class="go"> 3
</span><span class="go"> 4
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">S</span><span> </span><span class="o">=</span><span> </span><span class="n">SharedArray</span><span class="p">(</span><span class="kt">Int</span><span class="p">,</span><span> </span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="p">,</span><span> </span><span class="n">init</span><span> </span><span class="o">=</span><span> </span><span class="n">S</span><span> </span><span class="o">-&gt;</span><span> </span><span class="n">S</span><span class="p">[</span><span class="n">Base</span><span class="o">.</span><span class="n">localindexes</span><span class="p">(</span><span class="n">S</span><span class="p">)</span><span class="p">]</span><span> </span><span class="o">=</span><span> </span><span class="n">myid</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="go">3×4 SharedArray{Int64,2}:
</span><span class="go"> 2  2  3  4
</span><span class="go"> 2  3  3  4
</span><span class="go"> 2  3  4  4
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span> </span><span class="o">=</span><span> </span><span class="mi">7</span><span>
</span><span class="go">7
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">S</span><span>
</span><span class="go">3×4 SharedArray{Int64,2}:
</span><span class="go"> 2  2  3  4
</span><span class="go"> 2  3  3  4
</span><span class="go"> 2  7  4  4
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p><a href="../stdlib/parallel.html#Base.localindexes"><code>Base.localindexes()</code></a> provides disjoint one-dimensional ranges of indexes, and is sometimes convenient for splitting up tasks among processes. You can, of course, divide the work any way you wish:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">S</span><span> </span><span class="o">=</span><span> </span><span class="n">SharedArray</span><span class="p">(</span><span class="kt">Int</span><span class="p">,</span><span> </span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="p">,</span><span> </span><span class="n">init</span><span> </span><span class="o">=</span><span> </span><span class="n">S</span><span> </span><span class="o">-&gt;</span><span> </span><span class="n">S</span><span class="p">[</span><span class="n">indexpids</span><span class="p">(</span><span class="n">S</span><span class="p">)</span><span class="p">:</span><span class="n">length</span><span class="p">(</span><span class="n">procs</span><span class="p">(</span><span class="n">S</span><span class="p">)</span><span class="p">)</span><span class="p">:</span><span class="n">length</span><span class="p">(</span><span class="n">S</span><span class="p">)</span><span class="p">]</span><span> </span><span class="o">=</span><span> </span><span class="n">myid</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="go">3×4 SharedArray{Int64,2}:
</span><span class="go"> 2  2  2  2
</span><span class="go"> 3  3  3  3
</span><span class="go"> 4  4  4  4
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Since all processes have access to the underlying data, you do have to be careful not to set up conflicts.  For example:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="p">@</span><span class="n">sync</span><span> </span><span class="k">begin</span><span>
</span><span>    </span><span class="k">for</span><span> </span><span class="n">p</span><span> </span><span class="k">in</span><span> </span><span class="n">procs</span><span class="p">(</span><span class="n">S</span><span class="p">)</span><span>
</span><span>        </span><span class="p">@</span><span class="n">async</span><span> </span><span class="k">begin</span><span>
</span><span>            </span><span class="n">remotecall_wait</span><span class="p">(</span><span class="n">fill!</span><span class="p">,</span><span> </span><span class="n">p</span><span class="p">,</span><span> </span><span class="n">S</span><span class="p">,</span><span> </span><span class="n">p</span><span class="p">)</span><span>
</span><span>        </span><span class="k">end</span><span>
</span><span>    </span><span class="k">end</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>would result in undefined behavior: because each process fills the <em>entire</em> array with its own <code>pid</code>, whichever process is the last to execute (for any particular element of <code>S</code>) will have its <code>pid</code> retained.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>As a more extended and complex example, consider running the following &quot;kernel&quot; in parallel:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span> </span><span class="o">=</span><span> </span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">t</span><span class="p">]</span><span> </span><span class="o">+</span><span> </span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">t</span><span class="p">]</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In this case, if we try to split up the work using a one-dimensional index, we are likely to run into trouble: if <code>q[i,j,t]</code> is near the end of the block assigned to one worker and <code>q[i,j,t+1]</code> is near the beginning of the block assigned to another, it&#39;s very likely that <code>q[i,j,t]</code> will not be ready at the time it&#39;s needed for computing <code>q[i,j,t+1]</code>.  In such cases, one is better off chunking the array manually.  Let&#39;s split along the second dimension:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="c"># This function retuns the (irange,jrange) indexes assigned to this worker</span><span>
</span><span class="p">@</span><span class="n">everywhere</span><span> </span><span class="k">function</span><span class="nf"> </span><span class="nf">myrange</span><span class="p">(</span><span class="n">q</span><span class="p">:</span><span class="p">:</span><span class="n">SharedArray</span><span class="p">)</span><span>
</span><span>    </span><span class="n">idx</span><span> </span><span class="o">=</span><span> </span><span class="n">indexpids</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span>
</span><span>    </span><span class="k">if</span><span> </span><span class="n">idx</span><span> </span><span class="o">==</span><span> </span><span class="mi">0</span><span>
</span><span>        </span><span class="c"># This worker is not assigned a piece</span><span>
</span><span>        </span><span class="k">return</span><span> </span><span class="mi">1</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span> </span><span class="mi">1</span><span class="p">:</span><span class="mi">0</span><span>
</span><span>    </span><span class="k">end</span><span>
</span><span>    </span><span class="n">nchunks</span><span> </span><span class="o">=</span><span> </span><span class="n">length</span><span class="p">(</span><span class="n">procs</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="p">)</span><span>
</span><span>    </span><span class="n">splits</span><span> </span><span class="o">=</span><span> </span><span class="p">[</span><span class="n">round</span><span class="p">(</span><span class="kt">Int</span><span class="p">,</span><span> </span><span class="n">s</span><span class="p">)</span><span> </span><span class="k">for</span><span> </span><span class="n">s</span><span> </span><span class="k">in</span><span> </span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">size</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="p">,</span><span class="n">nchunks</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="p">]</span><span>
</span><span>    </span><span class="mi">1</span><span class="p">:</span><span class="n">size</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="p">,</span><span> </span><span class="n">splits</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">splits</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span>
</span><span class="k">end</span><span>
</span><span>
</span><span class="c"># Here&#39;s the kernel</span><span>
</span><span class="p">@</span><span class="n">everywhere</span><span> </span><span class="k">function</span><span class="nf"> </span><span class="nf">advection_chunk</span><span class="o">!</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span> </span><span class="n">u</span><span class="p">,</span><span> </span><span class="n">irange</span><span class="p">,</span><span> </span><span class="n">jrange</span><span class="p">,</span><span> </span><span class="n">trange</span><span class="p">)</span><span>
</span><span>    </span><span class="p">@</span><span class="n">show</span><span> </span><span class="p">(</span><span class="n">irange</span><span class="p">,</span><span> </span><span class="n">jrange</span><span class="p">,</span><span> </span><span class="n">trange</span><span class="p">)</span><span>  </span><span class="c"># display so we can see what&#39;s happening</span><span>
</span><span>    </span><span class="k">for</span><span> </span><span class="n">t</span><span> </span><span class="k">in</span><span> </span><span class="n">trange</span><span class="p">,</span><span> </span><span class="n">j</span><span> </span><span class="k">in</span><span> </span><span class="n">jrange</span><span class="p">,</span><span> </span><span class="n">i</span><span> </span><span class="k">in</span><span> </span><span class="n">irange</span><span>
</span><span>        </span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span> </span><span class="o">=</span><span> </span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">t</span><span class="p">]</span><span> </span><span class="o">+</span><span>  </span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">t</span><span class="p">]</span><span>
</span><span>    </span><span class="k">end</span><span>
</span><span>    </span><span class="n">q</span><span>
</span><span class="k">end</span><span>
</span><span>
</span><span class="c"># Here&#39;s a convenience wrapper for a SharedArray implementation</span><span>
</span><span class="p">@</span><span class="n">everywhere</span><span> </span><span class="n">advection_shared_chunk!</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span> </span><span class="n">u</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">advection_chunk!</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span> </span><span class="n">u</span><span class="p">,</span><span> </span><span class="n">myrange</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="p">,</span><span> </span><span class="mi">1</span><span class="p">:</span><span class="n">size</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Now let&#39;s compare three different versions, one that runs in a single process:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">advection_serial!</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span> </span><span class="n">u</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">advection_chunk!</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span> </span><span class="n">u</span><span class="p">,</span><span> </span><span class="mi">1</span><span class="p">:</span><span class="n">size</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="p">,</span><span> </span><span class="mi">1</span><span class="p">:</span><span class="n">size</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="p">,</span><span> </span><span class="mi">1</span><span class="p">:</span><span class="n">size</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>one that uses <code>@parallel</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">function</span><span class="nf"> </span><span class="nf">advection_parallel</span><span class="o">!</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span> </span><span class="n">u</span><span class="p">)</span><span>
</span><span>    </span><span class="k">for</span><span> </span><span class="n">t</span><span> </span><span class="o">=</span><span> </span><span class="mi">1</span><span class="p">:</span><span class="n">size</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span>
</span><span>        </span><span class="p">@</span><span class="n">sync</span><span> </span><span class="p">@</span><span class="n">parallel</span><span> </span><span class="k">for</span><span> </span><span class="n">j</span><span> </span><span class="o">=</span><span> </span><span class="mi">1</span><span class="p">:</span><span class="n">size</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span>
</span><span>            </span><span class="k">for</span><span> </span><span class="n">i</span><span> </span><span class="o">=</span><span> </span><span class="mi">1</span><span class="p">:</span><span class="n">size</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span>
</span><span>                </span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span> </span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">t</span><span class="p">]</span><span> </span><span class="o">+</span><span> </span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">t</span><span class="p">]</span><span>
</span><span>            </span><span class="k">end</span><span>
</span><span>        </span><span class="k">end</span><span>
</span><span>    </span><span class="k">end</span><span>
</span><span>    </span><span class="n">q</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>and one that delegates in chunks:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">function</span><span class="nf"> </span><span class="nf">advection_shared</span><span class="o">!</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span> </span><span class="n">u</span><span class="p">)</span><span>
</span><span>    </span><span class="p">@</span><span class="n">sync</span><span> </span><span class="k">begin</span><span>
</span><span>        </span><span class="k">for</span><span> </span><span class="n">p</span><span> </span><span class="k">in</span><span> </span><span class="n">procs</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span>
</span><span>            </span><span class="p">@</span><span class="n">async</span><span> </span><span class="n">remotecall_wait</span><span class="p">(</span><span class="n">advection_shared_chunk!</span><span class="p">,</span><span> </span><span class="n">p</span><span class="p">,</span><span> </span><span class="n">q</span><span class="p">,</span><span> </span><span class="n">u</span><span class="p">)</span><span>
</span><span>        </span><span class="k">end</span><span>
</span><span>    </span><span class="k">end</span><span>
</span><span>    </span><span class="n">q</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>If we create SharedArrays and time these functions, we get the following results (with <code>julia -p 4</code>):</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span class="go">q = SharedArray(Float64, (500,500,500))
</span><span class="go">u = SharedArray(Float64, (500,500,500))
</span><span class="go">
</span><span class="go"># Run once to JIT-compile
</span><span class="go">advection_serial!(q, u)
</span><span class="go">advection_parallel!(q, u)
</span><span class="go">advection_shared!(q,u)
</span><span class="go">
</span><span class="go"># Now the real results:
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="p">@</span><span class="n">time</span><span> </span><span class="n">advection_serial!</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span> </span><span class="n">u</span><span class="p">)</span><span class="p">;</span><span>
</span><span class="go">(irange,jrange,trange) = (1:500,1:500,1:499)
</span><span class="go"> 830.220 milliseconds (216 allocations: 13820 bytes)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="p">@</span><span class="n">time</span><span> </span><span class="n">advection_parallel!</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span> </span><span class="n">u</span><span class="p">)</span><span class="p">;</span><span>
</span><span class="go">   2.495 seconds      (3999 k allocations: 289 MB, 2.09% gc time)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="p">@</span><span class="n">time</span><span> </span><span class="n">advection_shared!</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">u</span><span class="p">)</span><span class="p">;</span><span>
</span><span class="gt">
        From worker 2:       (irange,jrange,trange) = (1:500,1:125,1:499)
</span><span></span><span class="gt">
        From worker 4:       (irange,jrange,trange) = (1:500,251:375,1:499)
</span><span></span><span class="gt">
        From worker 3:       (irange,jrange,trange) = (1:500,126:250,1:499)
</span><span></span><span class="gt">
        From worker 5:       (irange,jrange,trange) = (1:500,376:500,1:499)
</span><span></span><span class="go"> 238.119 milliseconds (2264 allocations: 169 KB)
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The biggest advantage of <code>advection_shared!</code> is that it minimizes traffic among the workers, allowing each to compute for an extended time on the assigned piece.</p><a id="Shared-Arrays-and-Distributed-Garbage-Collection-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Shared Arrays and Distributed Garbage Collection</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Like remote references, shared arrays are also dependent on garbage collection on the creating node to release references from all participating workers. Code which creates many short lived shared array objects would benefit from explicitly finalizing these objects as soon as possible. This results in both memory and file handles mapping the shared segment being released sooner.</p><a id="ClusterManagers-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>ClusterManagers</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The launching, management and networking of Julia processes into a logical cluster is done via cluster managers. A <code>ClusterManager</code> is responsible for</p><div class="mdnote debug">Base.Markdown.List</div><ul><li><p>launching worker processes in a cluster environment</p></li><li><p>managing events during the lifetime of each worker</p></li><li><p>optionally, a cluster manager can also provide data transport</p></li></ul><div class="mdnote debug">Base.Markdown.Paragraph</div><p>A Julia cluster has the following characteristics: - The initial Julia process, also called the <code>master</code> is special and has a id of 1. - Only the <code>master</code> process can add or remove worker processes. - All processes can directly communicate with each other.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Connections between workers (using the in-built TCP/IP transport) is established in the following manner:</p><div class="mdnote debug">Base.Markdown.List</div><ul><li><p><a href="../stdlib/parallel.html#Base.addprocs"><code>addprocs()</code></a> is called on the master process with a <code>ClusterManager</code> object</p></li><li><p><a href="../stdlib/parallel.html#Base.addprocs"><code>addprocs()</code></a> calls the appropriate <a href="../stdlib/parallel.html#Base.launch"><code>launch()</code></a> method which spawns required number of worker processes on appropriate machines</p></li><li><p>Each worker starts listening on a free port and writes out its host, port information to <a href="../stdlib/io-network.html#Base.STDOUT"><code>STDOUT</code></a></p></li><li><p>The cluster manager captures the stdout&#39;s of each worker and makes it available to the master process</p></li><li><p>The master process parses this information and sets up TCP/IP connections to each worker</p></li><li><p>Every worker is also notified of other workers in the cluster</p></li><li><p>Each worker connects to all workers whose id is less than its own id</p></li><li><p>In this way a mesh network is established, wherein every worker is directly connected with every other worker</p></li></ul><div class="mdnote debug">Base.Markdown.Paragraph</div><p>While the default transport layer uses plain TCP sockets, it is possible for a Julia cluster to provide its own transport.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Julia provides two in-built cluster managers:</p><div class="mdnote debug">Base.Markdown.List</div><ul><li><p><code>LocalManager</code>, used when <a href="../stdlib/parallel.html#Base.addprocs"><code>addprocs()</code></a> or <a href="../stdlib/parallel.html#Base.addprocs"><code>addprocs(np::Integer)</code></a> are called</p></li><li><p><code>SSHManager</code>, used when <a href="../stdlib/parallel.html#Base.addprocs"><code>addprocs(hostnames::Array)</code></a> is called with a list of hostnames</p></li></ul><div class="mdnote debug">Base.Markdown.Paragraph</div><p><code>LocalManager</code> is used to launch additional workers on the same host, thereby leveraging multi-core and multi-processor hardware.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Thus, a minimal cluster manager would need to:</p><div class="mdnote debug">Base.Markdown.List</div><ul><li><p>be a subtype of the abstract <code>ClusterManager</code></p></li><li><p>implement <a href="../stdlib/parallel.html#Base.launch"><code>launch()</code></a>, a method responsible for launching new workers</p></li><li><p>implement <a href="../stdlib/parallel.html#Base.manage"><code>manage()</code></a>, which is called at various events during a worker&#39;s lifetime</p></li></ul><div class="mdnote debug">Base.Markdown.Paragraph</div><p><a href="@ref"><code>addprocs(manager::FooManager)</code></a> requires <code>FooManager</code> to implement:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">function launch(manager::FooManager, params::Dict, launched::Array, c::Condition)
    ...
end

function manage(manager::FooManager, id::Integer, config::WorkerConfig, op::Symbol)
    ...
end</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>As an example let us see how the <code>LocalManager</code>, the manager responsible for starting workers on the same host, is implemented:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">immutable LocalManager &lt;: ClusterManager
    np::Integer
end

function launch(manager::LocalManager, params::Dict, launched::Array, c::Condition)
    ...
end

function manage(manager::LocalManager, id::Integer, config::WorkerConfig, op::Symbol)
    ...
end</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The <a href="../stdlib/parallel.html#Base.launch"><code>launch()</code></a> method takes the following arguments:</p><div class="mdnote debug">Base.Markdown.List</div><ul><li><p><code>manager::ClusterManager</code> - the cluster manager <a href="../stdlib/parallel.html#Base.addprocs"><code>addprocs()</code></a> is called with</p></li><li><p><code>params::Dict</code> - all the keyword arguments passed to <a href="../stdlib/parallel.html#Base.addprocs"><code>addprocs()</code></a></p></li><li><p><code>launched::Array</code> - the array to append one or more <code>WorkerConfig</code> objects to</p></li><li><p><code>c::Condition</code> - the condition variable to be notified as and when workers are launched</p></li></ul><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The <a href="../stdlib/parallel.html#Base.launch"><code>launch()</code></a> method is called asynchronously in a separate task. The termination of this task signals that all requested workers have been launched. Hence the <a href="../stdlib/parallel.html#Base.launch"><code>launch()</code></a> function MUST exit as soon as all the requested workers have been launched.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Newly launched workers are connected to each other, and the master process, in a all-to-all manner. Specifying command argument, <code>--worker &lt;cookie&gt;</code> results in the launched processes initializing themselves as workers and connections being setup via TCP/IP sockets. Optionally <code>--bind-to bind_addr[:port]</code> may also be specified to enable other workers to connect to it at the specified <code>bind_addr</code> and <code>port</code>. This is useful for multi-homed hosts.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>For non-TCP/IP transports, for example, an implementation may choose to use MPI as the transport, <code>--worker</code> must NOT be specified. Instead newly launched workers should call <code>init_worker(cookie)</code> before using any of the parallel constructs.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>For every worker launched, the <a href="../stdlib/parallel.html#Base.launch"><code>launch()</code></a> method must add a <code>WorkerConfig</code> object (with appropriate fields initialized) to <code>launched</code></p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">type WorkerConfig
    # Common fields relevant to all cluster managers
    io::Nullable{IO}
    host::Nullable{AbstractString}
    port::Nullable{Integer}

    # Used when launching additional workers at a host
    count::Nullable{Union{Int, Symbol}}
    exename::Nullable{AbstractString}
    exeflags::Nullable{Cmd}

    # External cluster managers can use this to store information at a per-worker level
    # Can be a dict if multiple fields need to be stored.
    userdata::Nullable{Any}

    # SSHManager / SSH tunnel connections to workers
    tunnel::Nullable{Bool}
    bind_addr::Nullable{AbstractString}
    sshflags::Nullable{Cmd}
    max_parallel::Nullable{Integer}

    connect_at::Nullable{Any}

    .....
end</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Most of the fields in <code>WorkerConfig</code> are used by the inbuilt managers. Custom cluster managers would typically specify only <code>io</code> or <code>host</code> / <code>port</code>:</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>If <code>io</code> is specified, it is used to read host/port information. A Julia worker prints out its bind address and port at startup. This allows Julia workers to listen on any free port available instead of requiring worker ports to be configured manually.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>If <code>io</code> is not specified, <code>host</code> and <code>port</code> are used to connect.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p><code>count</code>, <code>exename</code> and <code>exeflags</code> are relevant for launching additional workers from a worker. For example, a cluster manager may launch a single worker per node, and use that to launch additional workers. <code>count</code> with an integer value <code>n</code> will launch a total of <code>n</code> workers, while a value of <code>:auto</code> will launch as many workers as cores on that machine. <code>exename</code> is the name of the <code>julia</code> executable including the full path. <code>exeflags</code> should be set to the required command line arguments for new workers.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p><code>tunnel</code>, <code>bind_addr</code>, <code>sshflags</code> and <code>max_parallel</code> are used when a ssh tunnel is required to connect to the workers from the master process.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p><code>userdata</code> is provided for custom cluster managers to store their own worker specific information.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p><code>manage(manager::FooManager, id::Integer, config::WorkerConfig, op::Symbol)</code> is called at different times during the worker&#39;s lifetime with appropriate <code>op</code> values:</p><div class="mdnote debug">Base.Markdown.List</div><ul><li><p>with <code>:register</code>/<code>:deregister</code> when a worker is added / removed from the Julia worker pool.</p></li><li><p>with <code>:interrupt</code> when <code>interrupt(workers)</code> is called. The <code>ClusterManager</code> should signal the appropriate worker with an interrupt signal.</p></li><li><p>with <code>:finalize</code> for cleanup purposes.</p></li></ul><a id="Cluster-Managers-with-custom-transports-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Cluster Managers with custom transports</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Replacing the default TCP/IP all-to-all socket connections with a custom transport layer is a little more involved. Each Julia process has as many communication tasks as the workers it is connected to. For example, consider a Julia cluster of 32 processes in a all-to-all mesh network:</p><div class="mdnote debug">Base.Markdown.List</div><ul><li><p>Each Julia process thus has 31 communication tasks</p></li><li><p>Each task handles all incoming messages from a single remote worker in a message processing loop</p></li><li><p>The message processing loop waits on an <code>AsyncStream</code> object - for example, a TCP socket in the default implementation, reads an entire message, processes it and waits for the next one</p></li><li><p>Sending messages to a process is done directly from any Julia task - not just communication tasks - again, via the appropriate <code>AsyncStream</code> object</p></li></ul><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Replacing the default transport involves the new implementation to setup connections to remote workers, and to provide appropriate <code>AsyncStream</code> objects that the message processing loops can wait on. The manager specific callbacks to be implemented are:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">connect</span><span class="p">(</span><span class="n">manager</span><span class="p">:</span><span class="p">:</span><span class="n">FooManager</span><span class="p">,</span><span> </span><span class="n">pid</span><span class="p">:</span><span class="p">:</span><span class="n">Integer</span><span class="p">,</span><span> </span><span class="n">config</span><span class="p">:</span><span class="p">:</span><span class="n">WorkerConfig</span><span class="p">)</span><span>
</span><span class="n">kill</span><span class="p">(</span><span class="n">manager</span><span class="p">:</span><span class="p">:</span><span class="n">FooManager</span><span class="p">,</span><span> </span><span class="n">pid</span><span class="p">:</span><span class="p">:</span><span class="kt">Int</span><span class="p">,</span><span> </span><span class="n">config</span><span class="p">:</span><span class="p">:</span><span class="n">WorkerConfig</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The default implementation (which uses TCP/IP sockets) is implemented as <code>connect(manager::ClusterManager, pid::Integer, config::WorkerConfig)</code>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p><code>connect</code> should return a pair of <code>AsyncStream</code> objects, one for reading data sent from worker <code>pid</code>, and the other to write data that needs to be sent to worker <code>pid</code>. Custom cluster managers can use an in-memory <code>BufferStream</code> as the plumbing to proxy data between the custom, possibly non-AsyncStream transport and Julia&#39;s in-built parallel infrastructure.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>A <code>BufferStream</code> is an in-memory <code>IOBuffer</code> which behaves like an <code>AsyncStream</code>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Folder <code>examples/clustermanager/0mq</code> is an example of using ZeroMQ is connect Julia workers in a star network with a 0MQ broker in the middle. Note: The Julia processes are still all <em>logically</em> connected to each other - any worker can message any other worker directly without any awareness of 0MQ being used as the transport layer.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>When using custom transports:</p><div class="mdnote debug">Base.Markdown.List</div><ul><li><p>Julia workers must NOT be started with <code>--worker</code>. Starting with <code>--worker</code> will result in the newly launched workers defaulting to the TCP/IP socket transport implementation</p></li><li><p>For every incoming logical connection with a worker, <code>Base.process_messages(rd::AsyncStream, wr::AsyncStream)</code> must be called. This launches a new task that handles reading and writing of messages from/to the worker represented by the <code>AsyncStream</code> objects</p></li><li><p><code>init_worker(cookie, manager::FooManager)</code> MUST be called as part of worker process initializaton</p></li><li><p>Field <code>connect_at::Any</code> in <code>WorkerConfig</code> can be set by the cluster manager when <code>launch</code> is called. The value of this field is passed in in all <code>connect</code> callbacks. Typically, it carries information on <em>how to connect</em> to a worker. For example, the TCP/IP socket transport uses this field to specify the <code>(host, port)</code> tuple at which to connect to a worker</p></li></ul><div class="mdnote debug">Base.Markdown.Paragraph</div><p><code>kill(manager, pid, config)</code> is called to remove a worker from the cluster. On the master process, the corresponding <code>AsyncStream</code> objects must be closed by the implementation to ensure proper cleanup. The default implementation simply executes an <code>exit()</code> call on the specified remote worker.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p><code>examples/clustermanager/simple</code> is an example that shows a simple implementation using unix domain sockets for cluster setup</p><a id="Network-requirements-for-LocalManager-and-SSHManager-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Network requirements for LocalManager and SSHManager</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Julia clusters are designed to be executed on already secured environments on infrastructure ranging from local laptops, to departmental clusters or even on the cloud. This section covers network security requirements for the inbuilt <code>LocalManager</code> and <code>SSHManager</code>:</p><div class="mdnote debug">Base.Markdown.List</div><ul><li><p>The master process does not listen on any port. It only connects out to the workers.</p></li><li><p>Each worker binds to only one of the local interfaces and listens on the first free port starting from 9009.</p></li><li><p><code>LocalManager</code>, i.e. <code>addprocs(N)</code>, by default binds only to the loopback interface. This means that workers consequently started on remote hosts, or anyone with malicious intentions is unable to connect to the cluster. A <code>addprocs(4)</code> followed by a <code>addprocs([&quot;remote_host&quot;])</code> will fail. Some users may need to create a cluster comprised of their local system and a few remote systems. This can be done by explicitly requesting <code>LocalManager</code> to bind to an external network interface via the <code>restrict</code> keyword argument. For example, <code>addprocs(4; restrict=false)</code>.</p></li><li><p><code>SSHManager</code>, i.e. <code>addprocs(list_of_remote_hosts)</code> launches workers on remote hosts via SSH. It is to be noted that by default SSH is only used to launch Julia workers. Subsequent master-worker and worker-worker connections use plain, unencrypted TCP/IP sockets. The remote hosts must have passwordless login enabled. Additional SSH flags or credentials may be specified via keyword argument <code>sshflags</code>.</p></li><li><p><code>addprocs(list_of_remote_hosts; tunnel=true, sshflags=&lt;ssh keys and other flags&gt;)</code> is useful when we wish to use SSH connections for master-worker too. A typical scenario for this is a local laptop running the Julia REPL (i.e., the master) with the rest of the cluster on the cloud, say on Amazon EC2. In this case only port 22 needs to be opened at the remote cluster coupled with SSH client authenticated via PKI. Authentication credentials can be supplied via <code>sshflags</code>, for example <code>sshflags=`-e &lt;keyfile&gt;`</code>.</p><p>Note that worker-worker connections are still plain TCP and the local security policy on the remote cluster must allow for free connections between worker nodes, at least for ports 9009 and above.</p><p>Securing and encrypting all worker-worker traffic (via SSH), or encrypting individual messages can be done via a custom ClusterManager.</p></li></ul><a id="Cluster-cookie-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Cluster cookie</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>All processes in a cluster share the same cookie which, by default, is a randomly generated string on the master process:</p><div class="mdnote debug">Base.Markdown.List</div><ul><li><p><code>Base.cluster_cookie()</code> returns the cookie, <code>Base.cluster_cookie(cookie)</code> sets it.</p></li><li><p>All connections are authenticated on both sides to ensure that only workers started by the master are allowed to connect to each other.</p></li><li><p>The cookie must be passed to the workers at startup via argument <code>--worker &lt;cookie&gt;</code>. Custom ClusterManagers can retrieve the cookie on the master by calling <code>Base.cluster_cookie()</code>. Cluster managers not using the default TCP/IP transport (and hence not specifying <code>--worker</code>) must call <code>init_worker(cookie, manager)</code> with the same cookie as on the master.</p></li></ul><div class="mdnote debug">Base.Markdown.Paragraph</div><p>It is to be noted that environments requiring higher levels of security (for example, cookies can be pre-shared and hence not specified as a startup arg) can implement this via a custom ClusterManager.</p><a id="Specifying-network-topology-(Experimental)-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Specifying network topology (Experimental)</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Keyword argument <code>topology</code> to <code>addprocs</code> is used to specify how the workers must be connected to each other:</p><div class="mdnote debug">Base.Markdown.List</div><ul><li><p><code>:all_to_all</code> : is the default, where all workers are connected to each other.</p></li><li><p><code>:master_slave</code> : only the driver process, i.e. pid 1 has connections to the workers.</p></li><li><p><code>:custom</code> : the <code>launch</code> method of the cluster manager specifes the connection topology. Fields <code>ident</code> and <code>connect_idents</code> in <code>WorkerConfig</code> are used to specify the  same. <code>connect_idents</code> is a list of <code>ClusterManager</code> provided identifiers to workers that worker with identified by <code>ident</code> must connect to.</p></li></ul><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Currently sending a message between unconnected workers results in an error. This behaviour, as also the functionality and interface should be considered experimental in nature and may change in future releases.</p><a id="Multi-threading-(Experimental)-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Multi-threading (Experimental)</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In addition to tasks, remote calls and remote references, Julia from v0.5 will natively support multi-threading. Note that this section is experimental and the interfaces may change in the future.</p><a id="Setup-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>Setup</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>By default, Julia starts up with a single thread of execution. This can be verified by using the command <a href="../stdlib/parallel.html#Base.Threads.nthreads"><code>Threads.nthreads()</code></a>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Threads</span><span class="o">.</span><span class="n">nthreads</span><span class="p">(</span><span class="p">)</span><span>
</span><span class="go">1
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The number of threads Julia starts up with is controlled by an environment variable called <code>JULIA_NUM_THREADS</code>. Now, let&#39;s start up Julia with 4 threads:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">export</span><span> </span><span class="n">JULIA_NUM_THREADS</span><span class="o">=</span><span class="mi">4</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>(The above command works on bourne shells on Linux and OSX. Note that if you&#39;re using a C shell on these platforms, you should use the keyword <code>set</code> instead of <code>export</code>. If you&#39;re on Windows, start up the command line in the location of <code>julia.exe</code> and use <code>set</code> instead of <code>export</code>.)</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Let&#39;s verify there are 4 threads at our disposal.</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Threads</span><span class="o">.</span><span class="n">nthreads</span><span class="p">(</span><span class="p">)</span><span>
</span><span class="go">4
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>But we are currently on the master thread. To check, we use the command <a href="../stdlib/parallel.html#Base.Threads.threadid"><code>Threads.threadid()</code></a></p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Threads</span><span class="o">.</span><span class="n">threadid</span><span class="p">(</span><span class="p">)</span><span>
</span><span class="go">1
</span></code></pre><a id="The-@threads-Macro-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>The <code>@threads</code> Macro</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Let&#39;s work a simple example using our native threads. Let us create an array of zeros:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">a</span><span> </span><span class="o">=</span><span> </span><span class="n">zeros</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span>
</span><span class="go">10-element Array{Float64,1}:
</span><span class="go"> 0.0
</span><span class="go"> 0.0
</span><span class="go"> 0.0
</span><span class="go"> 0.0
</span><span class="go"> 0.0
</span><span class="go"> 0.0
</span><span class="go"> 0.0
</span><span class="go"> 0.0
</span><span class="go"> 0.0
</span><span class="go"> 0.0
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Let us operate on this array simultaneously using 4 threads. We&#39;ll have each thread write its thread ID into each location.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Julia supports parallel loops using the <a href="../stdlib/parallel.html#Base.Threads.@threads"><code>Threads.@threads</code></a> macro. This macro is affixed in front of a <code>for</code> loop to indicate to Julia that the loop is a multi-threaded region.</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">Threads</span><span class="o">.</span><span class="p">@</span><span class="n">threads</span><span> </span><span class="k">for</span><span> </span><span class="n">i</span><span> </span><span class="o">=</span><span> </span><span class="mi">1</span><span class="p">:</span><span class="mi">10</span><span>
</span><span>    </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span> </span><span class="o">=</span><span> </span><span class="n">threadid</span><span class="p">(</span><span class="p">)</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The iteration space is split amongst the threads, after which each thread writes its thread ID to its assigned locations.:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">a</span><span>
</span><span class="go">10-element Array{Float64,1}:
</span><span class="go"> 1.0
</span><span class="go"> 1.0
</span><span class="go"> 1.0
</span><span class="go"> 2.0
</span><span class="go"> 2.0
</span><span class="go"> 2.0
</span><span class="go"> 3.0
</span><span class="go"> 3.0
</span><span class="go"> 4.0
</span><span class="go"> 4.0
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Note that <a href="../stdlib/parallel.html#Base.Threads.@threads"><code>Threads.@threads</code></a> does not have an optional reduction parameter like <a href="../stdlib/parallel.html#Base.@parallel"><code>@parallel</code></a>.</p><div class="mdnote debug">Base.Markdown.Admonition</div><div class="admonition footnote"><div class="admonition-title">[1]</div><div class="admonition-text"><p>In this context, MPI refers to the MPI-1 standard. Beginning with MPI-2, the MPI standards committee introduced a new set of communication mechanisms, collectively referred to as Remote Memory Access (RMA). The motivation for adding RMA to the MPI standard was to facilitate one-sided communication patterns. For additional information on the latest MPI standard, see <a href="http://www.mpi-forum.org/docs">http://www.mpi-forum.org/docs</a>.</p></div></div><footer><hr/><a class="previous" href="packages.html"><span class="direction">Previous</span><span class="title">Packages</span></a><a class="next" href="performance-tips.html"><span class="direction">Next</span><span class="title">Performance Tips</span></a></footer></article></body></html>
