<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Documenter.jl</title><link href="../normalize.css" rel="stylesheet" type="text/css"/><link href="../style.css" rel="stylesheet" type="text/css"/><link href="../highlight.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="../require.js" data-main="../documenter.js"></script><script src="../search-index.js"></script></head><body><nav class="toc"><a href="http://julialang.org/"><img class="logo" src="http://docs.julialang.org/en/release-0.4/_static/julia-logo.svg" alt="\$pkgname.jl logo"/></a><h1>$pkgname.jl</h1><input type="text" placeholder="Search docs"/><ul><li><a class="toctext" href="../index.html">Overview</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../man/guide.html">Guide</a></li><li><a class="toctext" href="../man/examples.html">Examples</a></li><li><a class="toctext" href="../man/syntax.html">Syntax</a></li><li><a class="toctext" href="../man/doctests.html">Doctests</a></li><li><a class="toctext" href="../man/hosting.html">Hosting Documentation</a></li><li><a class="toctext" href="../man/latex.html"><span>$\LaTeX$</span> syntax</a></li><li><a class="toctext" href="../man/internals.html">Package Internals</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../lib/public.html">Public Documentation</a></li><li><a class="toctext" href="../lib/internals.html">Internal Documentation</a></li></ul></li><li><span class="toctext">Dynamic pages</span><ul><li><a class="toctext" href="../dynamic/code.html">Code examples</a></li><li><a class="toctext" href="../dynamic/admonitions.html">Admonitions &amp; Co</a></li><li><a class="toctext" href="../dynamic/styles.html">Demonstrating <em>styles</em> of MD elements</a></li><li><a class="toctext" href="../dynamic/bugs.html">Some existing bugs</a></li></ul></li><li><span class="toctext">JuliaDocs - Manual</span><ul><li><a class="toctext" href="arrays.html">Multi-dimensional Arrays</a></li><li><a class="toctext" href="calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="toctext" href="complex-and-rational-numbers.html">Complex and Rational Numbers</a></li><li><a class="toctext" href="constructors.html">Constructors</a></li><li><a class="toctext" href="control-flow.html">Control Flow</a></li><li><a class="toctext" href="conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="toctext" href="dates.html">Date and DateTime</a></li><li><a class="toctext" href="documentation.html">Documentation</a></li><li><a class="toctext" href="embedding.html">Embedding Julia</a></li><li><a class="toctext" href="faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="functions.html">Functions</a></li><li><a class="toctext" href="getting-started.html">Getting Started</a></li><li><a class="toctext" href="handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="index.html">The Julia Manual</a></li><li class="current"><a class="toctext" href="integers-and-floating-point-numbers.html">Integers and Floating-Point Numbers</a><ul class="internal"><li><a class="toctext" href="#Integers-1">Integers</a></li><li><a class="toctext" href="#Floating-Point-Numbers-1">Floating-Point Numbers</a></li><li><a class="toctext" href="#Arbitrary-Precision-Arithmetic-1">Arbitrary Precision Arithmetic</a></li><li><a class="toctext" href="#Numeric-Literal-Coefficients-1">Numeric Literal Coefficients</a></li><li><a class="toctext" href="#Literal-zero-and-one-1">Literal zero and one</a></li></ul></li><li><a class="toctext" href="interacting-with-julia.html">Interacting With Julia</a></li><li><a class="toctext" href="interfaces.html">Interfaces</a></li><li><a class="toctext" href="introduction.html">Introduction</a></li><li><a class="toctext" href="linear-algebra.html">Linear algebra</a></li><li><a class="toctext" href="mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="metaprogramming.html">Metaprogramming</a></li><li><a class="toctext" href="methods.html">Methods</a></li><li><a class="toctext" href="modules.html">Modules</a></li><li><a class="toctext" href="networking-and-streams.html">Networking and Streams</a></li><li><a class="toctext" href="noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="packages.html">Packages</a></li><li><a class="toctext" href="parallel-computing.html">Parallel Computing</a></li><li><a class="toctext" href="performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="profile.html">Profiling</a></li><li><a class="toctext" href="running-external-programs.html">Running External Programs</a></li><li><a class="toctext" href="stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="strings.html">Strings</a></li><li><a class="toctext" href="style-guide.html">Style Guide</a></li><li><a class="toctext" href="types.html">Types</a></li><li><a class="toctext" href="unicode-input.html">Unicode Input</a></li><li><a class="toctext" href="variables-and-scoping.html">Scope of Variables</a></li><li><a class="toctext" href="variables.html">Variables</a></li><li><a class="toctext" href="workflow-tips.html">Workflow Tips</a></li></ul></li><li><span class="toctext">JuliaDocs - Standard Libary</span><ul><li><a class="toctext" href="../stdlib/arrays.html">Arrays</a></li><li><a class="toctext" href="../stdlib/base.html">Essentials</a></li><li><a class="toctext" href="../stdlib/c.html">C Interface</a></li><li><a class="toctext" href="../stdlib/collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="../stdlib/constants.html">Constants</a></li><li><a class="toctext" href="../stdlib/dates.html">Dates and Time</a></li><li><a class="toctext" href="../stdlib/file.html">Filesystem</a></li><li><a class="toctext" href="../stdlib/index.html">The Julia Standard Library</a></li><li><a class="toctext" href="../stdlib/io-network.html">I/O and Network</a></li><li><a class="toctext" href="../stdlib/libc.html">C Standard Library</a></li><li><a class="toctext" href="../stdlib/libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="../stdlib/linalg.html">Linear Algebra</a></li><li><a class="toctext" href="../stdlib/math.html">Mathematics</a></li><li><a class="toctext" href="../stdlib/numbers.html">Numbers</a></li><li><a class="toctext" href="../stdlib/parallel.html">Tasks and Parallel Computing</a></li><li><a class="toctext" href="../stdlib/pkg.html">Package Manager Functions</a></li><li><a class="toctext" href="../stdlib/profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/punctuation.html">Punctuation</a></li><li><a class="toctext" href="../stdlib/simd-types.html">SIMD Support</a></li><li><a class="toctext" href="../stdlib/sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="../stdlib/stacktraces.html">StackTraces</a></li><li><a class="toctext" href="../stdlib/strings.html">Strings</a></li><li><a class="toctext" href="../stdlib/test.html">Unit Testing</a></li></ul></li><li><span class="toctext">JuliaDocs - DevDocs</span><ul><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/C.html">Developing/debugging Julia&#39;s C code</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../devdocs/julia.html">Documentation of Julia&#39;s Internals</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/promote-op.html">Operator-sensitive promotion</a></li><li><a class="toctext" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/types.html">More about types</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>JuliaDocs - Manual</li><li><a href="integers-and-floating-point-numbers.html">Integers and Floating-Point Numbers</a></li></ul><a class="edit-page" href="https://github.com/"><span class="fa">ï‚›</span> Edit on GitHub</a></nav><hr/></header><a id="Integers-and-Floating-Point-Numbers-1"></a><div class="mdnote debug">Base.Markdown.Header{1}</div><h1>Integers and Floating-Point Numbers</h1><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Integers and floating-point values are the basic building blocks of arithmetic and computation. Built-in representations of such values are called numeric primitives, while representations of integers and floating-point numbers as immediate values in code are known as numeric literals. For example, <code>1</code> is an integer literal, while <code>1.0</code> is a floating-point literal; their binary in-memory representations as objects are numeric primitives.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Julia provides a broad range of primitive numeric types, and a full complement of arithmetic and bitwise operators as well as standard mathematical functions are defined over them. These map directly onto numeric types and operations that are natively supported on modern computers, thus allowing Julia to take full advantage of computational resources. Additionally, Julia provides software support for <a href="integers-and-floating-point-numbers.html#Arbitrary-Precision-Arithmetic-1">Arbitrary Precision Arithmetic</a>, which can handle operations on numeric values that cannot be represented effectively in native hardware representations, but at the cost of relatively slower performance.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The following are Julia&#39;s primitive numeric types:</p><div class="mdnote debug">Base.Markdown.List</div><ul><li><p><strong>Integer types:</strong></p></li></ul><div class="mdnote debug">Base.Markdown.Table</div><table><tr><th>Type</th><th>Signed?</th><th>Number of bits</th><th>Smallest value</th><th>Largest value</th></tr><tr><td><code>Int8</code></td><td>âœ“</td><td>8</td><td>-2^7</td><td>2^7 - 1</td></tr><tr><td><code>UInt8</code></td><td>Â </td><td>8</td><td>0</td><td>2^8 - 1</td></tr><tr><td><code>Int16</code></td><td>âœ“</td><td>16</td><td>-2^15</td><td>2^15 - 1</td></tr><tr><td><code>UInt16</code></td><td>Â </td><td>16</td><td>0</td><td>2^16 - 1</td></tr><tr><td><code>Int32</code></td><td>âœ“</td><td>32</td><td>-2^31</td><td>2^31 - 1</td></tr><tr><td><code>UInt32</code></td><td>Â </td><td>32</td><td>0</td><td>2^32 - 1</td></tr><tr><td><code>Int64</code></td><td>âœ“</td><td>64</td><td>-2^63</td><td>2^63 - 1</td></tr><tr><td><code>UInt64</code></td><td>Â </td><td>64</td><td>0</td><td>2^64 - 1</td></tr><tr><td><code>Int128</code></td><td>âœ“</td><td>128</td><td>-2^127</td><td>2^127 - 1</td></tr><tr><td><code>UInt128</code></td><td>Â </td><td>128</td><td>0</td><td>2^128 - 1</td></tr><tr><td><code>Bool</code></td><td>N/A</td><td>8</td><td><code>false</code> (0)</td><td><code>true</code> (1)</td></tr></table><div class="mdnote debug">Base.Markdown.List</div><ul><li><p><strong>Floating-point types:</strong></p></li></ul><div class="mdnote debug">Base.Markdown.Table</div><table><tr><th>Type</th><th>Precision</th><th>Number of bits</th></tr><tr><td><code>Float16</code></td><td><a href="https://en.wikipedia.org/wiki/Half-precision_floating-point_format">half</a></td><td>16</td></tr><tr><td><a href="../stdlib/numbers.html#Core.Float32"><code>Float32</code></a></td><td><a href="https://en.wikipedia.org/wiki/Single_precision_floating-point_format">single</a></td><td>32</td></tr><tr><td><a href="../stdlib/numbers.html#Core.Float64"><code>Float64</code></a></td><td><a href="https://en.wikipedia.org/wiki/Double_precision_floating-point_format">double</a></td><td>64</td></tr></table><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Additionally, full support for <a href="complex-and-rational-numbers.html#Complex-and-Rational-Numbers-1">Complex and Rational Numbers</a> is built on top of these primitive numeric types. All numeric types interoperate naturally without explicit casting, thanks to a flexible, user-extensible <a href="@ref">type promotion system</a>.</p><a id="Integers-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Integers</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Literal integers are represented in the standard manner:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="mi">1</span><span>
</span><span class="go">1
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="mi">1234</span><span>
</span><span class="go">1234
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The default type for an integer literal depends on whether the target system has a 32-bit architecture or a 64-bit architecture:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span class="go"># 32-bit system:
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span>
</span><span class="go">Int32
</span><span class="go">
</span><span class="go"># 64-bit system:
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span>
</span><span class="go">Int64
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The Julia internal variable <a href="../stdlib/constants.html#Base.Sys.WORD_SIZE"><code>Sys.WORD_SIZE</code></a> indicates whether the target system is 32-bit or 64-bit.:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span class="go"># 32-bit system:
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Sys</span><span class="o">.</span><span class="n">WORD_SIZE</span><span>
</span><span class="go">32
</span><span class="go">
</span><span class="go"># 64-bit system:
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Sys</span><span class="o">.</span><span class="n">WORD_SIZE</span><span>
</span><span class="go">64
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Julia also defines the types <code>Int</code> and <code>UInt</code>, which are aliases for the system&#39;s signed and unsigned native integer types respectively.:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span class="go"># 32-bit system:
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="kt">Int</span><span>
</span><span class="go">Int32
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">UInt</span><span>
</span><span class="go">UInt32
</span><span class="go">
</span><span class="go">
</span><span class="go"># 64-bit system:
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="kt">Int</span><span>
</span><span class="go">Int64
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">UInt</span><span>
</span><span class="go">UInt64
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Larger integer literals that cannot be represented using only 32 bits but can be represented in 64 bits always create 64-bit integers, regardless of the system type:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span class="go"># 32-bit or 64-bit system:
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="mi">3000000000</span><span class="p">)</span><span>
</span><span class="go">Int64
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Unsigned integers are input and output using the <code>0x</code> prefix and hexadecimal (base 16) digits <code>0-9a-f</code> (the capitalized digits <code>A-F</code> also work for input). The size of the unsigned value is determined by the number of hex digits used:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="mh">0x1</span><span>
</span><span class="go">0x01
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span><span>
</span><span class="go">UInt8
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="mh">0x123</span><span>
</span><span class="go">0x0123
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span><span>
</span><span class="go">UInt16
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="mh">0x1234567</span><span>
</span><span class="go">0x01234567
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span><span>
</span><span class="go">UInt32
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="mh">0x123456789abcdef</span><span>
</span><span class="go">0x0123456789abcdef
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span><span>
</span><span class="go">UInt64
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This behavior is based on the observation that when one uses unsigned hex literals for integer values, one typically is using them to represent a fixed numeric byte sequence, rather than just an integer value.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Recall that the variable <a href="../stdlib/base.html#ans"><code>ans</code></a> is set to the value of the last expression evaluated in an interactive session. This does not occur when Julia code is run in other ways.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Binary and octal literals are also supported:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="mb">0b10</span><span>
</span><span class="go">0x02
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span><span>
</span><span class="go">UInt8
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="mo">0o10</span><span>
</span><span class="go">0x08
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span><span>
</span><span class="go">UInt8
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The minimum and maximum representable values of primitive numeric types such as integers are given by the <a href="../stdlib/base.html#Base.typemin"><code>typemin()</code></a> and <a href="../stdlib/base.html#Base.typemax"><code>typemax()</code></a> functions:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="p">(</span><span class="nb">typemin</span><span class="p">(</span><span class="kt">Int32</span><span class="p">)</span><span class="p">,</span><span> </span><span class="nb">typemax</span><span class="p">(</span><span class="kt">Int32</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="go">(-2147483648,2147483647)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="k">for</span><span> </span><span class="n">T</span><span> </span><span class="k">in</span><span> </span><span class="p">[</span><span class="kt">Int8</span><span class="p">,</span><span class="kt">Int16</span><span class="p">,</span><span class="kt">Int32</span><span class="p">,</span><span class="kt">Int64</span><span class="p">,</span><span class="n">Int128</span><span class="p">,</span><span class="n">UInt8</span><span class="p">,</span><span class="n">UInt16</span><span class="p">,</span><span class="n">UInt32</span><span class="p">,</span><span class="n">UInt64</span><span class="p">,</span><span class="n">UInt128</span><span class="p">]</span><span>
</span><span class="gt">
         println(&quot;$(lpad(T,7)): [$(typemin(T)),$(typemax(T))]&quot;)
</span><span></span><span class="gt">
       end
</span><span></span><span class="go">   Int8: [-128,127]
</span><span class="go">  Int16: [-32768,32767]
</span><span class="go">  Int32: [-2147483648,2147483647]
</span><span class="go">  Int64: [-9223372036854775808,9223372036854775807]
</span><span class="go"> Int128: [-170141183460469231731687303715884105728,170141183460469231731687303715884105727]
</span><span class="go">  UInt8: [0,255]
</span><span class="go"> UInt16: [0,65535]
</span><span class="go"> UInt32: [0,4294967295]
</span><span class="go"> UInt64: [0,18446744073709551615]
</span><span class="go">UInt128: [0,340282366920938463463374607431768211455]
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The values returned by <a href="../stdlib/base.html#Base.typemin"><code>typemin()</code></a> and <a href="../stdlib/base.html#Base.typemax"><code>typemax()</code></a> are always of the given argument type. (The above expression uses several features we have yet to introduce, including <a href="@ref">for loops</a>, <a href="@ref">Strings</a>, and <a href="@ref">Interpolation</a>, but should be easy enough to understand for users with some existing programming experience.)</p><a id="Overflow-behavior-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>Overflow behavior</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In Julia, exceeding the maximum representable value of a given type results in a wraparound behavior:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">x</span><span> </span><span class="o">=</span><span> </span><span class="nb">typemax</span><span class="p">(</span><span class="kt">Int64</span><span class="p">)</span><span>
</span><span class="go">9223372036854775807
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">x</span><span> </span><span class="o">+</span><span> </span><span class="mi">1</span><span>
</span><span class="go">-9223372036854775808
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">x</span><span> </span><span class="o">+</span><span> </span><span class="mi">1</span><span> </span><span class="o">==</span><span> </span><span class="nb">typemin</span><span class="p">(</span><span class="kt">Int64</span><span class="p">)</span><span>
</span><span class="go">true
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Thus, arithmetic with Julia integers is actually a form of <a href="https://en.wikipedia.org/wiki/Modular_arithmetic">modular arithmetic</a>. This reflects the characteristics of the underlying arithmetic of integers as implemented on modern computers. In applications where overflow is possible, explicit checking for wraparound produced by overflow is essential; otherwise, the <code>BigInt</code> type in <a href="integers-and-floating-point-numbers.html#Arbitrary-Precision-Arithmetic-1">Arbitrary Precision Arithmetic</a> is recommended instead.</p><a id="Division-errors-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>Division errors</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Integer division (the <code>div</code> function) has two exceptional cases: dividing by zero, and dividing the lowest negative number (<a href="../stdlib/base.html#Base.typemin"><code>typemin()</code></a>) by -1. Both of these cases throw a <a href="../stdlib/base.html#Core.DivideError"><code>DivideError</code></a>. The remainder and modulus functions (<code>rem</code> and <code>mod</code>) throw a <a href="../stdlib/base.html#Core.DivideError"><code>DivideError</code></a> when their second argument is zero.</p><a id="Floating-Point-Numbers-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Floating-Point Numbers</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Literal floating-point numbers are represented in the standard formats:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="mf">1.0</span><span>
</span><span class="go">1.0
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="mf">1.</span><span>
</span><span class="go">1.0
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="mf">0.5</span><span>
</span><span class="go">0.5
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="o">.</span><span class="mi">5</span><span>
</span><span class="go">0.5
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="o">-</span><span class="mf">1.23</span><span>
</span><span class="go">-1.23
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="mf">1e10</span><span>
</span><span class="go">1.0e10
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="mf">2.5e-4</span><span>
</span><span class="go">0.00025
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The above results are all <code>Float64</code> values. Literal <code>Float32</code> values can be entered by writing an <code>f</code> in place of <code>e</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="mf">0.5f0</span><span>
</span><span class="go">0.5f0
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span><span>
</span><span class="go">Float32
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="mf">2.5f-4</span><span>
</span><span class="go">0.00025f0
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Values can be converted to <code>Float32</code> easily:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="kt">Float32</span><span class="p">(</span><span class="o">-</span><span class="mf">1.5</span><span class="p">)</span><span>
</span><span class="go">-1.5f0
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span><span>
</span><span class="go">Float32
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Hexadecimal floating-point literals are also valid, but only as <code>Float64</code> values:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="mh">0x1</span><span class="n">p0</span><span>
</span><span class="go">1.0
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="mh">0x1</span><span class="o">.</span><span class="mi">8</span><span class="n">p3</span><span>
</span><span class="go">12.0
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="mi">0</span><span class="n">x</span><span class="o">.</span><span class="mi">4</span><span class="n">p</span><span class="o">-</span><span class="mi">1</span><span>
</span><span class="go">0.125
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span><span>
</span><span class="go">Float64
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Half-precision floating-point numbers are also supported (<code>Float16</code>), but only as a storage format. In calculations they&#39;ll be converted to <code>Float32</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">sizeof</span><span class="p">(</span><span class="n">Float16</span><span class="p">(</span><span class="mf">4.</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="go">2
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="mi">2</span><span class="o">*</span><span class="n">Float16</span><span class="p">(</span><span class="mf">4.</span><span class="p">)</span><span>
</span><span class="go">8.0f0
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The underscore <code>_</code> can be used as digit separator:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="mi">10_000</span><span class="p">,</span><span> </span><span class="mf">0.000_000_005</span><span class="p">,</span><span> </span><span class="mh">0xdead_beef</span><span class="p">,</span><span> </span><span class="mb">0b1011_0010</span><span>
</span><span class="go">(10000,5.0e-9,0xdeadbeef,0xb2)
</span></code></pre><a id="Floating-point-zero-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>Floating-point zero</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Floating-point numbers have <a href="https://en.wikipedia.org/wiki/Signed_zero">two zeros</a>, positive zero and negative zero. They are equal to each other but have different binary representations, as can be seen using the <code>bits</code> function: :</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="mf">0.0</span><span> </span><span class="o">==</span><span> </span><span class="o">-</span><span class="mf">0.0</span><span>
</span><span class="go">true
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">bits</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span><span>
</span><span class="go">&quot;0000000000000000000000000000000000000000000000000000000000000000&quot;
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">bits</span><span class="p">(</span><span class="o">-</span><span class="mf">0.0</span><span class="p">)</span><span>
</span><span class="go">&quot;1000000000000000000000000000000000000000000000000000000000000000&quot;
</span></code></pre><a id="Special-floating-point-values-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>Special floating-point values</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>There are three specified standard floating-point values that do not correspond to any point on the real number line:</p><div class="mdnote debug">Base.Markdown.Table</div><table><tr><th><code>Float16</code></th><th><code>Float32</code></th><th><code>Float64</code></th><th>Name</th><th>Description</th></tr><tr><td><code>Inf16</code></td><td><code>Inf32</code></td><td><code>Inf</code></td><td>positive infinity</td><td>a value greater than all finite floating-point values</td></tr><tr><td><code>-Inf16</code></td><td><code>-Inf32</code></td><td><code>-Inf</code></td><td>negative infinity</td><td>a value less than all finite floating-point values</td></tr><tr><td><code>NaN16</code></td><td><code>NaN32</code></td><td><code>NaN</code></td><td>not a number</td><td>a value not <code>==</code> to any floating-point value (including itself)</td></tr></table><div class="mdnote debug">Base.Markdown.Paragraph</div><p>For further discussion of how these non-finite floating-point values are ordered with respect to each other and other floats, see <a href="mathematical-operations.html#Numeric-Comparisons-1">Numeric Comparisons</a>. By the <a href="https://en.wikipedia.org/wiki/IEEE_754-2008">IEEE 754 standard</a>, these floating-point values are the results of certain arithmetic operations:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="mi">1</span><span class="o">/</span><span class="nb">Inf</span><span>
</span><span class="go">0.0
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="mi">1</span><span class="o">/</span><span class="mi">0</span><span>
</span><span class="go">Inf
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="o">-</span><span class="mi">5</span><span class="o">/</span><span class="mi">0</span><span>
</span><span class="go">-Inf
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="mf">0.000001</span><span class="o">/</span><span class="mi">0</span><span>
</span><span class="go">Inf
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="mi">0</span><span class="o">/</span><span class="mi">0</span><span>
</span><span class="go">NaN
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="mi">500</span><span> </span><span class="o">+</span><span> </span><span class="nb">Inf</span><span>
</span><span class="go">Inf
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="mi">500</span><span> </span><span class="o">-</span><span> </span><span class="nb">Inf</span><span>
</span><span class="go">-Inf
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">Inf</span><span> </span><span class="o">+</span><span> </span><span class="nb">Inf</span><span>
</span><span class="go">Inf
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">Inf</span><span> </span><span class="o">-</span><span> </span><span class="nb">Inf</span><span>
</span><span class="go">NaN
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">Inf</span><span> </span><span class="o">*</span><span> </span><span class="nb">Inf</span><span>
</span><span class="go">Inf
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">Inf</span><span> </span><span class="o">/</span><span> </span><span class="nb">Inf</span><span>
</span><span class="go">NaN
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="mi">0</span><span> </span><span class="o">*</span><span> </span><span class="nb">Inf</span><span>
</span><span class="go">NaN
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The <a href="../stdlib/base.html#Base.typemin"><code>typemin()</code></a> and <a href="../stdlib/base.html#Base.typemax"><code>typemax()</code></a> functions also apply to floating-point types:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="p">(</span><span class="nb">typemin</span><span class="p">(</span><span class="n">Float16</span><span class="p">)</span><span class="p">,</span><span class="nb">typemax</span><span class="p">(</span><span class="n">Float16</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="go">(-Inf16,Inf16)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="p">(</span><span class="nb">typemin</span><span class="p">(</span><span class="kt">Float32</span><span class="p">)</span><span class="p">,</span><span class="nb">typemax</span><span class="p">(</span><span class="kt">Float32</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="go">(-Inf32,Inf32)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="p">(</span><span class="nb">typemin</span><span class="p">(</span><span class="kt">Float64</span><span class="p">)</span><span class="p">,</span><span class="nb">typemax</span><span class="p">(</span><span class="kt">Float64</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="go">(-Inf,Inf)
</span></code></pre><a id="Machine-epsilon-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>Machine epsilon</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Most real numbers cannot be represented exactly with floating-point numbers, and so for many purposes it is important to know the distance between two adjacent representable floating-point numbers, which is often known as <a href="https://en.wikipedia.org/wiki/Machine_epsilon">machine epsilon</a>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Julia provides <a href="../stdlib/dates.html#Base.eps"><code>eps()</code></a>, which gives the distance between <code>1.0</code> and the next larger representable floating-point value:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">eps</span><span class="p">(</span><span class="kt">Float32</span><span class="p">)</span><span>
</span><span class="go">1.1920929f-7
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">eps</span><span class="p">(</span><span class="kt">Float64</span><span class="p">)</span><span>
</span><span class="go">2.220446049250313e-16
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">eps</span><span class="p">(</span><span class="p">)</span><span> </span><span class="c"># same as eps(Float64)</span><span>
</span><span class="go">2.220446049250313e-16
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>These values are <code>2.0^-23</code> and <code>2.0^-52</code> as <code>Float32</code> and <code>Float64</code> values, respectively. The <a href="../stdlib/dates.html#Base.eps"><code>eps()</code></a> function can also take a floating-point value as an argument, and gives the absolute difference between that value and the next representable floating point value. That is, <code>eps(x)</code> yields a value of the same type as <code>x</code> such that <code>x + eps(x)</code> is the next representable floating-point value larger than <code>x</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">eps</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span><span>
</span><span class="go">2.220446049250313e-16
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">eps</span><span class="p">(</span><span class="mf">1000.</span><span class="p">)</span><span>
</span><span class="go">1.1368683772161603e-13
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">eps</span><span class="p">(</span><span class="mf">1e-27</span><span class="p">)</span><span>
</span><span class="go">1.793662034335766e-43
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">eps</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span><span>
</span><span class="go">5.0e-324
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The distance between two adjacent representable floating-point numbers is not constant, but is smaller for smaller values and larger for larger values. In other words, the representable floating-point numbers are densest in the real number line near zero, and grow sparser exponentially as one moves farther away from zero. By definition, <code>eps(1.0)</code> is the same as <code>eps(Float64)</code> since <code>1.0</code> is a 64-bit floating-point value.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Julia also provides the <a href="../stdlib/numbers.html#Base.nextfloat"><code>nextfloat()</code></a> and <a href="../stdlib/numbers.html#Base.prevfloat"><code>prevfloat()</code></a> functions which return the next largest or smallest representable floating-point number to the argument respectively: :</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">x</span><span> </span><span class="o">=</span><span> </span><span class="mf">1.25f0</span><span>
</span><span class="go">1.25f0
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">nextfloat</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span>
</span><span class="go">1.2500001f0
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">prevfloat</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span>
</span><span class="go">1.2499999f0
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">bits</span><span class="p">(</span><span class="n">prevfloat</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="go">&quot;00111111100111111111111111111111&quot;
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">bits</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span>
</span><span class="go">&quot;00111111101000000000000000000000&quot;
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">bits</span><span class="p">(</span><span class="n">nextfloat</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="go">&quot;00111111101000000000000000000001&quot;
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This example highlights the general principle that the adjacent representable floating-point numbers also have adjacent binary integer representations.</p><a id="Rounding-modes-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>Rounding modes</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>If a number doesn&#39;t have an exact floating-point representation, it must be rounded to an appropriate representable value, however, if wanted, the manner in which this rounding is done can be changed according to the rounding modes presented in the <a href="https://en.wikipedia.org/wiki/IEEE_754-2008">IEEE 754 standard</a>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="mf">1.1</span><span> </span><span class="o">+</span><span> </span><span class="mf">0.1</span><span>
</span><span class="go">1.2000000000000002
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">setrounding</span><span class="p">(</span><span class="kt">Float64</span><span class="p">,</span><span class="n">RoundDown</span><span class="p">)</span><span> </span><span class="k">do</span><span>
</span><span class="gt">
       1.1 + 0.1
</span><span></span><span class="gt">
       end
</span><span></span><span class="go">1.2
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The default mode used is always <a href="../stdlib/math.html#Base.Rounding.RoundNearest"><code>RoundNearest</code></a>, which rounds to the nearest representable value, with ties rounded towards the nearest value with an even least significant bit.</p><div class="mdnote debug">Base.Markdown.Admonition</div><div class="admonition warning"><div class="admonition-title"></div><div class="admonition-text"><p>Rounding is generally only correct for basic arithmetic functions (<a href="../stdlib/math.html#Base.+"><code>+()</code></a>, <a href="../stdlib/math.html#Base.-"><code>-()</code></a>, <a href="../stdlib/linalg.html#Base.*"><code>*()</code></a>, <a href="../stdlib/math.html#Base./"><code>/()</code></a> and <a href="../stdlib/math.html#Base.sqrt"><code>sqrt()</code></a>) and type conversion operations. Many other functions assume the default <a href="../stdlib/math.html#Base.Rounding.RoundNearest"><code>RoundNearest</code></a> mode is set, and can give erroneous results when operating under other rounding modes.</p></div></div><a id="Background-and-References-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>Background and References</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Floating-point arithmetic entails many subtleties which can be surprising to users who are unfamiliar with the low-level implementation details. However, these subtleties are described in detail in most books on scientific computation, and also in the following references:</p><div class="mdnote debug">Base.Markdown.List</div><ul><li><p>The definitive guide to floating point arithmetic is the <a href="http://standards.ieee.org/findstds/standard/754-2008.html">IEEE 754-2008 Standard</a>; however, it is not available for free online.</p></li><li><p>For a brief but lucid presentation of how floating-point numbers are represented, see John D. Cook&#39;s <a href="http://www.johndcook.com/blog/2009/04/06/anatomy-of-a-floating-point-number/">article</a> on the subject as well as his <a href="http://www.johndcook.com/blog/2009/04/06/numbers-are-a-leaky-abstraction/">introduction</a> to some of the issues arising from how this representation differs in behavior from the idealized abstraction of real numbers.</p></li><li><p>Also recommended is Bruce Dawson&#39;s <a href="https://randomascii.wordpress.com/2012/05/20/thats-not-normalthe-performance-of-odd-floats/">series of blog posts on floating-point numbers</a>.</p></li><li><p>For an excellent, in-depth discussion of floating-point numbers and issues of numerical accuracy encountered when computing with them, see David Goldberg&#39;s paper <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.22.6768&rep=rep1&type=pdf">What Every Computer Scientist Should Know About Floating-Point Arithmetic</a>.</p></li><li><p>For even more extensive documentation of the history of, rationale for, and issues with floating-point numbers, as well as discussion of many other topics in numerical computing, see the <a href="http://www.cs.berkeley.edu/~wkahan/">collected writings</a> of <a href="https://en.wikipedia.org/wiki/William_Kahan">William Kahan</a>, commonly known as the &quot;Father of Floating-Point&quot;. Of particular interest may be <a href="http://www.cs.berkeley.edu/~wkahan/ieee754status/754story.html">An Interview with the Old Man of Floating-Point</a>.</p></li></ul><a id="Arbitrary-Precision-Arithmetic-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Arbitrary Precision Arithmetic</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>To allow computations with arbitrary-precision integers and floating point numbers, Julia wraps the <a href="https://gmplib.org">GNU Multiple Precision Arithmetic Library (GMP)</a> and the <a href="http://www.mpfr.org">GNU MPFR Library</a>, respectively. The <a href="../stdlib/numbers.html#Base.GMP.BigInt"><code>BigInt</code></a> and <a href="../stdlib/numbers.html#Base.MPFR.BigFloat"><code>BigFloat</code></a> types are available in Julia for arbitrary precision integer and floating point numbers respectively.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Constructors exist to create these types from primitive numerical types, and <a href="../stdlib/base.html#Base.parse"><code>parse()</code></a> can be use to construct them from <code>AbstractString</code>s.  Once created, they participate in arithmetic with all other numeric types thanks to Julia&#39;s <a href="@ref">type promotion and conversion mechanism</a>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">BigInt</span><span class="p">(</span><span class="nb">typemax</span><span class="p">(</span><span class="kt">Int64</span><span class="p">)</span><span class="p">)</span><span> </span><span class="o">+</span><span> </span><span class="mi">1</span><span>
</span><span class="go">9223372036854775808
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">parse</span><span class="p">(</span><span class="n">BigInt</span><span class="p">,</span><span> </span><span class="s">&quot;</span><span class="s">123456789012345678901234567890</span><span class="s">&quot;</span><span class="p">)</span><span> </span><span class="o">+</span><span> </span><span class="mi">1</span><span>
</span><span class="go">123456789012345678901234567891
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">parse</span><span class="p">(</span><span class="n">BigFloat</span><span class="p">,</span><span> </span><span class="s">&quot;</span><span class="s">1.23456789012345678901</span><span class="s">&quot;</span><span class="p">)</span><span>
</span><span class="go">1.234567890123456789010000000000000000000000000000000000000000000000000000000004
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">BigFloat</span><span class="p">(</span><span class="mf">2.0</span><span class="o">^</span><span class="mi">66</span><span class="p">)</span><span> </span><span class="o">/</span><span> </span><span class="mi">3</span><span>
</span><span class="go">2.459565876494606882133333333333333333333333333333333333333333333333333333333344e+19
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">factorial</span><span class="p">(</span><span class="n">BigInt</span><span class="p">(</span><span class="mi">40</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="go">815915283247897734345611269596115894272000000000
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>However, type promotion between the primitive types above and <a href="../stdlib/numbers.html#Base.GMP.BigInt"><code>BigInt</code></a>/<a href="../stdlib/numbers.html#Base.MPFR.BigFloat"><code>BigFloat</code></a> is not automatic and must be explicitly stated.</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">x</span><span> </span><span class="o">=</span><span> </span><span class="nb">typemin</span><span class="p">(</span><span class="kt">Int64</span><span class="p">)</span><span>
</span><span class="go">-9223372036854775808
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">x</span><span> </span><span class="o">=</span><span> </span><span class="n">x</span><span> </span><span class="o">-</span><span> </span><span class="mi">1</span><span>
</span><span class="go">9223372036854775807
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span>
</span><span class="go">Int64
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">y</span><span> </span><span class="o">=</span><span> </span><span class="n">BigInt</span><span class="p">(</span><span class="nb">typemin</span><span class="p">(</span><span class="kt">Int64</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="go">-9223372036854775808
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">y</span><span> </span><span class="o">=</span><span> </span><span class="n">y</span><span> </span><span class="o">-</span><span> </span><span class="mi">1</span><span>
</span><span class="go">-9223372036854775809
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span>
</span><span class="go">BigInt
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The default precision (in number of bits of the significand) and rounding mode of <a href="../stdlib/numbers.html#Base.MPFR.BigFloat"><code>BigFloat</code></a> operations can be changed globally by calling <a href="../stdlib/numbers.html#Base.MPFR.setprecision"><code>setprecision()</code></a> and <a href="../stdlib/numbers.html#Base.Rounding.setrounding"><code>setrounding()</code></a>, and all further calculations will take these changes in account.  Alternatively, the precision or the rounding can be changed only within the execution of a particular block of code by using the same functions with a <code>do</code> block:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">setrounding</span><span class="p">(</span><span class="n">BigFloat</span><span class="p">,</span><span> </span><span class="n">RoundUp</span><span class="p">)</span><span> </span><span class="k">do</span><span>
</span><span class="gt">
       BigFloat(1) + parse(BigFloat, &quot;0.1&quot;)
</span><span></span><span class="gt">
       end
</span><span></span><span class="go">1.100000000000000000000000000000000000000000000000000000000000000000000000000003
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">setrounding</span><span class="p">(</span><span class="n">BigFloat</span><span class="p">,</span><span> </span><span class="n">RoundDown</span><span class="p">)</span><span> </span><span class="k">do</span><span>
</span><span class="gt">
       BigFloat(1) + parse(BigFloat, &quot;0.1&quot;)
</span><span></span><span class="gt">
       end
</span><span></span><span class="go">1.099999999999999999999999999999999999999999999999999999999999999999999999999986
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">setprecision</span><span class="p">(</span><span class="mi">40</span><span class="p">)</span><span> </span><span class="k">do</span><span>
</span><span class="gt">
       BigFloat(1) + parse(BigFloat, &quot;0.1&quot;)
</span><span></span><span class="gt">
       end
</span><span></span><span class="go">1.1000000000004
</span></code></pre><a id="Numeric-Literal-Coefficients-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Numeric Literal Coefficients</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>To make common numeric formulas and expressions clearer, Julia allows variables to be immediately preceded by a numeric literal, implying multiplication. This makes writing polynomial expressions much cleaner:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">x</span><span> </span><span class="o">=</span><span> </span><span class="mi">3</span><span>
</span><span class="go">3
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="mi">2</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span> </span><span class="o">-</span><span> </span><span class="mi">3</span><span class="n">x</span><span> </span><span class="o">+</span><span> </span><span class="mi">1</span><span>
</span><span class="go">10
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="mf">1.5</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span> </span><span class="o">-</span><span> </span><span class="o">.</span><span class="mi">5</span><span class="n">x</span><span> </span><span class="o">+</span><span> </span><span class="mi">1</span><span>
</span><span class="go">13.0
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>It also makes writing exponential functions more elegant:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="mi">2</span><span class="o">^</span><span class="mi">2</span><span class="n">x</span><span>
</span><span class="go">64
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The precedence of numeric literal coefficients is the same as that of unary operators such as negation. So <code>2^3x</code> is parsed as <code>2^(3x)</code>, and <code>2x^3</code> is parsed as <code>2*(x^3)</code>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Numeric literals also work as coefficients to parenthesized expressions:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="mi">2</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span> </span><span class="o">-</span><span> </span><span class="mi">3</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span> </span><span class="o">+</span><span> </span><span class="mi">1</span><span>
</span><span class="go">3
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Additionally, parenthesized expressions can be used as coefficients to variables, implying multiplication of the expression by the variable:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="n">x</span><span>
</span><span class="go">6
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Neither juxtaposition of two parenthesized expressions, nor placing a variable before a parenthesized expression, however, can be used to imply multiplication:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span>
</span><span class="go">ERROR: MethodError: objects of type Int64 are not callable
</span><span class="go">...
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">x</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span>
</span><span class="go">ERROR: MethodError: objects of type Int64 are not callable
</span><span class="go">...
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Both expressions are interpreted as function application: any expression that is not a numeric literal, when immediately followed by a parenthetical, is interpreted as a function applied to the values in parentheses (see <a href="@ref">Functions</a> for more about functions). Thus, in both of these cases, an error occurs since the left-hand value is not a function.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The above syntactic enhancements significantly reduce the visual noise incurred when writing common mathematical formulae. Note that no whitespace may come between a numeric literal coefficient and the identifier or parenthesized expression which it multiplies.</p><a id="Syntax-Conflicts-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>Syntax Conflicts</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Juxtaposed literal coefficient syntax may conflict with two numeric literal syntaxes: hexadecimal integer literals and engineering notation for floating-point literals. Here are some situations where syntactic conflicts arise:</p><div class="mdnote debug">Base.Markdown.List</div><ul><li><p>The hexadecimal integer literal expression <code>0xff</code> could be interpreted as the numeric literal <code>0</code> multiplied by the variable <code>xff</code>.</p></li><li><p>The floating-point literal expression <code>1e10</code> could be interpreted as the numeric literal <code>1</code> multiplied by the variable <code>e10</code>, and similarly with the equivalent <code>E</code> form.</p></li></ul><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In both cases, we resolve the ambiguity in favor of interpretation as a numeric literals:</p><div class="mdnote debug">Base.Markdown.List</div><ul><li><p>Expressions starting with <code>0x</code> are always hexadecimal literals.</p></li><li><p>Expressions starting with a numeric literal followed by <code>e</code> or <code>E</code> are always floating-point literals.</p></li></ul><a id="Literal-zero-and-one-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Literal zero and one</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Julia provides functions which return literal 0 and 1 corresponding to a specified type or the type of a given variable.</p><div class="mdnote debug">Base.Markdown.Table</div><table><tr><th>Function</th><th>Description</th></tr><tr><td><a href="../stdlib/numbers.html#Base.zero"><code>zero(x)</code></a></td><td>Literal zero of type <code>x</code> or type of variable <code>x</code></td></tr><tr><td><a href="../stdlib/numbers.html#Base.one"><code>one(x)</code></a></td><td>Literal one of type <code>x</code> or type of variable <code>x</code></td></tr></table><div class="mdnote debug">Base.Markdown.Paragraph</div><p>These functions are useful in <a href="mathematical-operations.html#Numeric-Comparisons-1">Numeric Comparisons</a> to avoid overhead from unnecessary <a href="@ref">type conversion</a>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Examples:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">zero</span><span class="p">(</span><span class="kt">Float32</span><span class="p">)</span><span>
</span><span class="go">0.0f0
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">zero</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span><span>
</span><span class="go">0.0
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">one</span><span class="p">(</span><span class="kt">Int32</span><span class="p">)</span><span>
</span><span class="go">1
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">one</span><span class="p">(</span><span class="n">BigFloat</span><span class="p">)</span><span>
</span><span class="go">1.000000000000000000000000000000000000000000000000000000000000000000000000000000
</span></code></pre><footer><hr/><a class="previous" href="index.html"><span class="direction">Previous</span><span class="title">The Julia Manual</span></a><a class="next" href="interacting-with-julia.html"><span class="direction">Next</span><span class="title">Interacting With Julia</span></a></footer></article></body></html>
