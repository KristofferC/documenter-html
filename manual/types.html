<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Documenter.jl</title><link href="../normalize.css" rel="stylesheet" type="text/css"/><link href="../style.css" rel="stylesheet" type="text/css"/><link href="../highlight.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="../require.js" data-main="../documenter.js"></script><script src="../search-index.js"></script></head><body><nav class="toc"><a href="http://julialang.org/"><img class="logo" src="http://docs.julialang.org/en/release-0.4/_static/julia-logo.svg" alt="\$pkgname.jl logo"/></a><h1>$pkgname.jl</h1><input type="text" placeholder="Search docs"/><ul><li><a class="toctext" href="../index.html">Overview</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../man/guide.html">Guide</a></li><li><a class="toctext" href="../man/examples.html">Examples</a></li><li><a class="toctext" href="../man/syntax.html">Syntax</a></li><li><a class="toctext" href="../man/doctests.html">Doctests</a></li><li><a class="toctext" href="../man/hosting.html">Hosting Documentation</a></li><li><a class="toctext" href="../man/latex.html"><span>$\LaTeX$</span> syntax</a></li><li><a class="toctext" href="../man/internals.html">Package Internals</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../lib/public.html">Public Documentation</a></li><li><a class="toctext" href="../lib/internals.html">Internal Documentation</a></li></ul></li><li><span class="toctext">Dynamic pages</span><ul><li><a class="toctext" href="../dynamic/code.html">Code examples</a></li><li><a class="toctext" href="../dynamic/admonitions.html">Admonitions &amp; Co</a></li><li><a class="toctext" href="../dynamic/styles.html">Demonstrating <em>styles</em> of MD elements</a></li><li><a class="toctext" href="../dynamic/bugs.html">Some existing bugs</a></li></ul></li><li><span class="toctext">JuliaDocs - Manual</span><ul><li><a class="toctext" href="arrays.html">Multi-dimensional Arrays</a></li><li><a class="toctext" href="calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="toctext" href="complex-and-rational-numbers.html">Complex and Rational Numbers</a></li><li><a class="toctext" href="constructors.html">Constructors</a></li><li><a class="toctext" href="control-flow.html">Control Flow</a></li><li><a class="toctext" href="conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="toctext" href="dates.html">Date and DateTime</a></li><li><a class="toctext" href="documentation.html">Documentation</a></li><li><a class="toctext" href="embedding.html">Embedding Julia</a></li><li><a class="toctext" href="faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="functions.html">Functions</a></li><li><a class="toctext" href="getting-started.html">Getting Started</a></li><li><a class="toctext" href="handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="index.html">The Julia Manual</a></li><li><a class="toctext" href="integers-and-floating-point-numbers.html">Integers and Floating-Point Numbers</a></li><li><a class="toctext" href="interacting-with-julia.html">Interacting With Julia</a></li><li><a class="toctext" href="interfaces.html">Interfaces</a></li><li><a class="toctext" href="introduction.html">Introduction</a></li><li><a class="toctext" href="linear-algebra.html">Linear algebra</a></li><li><a class="toctext" href="mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="metaprogramming.html">Metaprogramming</a></li><li><a class="toctext" href="methods.html">Methods</a></li><li><a class="toctext" href="modules.html">Modules</a></li><li><a class="toctext" href="networking-and-streams.html">Networking and Streams</a></li><li><a class="toctext" href="noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="packages.html">Packages</a></li><li><a class="toctext" href="parallel-computing.html">Parallel Computing</a></li><li><a class="toctext" href="performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="profile.html">Profiling</a></li><li><a class="toctext" href="running-external-programs.html">Running External Programs</a></li><li><a class="toctext" href="stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="strings.html">Strings</a></li><li><a class="toctext" href="style-guide.html">Style Guide</a></li><li class="current"><a class="toctext" href="types.html">Types</a><ul class="internal"><li><a class="toctext" href="#Type-Declarations-1">Type Declarations</a></li><li><a class="toctext" href="#Abstract-Types-1">Abstract Types</a></li><li><a class="toctext" href="#Bits-Types-1">Bits Types</a></li><li><a class="toctext" href="#Composite-Types-1">Composite Types</a></li><li><a class="toctext" href="#Immutable-Composite-Types-1">Immutable Composite Types</a></li><li><a class="toctext" href="#Declared-Types-1">Declared Types</a></li><li><a class="toctext" href="#Type-Unions-1">Type Unions</a></li><li><a class="toctext" href="#Parametric-Types-1">Parametric Types</a></li><li><a class="toctext" href="#Type-Aliases-1">Type Aliases</a></li><li><a class="toctext" href="#Operations-on-Types-1">Operations on Types</a></li><li><a class="toctext" href="#\"Value-types\"-1">&quot;Value types&quot;</a></li><li><a class="toctext" href="#Nullable-Types:-Representing-Missing-Values-1">Nullable Types: Representing Missing Values</a></li></ul></li><li><a class="toctext" href="unicode-input.html">Unicode Input</a></li><li><a class="toctext" href="variables-and-scoping.html">Scope of Variables</a></li><li><a class="toctext" href="variables.html">Variables</a></li><li><a class="toctext" href="workflow-tips.html">Workflow Tips</a></li></ul></li><li><span class="toctext">JuliaDocs - Standard Libary</span><ul><li><a class="toctext" href="../stdlib/arrays.html">Arrays</a></li><li><a class="toctext" href="../stdlib/base.html">Essentials</a></li><li><a class="toctext" href="../stdlib/c.html">C Interface</a></li><li><a class="toctext" href="../stdlib/collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="../stdlib/constants.html">Constants</a></li><li><a class="toctext" href="../stdlib/dates.html">Dates and Time</a></li><li><a class="toctext" href="../stdlib/file.html">Filesystem</a></li><li><a class="toctext" href="../stdlib/index.html">The Julia Standard Library</a></li><li><a class="toctext" href="../stdlib/io-network.html">I/O and Network</a></li><li><a class="toctext" href="../stdlib/libc.html">C Standard Library</a></li><li><a class="toctext" href="../stdlib/libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="../stdlib/linalg.html">Linear Algebra</a></li><li><a class="toctext" href="../stdlib/math.html">Mathematics</a></li><li><a class="toctext" href="../stdlib/numbers.html">Numbers</a></li><li><a class="toctext" href="../stdlib/parallel.html">Tasks and Parallel Computing</a></li><li><a class="toctext" href="../stdlib/pkg.html">Package Manager Functions</a></li><li><a class="toctext" href="../stdlib/profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/punctuation.html">Punctuation</a></li><li><a class="toctext" href="../stdlib/simd-types.html">SIMD Support</a></li><li><a class="toctext" href="../stdlib/sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="../stdlib/stacktraces.html">StackTraces</a></li><li><a class="toctext" href="../stdlib/strings.html">Strings</a></li><li><a class="toctext" href="../stdlib/test.html">Unit Testing</a></li></ul></li><li><span class="toctext">JuliaDocs - DevDocs</span><ul><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/C.html">Developing/debugging Julia&#39;s C code</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../devdocs/julia.html">Documentation of Julia&#39;s Internals</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/promote-op.html">Operator-sensitive promotion</a></li><li><a class="toctext" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/types.html">More about types</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>JuliaDocs - Manual</li><li><a href="types.html">Types</a></li></ul><a class="edit-page" href="https://github.com/"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><a id="Types-1"></a><div class="mdnote debug">Base.Markdown.Header{1}</div><h1>Types</h1><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Type systems have traditionally fallen into two quite different camps: static type systems, where every program expression must have a type computable before the execution of the program, and dynamic type systems, where nothing is known about types until run time, when the actual values manipulated by the program are available. Object orientation allows some flexibility in statically typed languages by letting code be written without the precise types of values being known at compile time. The ability to write code that can operate on different types is called polymorphism. All code in classic dynamically typed languages is polymorphic: only by explicitly checking types, or when objects fail to support operations at run-time, are the types of any values ever restricted.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Julia&#39;s type system is dynamic, but gains some of the advantages of static type systems by making it possible to indicate that certain values are of specific types. This can be of great assistance in generating efficient code, but even more significantly, it allows method dispatch on the types of function arguments to be deeply integrated with the language. Method dispatch is explored in detail in <a href="methods.html#Methods-1">Methods</a>, but is rooted in the type system presented here.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The default behavior in Julia when types are omitted is to allow values to be of any type. Thus, one can write many useful Julia programs without ever explicitly using types. When additional expressiveness is needed, however, it is easy to gradually introduce explicit type annotations into previously &quot;untyped&quot; code. Doing so will typically increase both the performance and robustness of these systems, and perhaps somewhat counterintuitively, often significantly simplify them.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Describing Julia in the lingo of <a href="https://en.wikipedia.org/wiki/Type_system">type systems</a>, it is: dynamic, nominative and parametric. Generic types can be parameterized, and the hierarchical relationships between types are explicitly declared, rather than implied by compatible structure. One particularly distinctive feature of Julia&#39;s type system is that concrete types may not subtype each other: all concrete types are final and may only have abstract types as their supertypes. While this might at first seem unduly restrictive, it has many beneficial consequences with surprisingly few drawbacks. It turns out that being able to inherit behavior is much more important than being able to inherit structure, and inheriting both causes significant difficulties in traditional object-oriented languages. Other high-level aspects of Julia&#39;s type system that should be mentioned up front are:</p><div class="mdnote debug">Base.Markdown.List</div><ul><li><p>There is no division between object and non-object values: all values in Julia are true objects having a type that belongs to a single, fully connected type graph, all nodes of which are equally first-class as types.</p></li><li><p>There is no meaningful concept of a &quot;compile-time type&quot;: the only type a value has is its actual type when the program is running. This is called a &quot;run-time type&quot; in object-oriented languages where the combination of static compilation with polymorphism makes this distinction significant.</p></li><li><p>Only values, not variables, have types – variables are simply names bound to values.</p></li><li><p>Both abstract and concrete types can be parameterized by other types. They can also be parameterized by symbols, by values of any type for which <a href="../stdlib/base.html#Base.isbits"><code>isbits()</code></a> returns true (essentially, things like numbers and bools that are stored like C types or structs with no pointers to other objects), and also by tuples thereof. Type parameters may be omitted when they do not need to be referenced or restricted.</p></li></ul><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Julia&#39;s type system is designed to be powerful and expressive, yet clear, intuitive and unobtrusive. Many Julia programmers may never feel the need to write code that explicitly uses types. Some kinds of programming, however, become clearer, simpler, faster and more robust with declared types.</p><a id="Type-Declarations-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Type Declarations</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The <code>::</code> operator can be used to attach type annotations to expressions and variables in programs. There are two primary reasons to do this:</p><div class="mdnote debug">Base.Markdown.List</div><ol><li><p>As an assertion to help confirm that your program works the way you expect,</p></li><li><p>To provide extra type information to the compiler, which can then improve performance in some cases</p></li></ol><div class="mdnote debug">Base.Markdown.Paragraph</div><p>When appended to an expression computing a value, the <code>::</code> operator is read as &quot;is an instance of&quot;. It can be used anywhere to assert that the value of the expression on the left is an instance of the type on the right. When the type on the right is concrete, the value on the left must have that type as its implementation – recall that all concrete types are final, so no implementation is a subtype of any other. When the type is abstract, it suffices for the value to be implemented by a concrete type that is a subtype of the abstract type. If the type assertion is not true, an exception is thrown, otherwise, the left-hand value is returned:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="p">:</span><span class="p">:</span><span class="n">AbstractFloat</span><span>
</span><span class="go">ERROR: TypeError: typeassert: expected AbstractFloat, got Int64
</span><span class="go"> ...
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="p">:</span><span class="p">:</span><span class="kt">Int</span><span>
</span><span class="go">3
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This allows a type assertion to be attached to any expression in-place.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>When appended to a variable on the left-hand side of an assignment, or as part of a <code>local</code> declaration, the <code>::</code> operator means something a bit different: it declares the variable to always have the specified type, like a type declaration in a statically-typed language such as C. Every value assigned to the variable will be converted to the declared type using <a href="../stdlib/base.html#Base.convert"><code>convert()</code></a>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="k">function</span><span class="nf"> </span><span class="nf">foo</span><span class="p">(</span><span class="p">)</span><span>
</span><span class="gt">
         x::Int8 = 100
</span><span></span><span class="gt">
         x
</span><span></span><span class="gt">
       end
</span><span></span><span class="go">foo (generic function with 1 method)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">foo</span><span class="p">(</span><span class="p">)</span><span>
</span><span class="go">100
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span><span>
</span><span class="go">Int8
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This feature is useful for avoiding performance &quot;gotchas&quot; that could occur if one of the assignments to a variable changed its type unexpectedly.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This &quot;declaration&quot; behavior only occurs in specific contexts:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="kd">local</span><span> </span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="kt">Int8</span><span>  </span><span class="c"># in a local declaration</span><span>
</span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="kt">Int8</span><span> </span><span class="o">=</span><span> </span><span class="mi">10</span><span>   </span><span class="c"># as the left-hand side of an assignment</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>and applies to the whole current scope, even before the declaration. Currently, type declarations cannot be used in global scope, e.g. in the REPL, since Julia does not yet have constant-type globals.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Declarations can also be attached to function definitions:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">function</span><span class="nf"> </span><span class="nf">sinc</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="p">:</span><span class="p">:</span><span class="kt">Float64</span><span>
</span><span>    </span><span class="k">if</span><span> </span><span class="n">x</span><span> </span><span class="o">==</span><span> </span><span class="mi">0</span><span>
</span><span>        </span><span class="k">return</span><span> </span><span class="mi">1</span><span>
</span><span>    </span><span class="k">end</span><span>
</span><span>    </span><span class="k">return</span><span> </span><span class="n">sin</span><span class="p">(</span><span class="nb">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="nb">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Returning from this function behaves just like an assignment to a variable with a declared type: the value is always converted to <code>Float64</code>.</p><a id="Abstract-Types-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Abstract Types</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Abstract types cannot be instantiated, and serve only as nodes in the type graph, thereby describing sets of related concrete types: those concrete types which are their descendants. We begin with abstract types even though they have no instantiation because they are the backbone of the type system: they form the conceptual hierarchy which makes Julia&#39;s type system more than just a collection of object implementations.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Recall that in <a href="integers-and-floating-point-numbers.html#Integers-and-Floating-Point-Numbers-1">Integers and Floating-Point Numbers</a>, we introduced a variety of concrete types of numeric values: <code>Int8</code>, <code>UInt8</code>, <code>Int16</code>, <code>UInt16</code>, <code>Int32</code>, <code>UInt32</code>, <code>Int64</code>, <code>UInt64</code>, <code>Int128</code>, <code>UInt128</code>, <code>Float16</code>, <a href="../stdlib/numbers.html#Core.Float32"><code>Float32</code></a>, and <a href="../stdlib/numbers.html#Core.Float64"><code>Float64</code></a>.  Although they have different representation sizes, <code>Int8</code>, <code>Int16</code>, <code>Int32</code>, <code>Int64</code>  and <code>Int128</code> all have in common that they are signed integer types. Likewise <code>UInt8</code>, <code>UInt16</code>, <code>UInt32</code>, <code>UInt64</code> and <code>UInt128</code> are all unsigned integer types, while <code>Float16</code>, <a href="../stdlib/numbers.html#Core.Float32"><code>Float32</code></a> and <a href="../stdlib/numbers.html#Core.Float64"><code>Float64</code></a> are distinct in being floating-point types rather than integers. It is common for a piece of code to make sense, for example, only if its arguments are some kind of integer, but not really depend on what particular <em>kind</em> of integer.  For example, the greatest common denominator algorithm works for all kinds of integers, but will not work for floating-point numbers.  Abstract types allow the construction of a hierarchy of types, providing a context into which concrete types can fit.  This allows you, for example, to easily program to any type that is an integer, without restricting an algorithm to a specific type of integer.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Abstract types are declared using the <code>abstract</code> keyword. The general syntaxes for declaring an abstract type are:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">abstract «name»
abstract «name» &lt;: «supertype»</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The <code>abstract</code> keyword introduces a new abstract type, whose name is given by <code>«name»</code>. This name can be optionally followed by <code>&lt;:</code> and an already-existing type, indicating that the newly declared abstract type is a subtype of this &quot;parent&quot; type.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>When no supertype is given, the default supertype is <code>Any</code> – a predefined abstract type that all objects are instances of and all types are subtypes of. In type theory, <code>Any</code> is commonly called &quot;top&quot; because it is at the apex of the type graph. Julia also has a predefined abstract &quot;bottom&quot; type, at the nadir of the type graph, which is written as <code>Union{}</code>. It is the exact opposite of <code>Any</code>: no object is an instance of <code>Union{}</code> and all types are supertypes of <code>Union{}</code>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Let&#39;s consider some of the abstract types that make up Julia&#39;s numerical hierarchy:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">abstract</span><span class="nc"> </span><span class="nc">Number</span><span>
</span><span class="k">abstract</span><span class="nc"> </span><span class="nc">Real</span><span>     </span><span class="o">&lt;:</span><span> </span><span class="n">Number</span><span>
</span><span class="k">abstract</span><span class="nc"> </span><span class="nc">AbstractFloat</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Real</span><span>
</span><span class="k">abstract</span><span class="nc"> </span><span class="nc">Integer</span><span>  </span><span class="o">&lt;:</span><span> </span><span class="n">Real</span><span>
</span><span class="k">abstract</span><span class="nc"> </span><span class="nc">Signed</span><span>   </span><span class="o">&lt;:</span><span> </span><span class="n">Integer</span><span>
</span><span class="k">abstract</span><span class="nc"> </span><span class="nc">Unsigned</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Integer</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The <code>Number</code> type is a direct child type of <code>Any</code>, and <code>Real</code> is its child. In turn, <code>Real</code> has two children (it has more, but only two are shown here; we&#39;ll get to the others later): <code>Integer</code> and <code>AbstractFloat</code>, separating the world into representations of integers and representations of real numbers. Representations of real numbers include, of course, floating-point types, but also include other types, such as rationals. Hence, <code>AbstractFloat</code> is a proper subtype of <code>Real</code>, including only floating-point representations of real numbers. Integers are further subdivided into <code>Signed</code> and <code>Unsigned</code> varieties.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The <code>&lt;:</code> operator in general means &quot;is a subtype of&quot;, and, used in declarations like this, declares the right-hand type to be an immediate supertype of the newly declared type. It can also be used in expressions as a subtype operator which returns <code>true</code> when its left operand is a subtype of its right operand:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Integer</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Number</span><span>
</span><span class="go">true
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Integer</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">AbstractFloat</span><span>
</span><span class="go">false
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>An important use of abstract types is to provide default implementations for concrete types. To give a simple example, consider:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">function</span><span class="nf"> </span><span class="nf">myplus</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span>
</span><span> </span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The first thing to note is that the above argument declarations are equivalent to <code>x::Any</code> and <code>y::Any</code>. When this function is invoked, say as <code>myplus(2,5)</code>, the dispatcher chooses the most specific method named <code>myplus</code> that matches the given arguments. (See <a href="methods.html#Methods-1">Methods</a> for more information on multiple dispatch.)</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Assuming no method more specific than the above is found, Julia next internally defines and compiles a method called <code>myplus</code> specifically for two <code>Int</code> arguments based on the generic function given above, i.e., it implicitly defines and compiles:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">function</span><span class="nf"> </span><span class="nf">myplus</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="kt">Int</span><span class="p">,</span><span class="n">y</span><span class="p">:</span><span class="p">:</span><span class="kt">Int</span><span class="p">)</span><span>
</span><span> </span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>and finally, it invokes this specific method.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Thus, abstract types allow programmers to write generic functions that can later be used as the default method by many combinations of concrete types. Thanks to multiple dispatch, the programmer has full control over whether the default or more specific method is used.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>An important point to note is that there is no loss in performance if the programmer relies on a function whose arguments are abstract types, because it is recompiled for each tuple of argument concrete types with which it is invoked. (There may be a performance issue, however, in the case of function arguments that are containers of abstract types; see <a href="performance-tips.html#Performance-Tips-1">Performance Tips</a>.)</p><a id="Bits-Types-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Bits Types</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>A bits type is a concrete type whose data consists of plain old bits. Classic examples of bits types are integers and floating-point values. Unlike most languages, Julia lets you declare your own bits types, rather than providing only a fixed set of built-in bits types. In fact, the standard bits types are all defined in the language itself:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">bitstype</span><span> </span><span class="mi">16</span><span> </span><span class="n">Float16</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">AbstractFloat</span><span>
</span><span class="k">bitstype</span><span> </span><span class="mi">32</span><span> </span><span class="kt">Float32</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">AbstractFloat</span><span>
</span><span class="k">bitstype</span><span> </span><span class="mi">64</span><span> </span><span class="kt">Float64</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">AbstractFloat</span><span>
</span><span>
</span><span class="k">bitstype</span><span> </span><span class="mi">8</span><span>  </span><span class="kt">Bool</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Integer</span><span>
</span><span class="k">bitstype</span><span> </span><span class="mi">32</span><span> </span><span class="n">Char</span><span>
</span><span>
</span><span class="k">bitstype</span><span> </span><span class="mi">8</span><span>  </span><span class="kt">Int8</span><span>     </span><span class="o">&lt;:</span><span> </span><span class="n">Signed</span><span>
</span><span class="k">bitstype</span><span> </span><span class="mi">8</span><span>  </span><span class="n">UInt8</span><span>    </span><span class="o">&lt;:</span><span> </span><span class="n">Unsigned</span><span>
</span><span class="k">bitstype</span><span> </span><span class="mi">16</span><span> </span><span class="kt">Int16</span><span>    </span><span class="o">&lt;:</span><span> </span><span class="n">Signed</span><span>
</span><span class="k">bitstype</span><span> </span><span class="mi">16</span><span> </span><span class="n">UInt16</span><span>   </span><span class="o">&lt;:</span><span> </span><span class="n">Unsigned</span><span>
</span><span class="k">bitstype</span><span> </span><span class="mi">32</span><span> </span><span class="kt">Int32</span><span>    </span><span class="o">&lt;:</span><span> </span><span class="n">Signed</span><span>
</span><span class="k">bitstype</span><span> </span><span class="mi">32</span><span> </span><span class="n">UInt32</span><span>   </span><span class="o">&lt;:</span><span> </span><span class="n">Unsigned</span><span>
</span><span class="k">bitstype</span><span> </span><span class="mi">64</span><span> </span><span class="kt">Int64</span><span>    </span><span class="o">&lt;:</span><span> </span><span class="n">Signed</span><span>
</span><span class="k">bitstype</span><span> </span><span class="mi">64</span><span> </span><span class="n">UInt64</span><span>   </span><span class="o">&lt;:</span><span> </span><span class="n">Unsigned</span><span>
</span><span class="k">bitstype</span><span> </span><span class="mi">128</span><span> </span><span class="n">Int128</span><span>  </span><span class="o">&lt;:</span><span> </span><span class="n">Signed</span><span>
</span><span class="k">bitstype</span><span> </span><span class="mi">128</span><span> </span><span class="n">UInt128</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Unsigned</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The general syntaxes for declaration of a <code>bitstype</code> are:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">bitstype «bits» «name»
bitstype «bits» «name» &lt;: «supertype»</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The number of bits indicates how much storage the type requires and the name gives the new type a name. A bits type can optionally be declared to be a subtype of some supertype. If a supertype is omitted, then the type defaults to having <code>Any</code> as its immediate supertype. The declaration of <code>Bool</code> above therefore means that a boolean value takes eight bits to store, and has <code>Integer</code> as its immediate supertype. Currently, only sizes that are multiples of 8 bits are supported. Therefore, boolean values, although they really need just a single bit, cannot be declared to be any smaller than eight bits.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The types <code>Bool</code>, <code>Int8</code> and <code>UInt8</code> all have identical representations: they are eight-bit chunks of memory. Since Julia&#39;s type system is nominative, however, they are not interchangeable despite having identical structure. Another fundamental difference between them is that they have different supertypes: <code>Bool</code>&#39;s direct supertype is <code>Integer</code>, <code>Int8</code>&#39;s is <code>Signed</code>, and <code>UInt8</code>&#39;s is <code>Unsigned</code>. All other differences between <code>Bool</code>, <code>Int8</code>, and <code>UInt8</code> are matters of behavior – the way functions are defined to act when given objects of these types as arguments. This is why a nominative type system is necessary: if structure determined type, which in turn dictates behavior, then it would be impossible to make <code>Bool</code> behave any differently than <code>Int8</code> or <code>UInt8</code>.</p><a id="Composite-Types-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Composite Types</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p><a href="https://en.wikipedia.org/wiki/Composite_data_type">Composite types</a> are called records, structures (<code>struct</code>s in C), or objects in various languages. A composite type is a collection of named fields, an instance of which can be treated as a single value. In many languages, composite types are the only kind of user-definable type, and they are by far the most commonly used user-defined type in Julia as well.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In mainstream object oriented languages, such as C++, Java, Python and Ruby, composite types also have named functions associated with them, and the combination is called an &quot;object&quot;. In purer object-oriented languages, such as Ruby or Smalltalk, all values are objects whether they are composites or not. In less pure object oriented languages, including C++ and Java, some values, such as integers and floating-point values, are not objects, while instances of user-defined composite types are true objects with associated methods. In Julia, all values are objects, but functions are not bundled with the objects they operate on. This is necessary since Julia chooses which method of a function to use by multiple dispatch, meaning that the types of <em>all</em> of a function&#39;s arguments are considered when selecting a method, rather than just the first one (see <a href="methods.html#Methods-1">Methods</a> for more information on methods and dispatch). Thus, it would be inappropriate for functions to &quot;belong&quot; to only their first argument. Organizing methods into function objects rather than having named bags of methods &quot;inside&quot; each object ends up being a highly beneficial aspect of the language design.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Since composite types are the most common form of user-defined concrete type, they are simply introduced with the <code>type</code> keyword followed by a block of field names, optionally annotated with types using the <code>::</code> operator:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="k">type</span><span class="nc"> </span><span class="nc">Foo</span><span>
</span><span class="gt">
         bar
</span><span></span><span class="gt">
         baz::Int
</span><span></span><span class="gt">
         qux::Float64
</span><span></span><span class="gt">
       end
</span><span></span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Fields with no type annotation default to <code>Any</code>, and can accordingly hold any type of value.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>New objects of composite type <code>Foo</code> are created by applying the <code>Foo</code> type object like a function to values for its fields:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">foo</span><span> </span><span class="o">=</span><span> </span><span class="n">Foo</span><span class="p">(</span><span class="s">&quot;</span><span class="s">Hello, world.</span><span class="s">&quot;</span><span class="p">,</span><span> </span><span class="mi">23</span><span class="p">,</span><span> </span><span class="mf">1.5</span><span class="p">)</span><span>
</span><span class="go">Foo(&quot;Hello, world.&quot;,23,1.5)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span>
</span><span class="go">Foo
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>When a type is applied like a function it is called a <em>constructor</em>. Two constructors are generated automatically (these are called <em>default constructors</em>). One accepts any arguments and calls <a href="../stdlib/base.html#Base.convert"><code>convert()</code></a> to convert them to the types of the fields, and the other accepts arguments that match the field types exactly. The reason both of these are generated is that this makes it easier to add new definitions without inadvertently replacing a default constructor.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Since the <code>bar</code> field is unconstrained in type, any value will do. However, the value for <code>baz</code> must be convertible to <code>Int</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Foo</span><span class="p">(</span><span class="p">(</span><span class="p">)</span><span class="p">,</span><span> </span><span class="mf">23.5</span><span class="p">,</span><span> </span><span class="mi">1</span><span class="p">)</span><span>
</span><span class="go">ERROR: InexactError()
</span><span class="go"> in Foo(::Tuple{}, ::Float64, ::Int64) at ./none:2
</span><span class="go"> ...
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>You may find a list of field names using the <code>fieldnames</code> function.</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">fieldnames</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span>
</span><span class="go">3-element Array{Symbol,1}:
</span><span class="go"> :bar
</span><span class="go"> :baz
</span><span class="go"> :qux
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>You can access the field values of a composite object using the traditional <code>foo.bar</code> notation:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">foo</span><span class="o">.</span><span class="n">bar</span><span>
</span><span class="go">&quot;Hello, world.&quot;
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">foo</span><span class="o">.</span><span class="n">baz</span><span>
</span><span class="go">23
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">foo</span><span class="o">.</span><span class="n">qux</span><span>
</span><span class="go">1.5
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>You can also change the values as one would expect:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">foo</span><span class="o">.</span><span class="n">qux</span><span> </span><span class="o">=</span><span> </span><span class="mi">2</span><span>
</span><span class="go">2
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">foo</span><span class="o">.</span><span class="n">bar</span><span> </span><span class="o">=</span><span> </span><span class="mi">1</span><span class="o">/</span><span class="o">/</span><span class="mi">2</span><span>
</span><span class="go">1//2
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Composite types with no fields are singletons; there can be only one instance of such types:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span class="go">type NoFields
</span><span class="go">end
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">is</span><span class="p">(</span><span class="n">NoFields</span><span class="p">(</span><span class="p">)</span><span class="p">,</span><span> </span><span class="n">NoFields</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="go">true
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The <code>is</code> function confirms that the &quot;two&quot; constructed instances of <code>NoFields</code> are actually one and the same. Singleton types are described in further detail <a href="@ref">below</a>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>There is much more to say about how instances of composite types are created, but that discussion depends on both <a href="types.html#Parametric-Types-1">Parametric Types</a> and on <a href="methods.html#Methods-1">Methods</a>, and is sufficiently important to be addressed in its own section: <a href="@ref">Constructors</a>.</p><a id="Immutable-Composite-Types-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Immutable Composite Types</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>It is also possible to define <em>immutable</em> composite types by using the keyword <code>immutable</code> instead of <code>type</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">immutable</span><span> </span><span class="n">Complex</span><span>
</span><span>  </span><span class="n">real</span><span class="p">:</span><span class="p">:</span><span class="kt">Float64</span><span>
</span><span>  </span><span class="n">imag</span><span class="p">:</span><span class="p">:</span><span class="kt">Float64</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Such types behave much like other composite types, except that instances of them cannot be modified. Immutable types have several advantages:</p><div class="mdnote debug">Base.Markdown.List</div><ul><li><p>They are more efficient in some cases. Types like the <code>Complex</code> example above can be packed efficiently into arrays, and in some cases the compiler is able to avoid allocating immutable objects entirely.</p></li><li><p>It is not possible to violate the invariants provided by the type&#39;s constructors.</p></li><li><p>Code using immutable objects can be easier to reason about.</p></li></ul><div class="mdnote debug">Base.Markdown.Paragraph</div><p>An immutable object might contain mutable objects, such as arrays, as fields. Those contained objects will remain mutable; only the fields of the immutable object itself cannot be changed to point to different objects.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>A useful way to think about immutable composites is that each instance is associated with specific field values – the field values alone tell you everything about the object. In contrast, a mutable object is like a little container that might hold different values over time, and so is not identified with specific field values. In deciding whether to make a type immutable, ask whether two instances with the same field values would be considered identical, or if they might need to change independently over time. If they would be considered identical, the type should probably be immutable.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>To recap, two essential properties define immutability in Julia:</p><div class="mdnote debug">Base.Markdown.List</div><ul><li><p>An object with an immutable type is passed around (both in assignment statements and in function calls) by copying, whereas a mutable type is passed around by reference.</p></li><li><p>It is not permitted to modify the fields of a composite immutable type.</p></li></ul><div class="mdnote debug">Base.Markdown.Paragraph</div><p>It is instructive, particularly for readers whose background is C/C++, to consider why these two properties go hand in hand.  If they were separated, i.e., if the fields of objects passed around by copying could be modified, then it would become more difficult to reason about certain instances of generic code.  For example, suppose <code>x</code> is a function argument of an abstract type, and suppose that the function changes a field: <code>x.isprocessed = true</code>.  Depending on whether <code>x</code> is passed by copying or by reference, this statement may or may not alter the actual argument in the calling routine.  Julia sidesteps the possibility of creating functions with unknown effects in this scenario by forbidding modification of fields of objects passed around by copying.</p><a id="Declared-Types-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Declared Types</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The three kinds of types discussed in the previous three sections are actually all closely related. They share the same key properties:</p><div class="mdnote debug">Base.Markdown.List</div><ul><li><p>They are explicitly declared.</p></li><li><p>They have names.</p></li><li><p>They have explicitly declared supertypes.</p></li><li><p>They may have parameters.</p></li></ul><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Because of these shared properties, these types are internally represented as instances of the same concept, <code>DataType</code>, which is the type of any of these types:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="n">Real</span><span class="p">)</span><span>
</span><span class="go">DataType
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="kt">Int</span><span class="p">)</span><span>
</span><span class="go">DataType
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>A <code>DataType</code> may be abstract or concrete. If it is concrete, it has a specified size, storage layout, and (optionally) field names. Thus a bits type is a <code>DataType</code> with nonzero size, but no field names. A composite type is a <code>DataType</code> that has field names or is empty (zero size).</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Every concrete value in the system is an instance of some <code>DataType</code>.</p><a id="Type-Unions-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Type Unions</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>A type union is a special abstract type which includes as objects all instances of any of its argument types, constructed using the special <code>Union</code> function:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">IntOrString</span><span> </span><span class="o">=</span><span> </span><span class="n">Union</span><span class="p">{</span><span class="kt">Int</span><span class="p">,</span><span class="n">AbstractString</span><span class="p">}</span><span>
</span><span class="go">Union{AbstractString,Int64}
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="mi">1</span><span> </span><span class="p">:</span><span class="p">:</span><span> </span><span class="n">IntOrString</span><span>
</span><span class="go">1
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="s">&quot;</span><span class="s">Hello!</span><span class="s">&quot;</span><span> </span><span class="p">:</span><span class="p">:</span><span> </span><span class="n">IntOrString</span><span>
</span><span class="go">&quot;Hello!&quot;
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="mf">1.0</span><span> </span><span class="p">:</span><span class="p">:</span><span> </span><span class="n">IntOrString</span><span>
</span><span class="go">ERROR: type: typeassert: expected Union{AbstractString,Int64}, got Float64
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The compilers for many languages have an internal union construct for reasoning about types; Julia simply exposes it to the programmer.</p><a id="Parametric-Types-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Parametric Types</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>An important and powerful feature of Julia&#39;s type system is that it is parametric: types can take parameters, so that type declarations actually introduce a whole family of new types – one for each possible combination of parameter values. There are many languages that support some version of <a href="https://en.wikipedia.org/wiki/Generic_programming">generic programming</a>, wherein data structures and algorithms to manipulate them may be specified without specifying the exact types involved. For example, some form of generic programming exists in ML, Haskell, Ada, Eiffel, C++, Java, C#, F#, and Scala, just to name a few. Some of these languages support true parametric polymorphism (e.g. ML, Haskell, Scala), while others support ad-hoc, template-based styles of generic programming (e.g. C++, Java). With so many different varieties of generic programming and parametric types in various languages, we won&#39;t even attempt to compare Julia&#39;s parametric types to other languages, but will instead focus on explaining Julia&#39;s system in its own right. We will note, however, that because Julia is a dynamically typed language and doesn&#39;t need to make all type decisions at compile time, many traditional difficulties encountered in static parametric type systems can be relatively easily handled.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>All declared types (the <code>DataType</code> variety) can be parameterized, with the same syntax in each case. We will discuss them in the following order: first, parametric composite types, then parametric abstract types, and finally parametric bits types.</p><a id="Parametric-Composite-Types-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>Parametric Composite Types</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Type parameters are introduced immediately after the type name, surrounded by curly braces:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">type</span><span class="nc"> </span><span class="nc">Point</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span>
</span><span>  </span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">T</span><span>
</span><span>  </span><span class="n">y</span><span class="p">:</span><span class="p">:</span><span class="n">T</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This declaration defines a new parametric type, <code>Point{T}</code>, holding two &quot;coordinates&quot; of type <code>T</code>. What, one may ask, is <code>T</code>? Well, that&#39;s precisely the point of parametric types: it can be any type at all (or a value of any bits type, actually, although here it&#39;s clearly used as a type). <code>Point{Float64}</code> is a concrete type equivalent to the type defined by replacing <code>T</code> in the definition of <code>Point</code> with <a href="../stdlib/numbers.html#Core.Float64"><code>Float64</code></a>. Thus, this single declaration actually declares an unlimited number of types: <code>Point{Float64}</code>, <code>Point{AbstractString}</code>, <code>Point{Int64}</code>, etc. Each of these is now a usable concrete type:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Point</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span><span>
</span><span class="go">Point{Float64}
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Point</span><span class="p">{</span><span class="n">AbstractString</span><span class="p">}</span><span>
</span><span class="go">Point{AbstractString}
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The type <code>Point{Float64}</code> is a point whose coordinates are 64-bit floating-point values, while the type <code>Point{AbstractString}</code> is a &quot;point&quot; whose &quot;coordinates&quot; are string objects (see <a href="@ref">Strings</a>). However, <code>Point</code> itself is also a valid type object:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Point</span><span>
</span><span class="go">Point{T}
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Here the <code>T</code> is the dummy type symbol used in the original declaration of <code>Point</code>. What does <code>Point</code> by itself mean? It is an abstract type that contains all the specific instances <code>Point{Float64}</code>, <code>Point{AbstractString}</code>, etc.:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Point</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Point</span><span>
</span><span class="go">true
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Point</span><span class="p">{</span><span class="n">AbstractString</span><span class="p">}</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Point</span><span>
</span><span class="go">true
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Other types, of course, are not subtypes of it:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="kt">Float64</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Point</span><span>
</span><span class="go">false
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">AbstractString</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Point</span><span>
</span><span class="go">false
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Concrete <code>Point</code> types with different values of <code>T</code> are never subtypes of each other:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Point</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Point</span><span class="p">{</span><span class="kt">Int64</span><span class="p">}</span><span>
</span><span class="go">false
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Point</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Point</span><span class="p">{</span><span class="n">Real</span><span class="p">}</span><span>
</span><span class="go">false
</span></code></pre><div class="mdnote debug">Base.Markdown.Admonition</div><div class="admonition warning"><div class="admonition-title"></div><div class="admonition-text"><p>This last point is <em>very</em> important: even though <code>Float64 &lt;: Real</code> we <strong>DO NOT</strong> have <code>Point{Float64} &lt;: Point{Real}</code>.</p></div></div><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In other words, in the parlance of type theory, Julia&#39;s type parameters are <em>invariant</em>, rather than being covariant (or even contravariant). This is for practical reasons: while any instance of <code>Point{Float64}</code> may conceptually be like an instance of <code>Point{Real}</code> as well, the two types have different representations in memory:</p><div class="mdnote debug">Base.Markdown.List</div><ul><li><p>An instance of <code>Point{Float64}</code> can be represented compactly and efficiently as an immediate pair of 64-bit values;</p></li><li><p>An instance of <code>Point{Real}</code> must be able to hold any pair of instances of <code>Real</code>. Since objects that are instances of <code>Real</code> can be of arbitrary size and structure, in practice an instance of <code>Point{Real}</code> must be represented as a pair of pointers to individually allocated <code>Real</code> objects.</p></li></ul><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The efficiency gained by being able to store <code>Point{Float64}</code> objects with immediate values is magnified enormously in the case of arrays: an <code>Array{Float64}</code> can be stored as a contiguous memory block of 64-bit floating-point values, whereas an <code>Array{Real}</code> must be an array of pointers to individually allocated <code>Real</code> objects – which may well be <a href="https://en.wikipedia.org/wiki/Object_type_%28object-oriented_programming%29#Boxing">boxed</a> 64-bit floating-point values, but also might be arbitrarily large, complex objects, which are declared to be implementations of the <code>Real</code> abstract type.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Since <code>Point{Float64}</code> is not a subtype of <code>Point{Real}</code>, the following method can&#39;t be applied to arguments of type <code>Point{Float64}</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">function</span><span class="nf"> </span><span class="nf">norm</span><span class="p">(</span><span class="n">p</span><span class="p">:</span><span class="p">:</span><span class="n">Point</span><span class="p">{</span><span class="n">Real</span><span class="p">}</span><span class="p">)</span><span>
</span><span>   </span><span class="n">sqrt</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span> </span><span class="o">+</span><span> </span><span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The correct way to define a method that accepts all arguments of type <code>Point{T}</code> where <code>T</code> is a subtype of <code>Real</code> is:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">function</span><span class="nf"> </span><span class="nf">norm</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Real</span><span class="p">}</span><span class="p">(</span><span class="n">p</span><span class="p">:</span><span class="p">:</span><span class="n">Point</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">)</span><span>
</span><span>   </span><span class="n">sqrt</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span> </span><span class="o">+</span><span> </span><span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>More examples will be discussed later in <a href="methods.html#Methods-1">Methods</a>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>How does one construct a <code>Point</code> object? It is possible to define custom constructors for composite types, which will be discussed in detail in <a href="@ref">Constructors</a>, but in the absence of any special constructor declarations, there are two default ways of creating new composite objects, one in which the type parameters are explicitly given and the other in which they are implied by the arguments to the object constructor.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Since the type <code>Point{Float64}</code> is a concrete type equivalent to <code>Point</code> declared with <a href="../stdlib/numbers.html#Core.Float64"><code>Float64</code></a> in place of <code>T</code>, it can be applied as a constructor accordingly:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Point</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">)</span><span>
</span><span class="go">Point{Float64}(1.0,2.0)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span><span>
</span><span class="go">Point{Float64}
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>For the default constructor, exactly one argument must be supplied for each field:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Point</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span><span>
</span><span class="go">ERROR: MethodError: Cannot `convert` an object of type Float64 to an object of type Point{Float64}
</span><span class="go">This may have arisen from a call to the constructor Point{Float64}(...),
</span><span class="go">since type constructors fall back to convert methods.
</span><span class="go"> in Point{Float64}(::Float64) at ./sysimg.jl:53
</span><span class="go"> ...
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Point</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">,</span><span class="mf">3.0</span><span class="p">)</span><span>
</span><span class="go">ERROR: MethodError: no method matching Point{Float64}(::Float64, ::Float64, ::Float64)
</span><span class="go">Closest candidates are:
</span><span class="go">  Point{Float64}{T}(::Any, ::Any)
</span><span class="go">  Point{Float64}{T}(::Any)
</span><span class="go"> ...
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Only one default constructor is generated for parametric types, since overriding it is not possible. This constructor accepts any arguments and converts them to the field types.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In many cases, it is redundant to provide the type of <code>Point</code> object one wants to construct, since the types of arguments to the constructor call already implicitly provide type information. For that reason, you can also apply <code>Point</code> itself as a constructor, provided that the implied value of the parameter type <code>T</code> is unambiguous:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Point</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">)</span><span>
</span><span class="go">Point{Float64}(1.0,2.0)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span><span>
</span><span class="go">Point{Float64}
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Point</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span>
</span><span class="go">Point{Int64}(1,2)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span><span>
</span><span class="go">Point{Int64}
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In the case of <code>Point</code>, the type of <code>T</code> is unambiguously implied if and only if the two arguments to <code>Point</code> have the same type. When this isn&#39;t the case, the constructor will fail with a <a href="../stdlib/base.html#Base.MethodError"><code>MethodError</code></a>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Point</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mf">2.5</span><span class="p">)</span><span>
</span><span class="go">ERROR: MethodError: no method matching Point{T}(::Int64, ::Float64)
</span><span class="go">...
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Constructor methods to appropriately handle such mixed cases can be defined, but that will not be discussed until later on in <a href="@ref">Constructors</a>.</p><a id="Parametric-Abstract-Types-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>Parametric Abstract Types</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Parametric abstract type declarations declare a collection of abstract types, in much the same way:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">abstract</span><span class="nc"> </span><span class="nc">Pointy</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>With this declaration, <code>Pointy{T}</code> is a distinct abstract type for each type or integer value of <code>T</code>. As with parametric composite types, each such instance is a subtype of <code>Pointy</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Pointy</span><span class="p">{</span><span class="kt">Int64</span><span class="p">}</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Pointy</span><span>
</span><span class="go">true
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Pointy</span><span class="p">{</span><span class="mi">1</span><span class="p">}</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Pointy</span><span>
</span><span class="go">true
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Parametric abstract types are invariant, much as parametric composite types are:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Pointy</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Pointy</span><span class="p">{</span><span class="n">Real</span><span class="p">}</span><span>
</span><span class="go">false
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Pointy</span><span class="p">{</span><span class="n">Real</span><span class="p">}</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Pointy</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span><span>
</span><span class="go">false
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Much as plain old abstract types serve to create a useful hierarchy of types over concrete types, parametric abstract types serve the same purpose with respect to parametric composite types. We could, for example, have declared <code>Point{T}</code> to be a subtype of <code>Pointy{T}</code> as follows:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">type</span><span class="nc"> </span><span class="nc">Point</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Pointy</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span>
</span><span>  </span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">T</span><span>
</span><span>  </span><span class="n">y</span><span class="p">:</span><span class="p">:</span><span class="n">T</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Given such a declaration, for each choice of <code>T</code>, we have <code>Point{T}</code> as a subtype of <code>Pointy{T}</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Point</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Pointy</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span><span>
</span><span class="go">true
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Point</span><span class="p">{</span><span class="n">Real</span><span class="p">}</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Pointy</span><span class="p">{</span><span class="n">Real</span><span class="p">}</span><span>
</span><span class="go">true
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Point</span><span class="p">{</span><span class="n">AbstractString</span><span class="p">}</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Pointy</span><span class="p">{</span><span class="n">AbstractString</span><span class="p">}</span><span>
</span><span class="go">true
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This relationship is also invariant:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Point</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Pointy</span><span class="p">{</span><span class="n">Real</span><span class="p">}</span><span>
</span><span class="go">false
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>What purpose do parametric abstract types like <code>Pointy</code> serve? Consider if we create a point-like implementation that only requires a single coordinate because the point is on the diagonal line <em>x = y</em>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">type</span><span class="nc"> </span><span class="nc">DiagPoint</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Pointy</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span>
</span><span>  </span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">T</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Now both <code>Point{Float64}</code> and <code>DiagPoint{Float64}</code> are implementations of the <code>Pointy{Float64}</code> abstraction, and similarly for every other possible choice of type <code>T</code>. This allows programming to a common interface shared by all <code>Pointy</code> objects, implemented for both <code>Point</code> and <code>DiagPoint</code>. This cannot be fully demonstrated, however, until we have introduced methods and dispatch in the next section, <a href="methods.html#Methods-1">Methods</a>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>There are situations where it may not make sense for type parameters to range freely over all possible types. In such situations, one can constrain the range of <code>T</code> like so:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">abstract</span><span class="nc"> </span><span class="nc">Pointy</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Real</span><span class="p">}</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>With such a declaration, it is acceptable to use any type that is a subtype of <code>Real</code> in place of <code>T</code>, but not types that are not subtypes of <code>Real</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Pointy</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span><span>
</span><span class="go">Pointy{Float64}
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Pointy</span><span class="p">{</span><span class="n">Real</span><span class="p">}</span><span>
</span><span class="go">Pointy{Real}
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Pointy</span><span class="p">{</span><span class="n">AbstractString</span><span class="p">}</span><span>
</span><span class="go">ERROR: TypeError: Pointy: in T, expected T&lt;:Real, got Type{AbstractString}
</span><span class="go"> ...
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Pointy</span><span class="p">{</span><span class="mi">1</span><span class="p">}</span><span>
</span><span class="go">ERROR: TypeError: Pointy: in T, expected T&lt;:Real, got Int64
</span><span class="go"> ...
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Type parameters for parametric composite types can be restricted in the same manner:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">type</span><span class="nc"> </span><span class="nc">Point</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Real</span><span class="p">}</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Pointy</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span>
</span><span>  </span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">T</span><span>
</span><span>  </span><span class="n">y</span><span class="p">:</span><span class="p">:</span><span class="n">T</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>To give a real-world example of how all this parametric type machinery can be useful, here is the actual definition of Julia&#39;s <code>Rational</code> immutable type (except that we omit the constructor here for simplicity), representing an exact ratio of integers:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">immutable</span><span> </span><span class="n">Rational</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Integer</span><span class="p">}</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Real</span><span>
</span><span>  </span><span class="n">num</span><span class="p">:</span><span class="p">:</span><span class="n">T</span><span>
</span><span>  </span><span class="n">den</span><span class="p">:</span><span class="p">:</span><span class="n">T</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>It only makes sense to take ratios of integer values, so the parameter type <code>T</code> is restricted to being a subtype of <code>Integer</code>, and a ratio of integers represents a value on the real number line, so any <code>Rational</code> is an instance of the <code>Real</code> abstraction.</p><a id="Tuple-Types-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>Tuple Types</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Tuples are an abstraction of the arguments of a function – without the function itself. The salient aspects of a function&#39;s arguments are their order and their types. Therefore a tuple type is similar to a parameterized immutable type where each parameter is the type of one field. For example, a 2-element tuple type resembles the following immutable type:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">immutable</span><span> </span><span class="n">Tuple2</span><span class="p">{</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">}</span><span>
</span><span>  </span><span class="n">a</span><span class="p">:</span><span class="p">:</span><span class="n">A</span><span>
</span><span>  </span><span class="n">b</span><span class="p">:</span><span class="p">:</span><span class="n">B</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>However, there are three key differences:</p><div class="mdnote debug">Base.Markdown.List</div><ul><li><p>Tuple types may have any number of parameters.</p></li><li><p>Tuple types are <em>covariant</em> in their parameters: <code>Tuple{Int}</code> is a subtype of <code>Tuple{Any}</code>. Therefore <code>Tuple{Any}</code> is considered an abstract type, and tuple types are only concrete if their parameters are.</p></li><li><p>Tuples do not have field names; fields are only accessed by index.</p></li></ul><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Tuple values are written with parentheses and commas. When a tuple is constructed, an appropriate tuple type is generated on demand:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;</span><span class="s">foo</span><span class="s">&quot;</span><span class="p">,</span><span class="mf">2.5</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="go">Tuple{Int64,String,Float64}
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Note the implications of covariance:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Tuple</span><span class="p">{</span><span class="kt">Int</span><span class="p">,</span><span class="n">AbstractString</span><span class="p">}</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Tuple</span><span class="p">{</span><span class="n">Real</span><span class="p">,</span><span class="kt">Any</span><span class="p">}</span><span>
</span><span class="go">true
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Tuple</span><span class="p">{</span><span class="kt">Int</span><span class="p">,</span><span class="n">AbstractString</span><span class="p">}</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Tuple</span><span class="p">{</span><span class="n">Real</span><span class="p">,</span><span class="n">Real</span><span class="p">}</span><span>
</span><span class="go">false
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Tuple</span><span class="p">{</span><span class="kt">Int</span><span class="p">,</span><span class="n">AbstractString</span><span class="p">}</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Tuple</span><span class="p">{</span><span class="n">Real</span><span class="p">,</span><span class="p">}</span><span>
</span><span class="go">false
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Intuitively, this corresponds to the type of a function&#39;s arguments being a subtype of the function&#39;s signature (when the signature matches).</p><a id="Vararg-Tuple-Types-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>Vararg Tuple Types</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The last parameter of a tuple type can be the special type <code>Vararg</code>, which denotes any number of trailing elements:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">isa</span><span class="p">(</span><span class="p">(</span><span class="s">&quot;</span><span class="s">1</span><span class="s">&quot;</span><span class="p">,</span><span class="p">)</span><span class="p">,</span><span> </span><span class="n">Tuple</span><span class="p">{</span><span class="n">AbstractString</span><span class="p">,</span><span class="n">Vararg</span><span class="p">{</span><span class="kt">Int</span><span class="p">}</span><span class="p">}</span><span class="p">)</span><span>
</span><span class="go">true
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">isa</span><span class="p">(</span><span class="p">(</span><span class="s">&quot;</span><span class="s">1</span><span class="s">&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="p">,</span><span> </span><span class="n">Tuple</span><span class="p">{</span><span class="n">AbstractString</span><span class="p">,</span><span class="n">Vararg</span><span class="p">{</span><span class="kt">Int</span><span class="p">}</span><span class="p">}</span><span class="p">)</span><span>
</span><span class="go">true
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">isa</span><span class="p">(</span><span class="p">(</span><span class="s">&quot;</span><span class="s">1</span><span class="s">&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="p">,</span><span> </span><span class="n">Tuple</span><span class="p">{</span><span class="n">AbstractString</span><span class="p">,</span><span class="n">Vararg</span><span class="p">{</span><span class="kt">Int</span><span class="p">}</span><span class="p">}</span><span class="p">)</span><span>
</span><span class="go">true
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">isa</span><span class="p">(</span><span class="p">(</span><span class="s">&quot;</span><span class="s">1</span><span class="s">&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mf">3.0</span><span class="p">)</span><span class="p">,</span><span> </span><span class="n">Tuple</span><span class="p">{</span><span class="n">AbstractString</span><span class="p">,</span><span class="n">Vararg</span><span class="p">{</span><span class="kt">Int</span><span class="p">}</span><span class="p">}</span><span class="p">)</span><span>
</span><span class="go">false
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Notice that <code>Vararg{T}</code> corresponds to zero or more elements of type <code>T</code>. Vararg tuple types are used to represent the arguments accepted by varargs methods (see <a href="functions.html#Varargs-Functions-1">Varargs Functions</a>).</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The type <code>Vararg{T,N}</code> corresponds to exactly <code>N</code> elements of type <code>T</code>.  <code>NTuple{N,T}</code> is a convenient alias for <code>Tuple{Vararg{T,N}}</code>, i.e. a tuple type containing exactly <code>N</code> elements of type <code>T</code>.</p><a id="Singleton-Types-1"></a><div class="mdnote debug">Base.Markdown.Header{4}</div><h4>Singleton Types</h4><div class="mdnote debug">Base.Markdown.Paragraph</div><p>There is a special kind of abstract parametric type that must be mentioned here: singleton types. For each type, <code>T</code>, the &quot;singleton type&quot; <code>Type{T}</code> is an abstract type whose only instance is the object <code>T</code>. Since the definition is a little difficult to parse, let&#39;s look at some examples:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">isa</span><span class="p">(</span><span class="kt">Float64</span><span class="p">,</span><span> </span><span class="n">Type</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span><span class="p">)</span><span>
</span><span class="go">true
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">isa</span><span class="p">(</span><span class="n">Real</span><span class="p">,</span><span> </span><span class="n">Type</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span><span class="p">)</span><span>
</span><span class="go">false
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">isa</span><span class="p">(</span><span class="n">Real</span><span class="p">,</span><span> </span><span class="n">Type</span><span class="p">{</span><span class="n">Real</span><span class="p">}</span><span class="p">)</span><span>
</span><span class="go">true
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">isa</span><span class="p">(</span><span class="kt">Float64</span><span class="p">,</span><span> </span><span class="n">Type</span><span class="p">{</span><span class="n">Real</span><span class="p">}</span><span class="p">)</span><span>
</span><span class="go">false
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In other words, <a href="../stdlib/base.html#Core.isa"><code>isa(A,Type{B})</code></a> is true if and only if <code>A</code> and <code>B</code> are the same object and that object is a type. Without the parameter, <code>Type</code> is simply an abstract type which has all type objects as its instances, including, of course, singleton types:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">isa</span><span class="p">(</span><span class="n">Type</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span><span class="p">,</span><span class="n">Type</span><span class="p">)</span><span>
</span><span class="go">true
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">isa</span><span class="p">(</span><span class="kt">Float64</span><span class="p">,</span><span class="n">Type</span><span class="p">)</span><span>
</span><span class="go">true
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">isa</span><span class="p">(</span><span class="n">Real</span><span class="p">,</span><span class="n">Type</span><span class="p">)</span><span>
</span><span class="go">true
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Any object that is not a type is not an instance of <code>Type</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">isa</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">Type</span><span class="p">)</span><span>
</span><span class="go">false
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">isa</span><span class="p">(</span><span class="s">&quot;</span><span class="s">foo</span><span class="s">&quot;</span><span class="p">,</span><span class="n">Type</span><span class="p">)</span><span>
</span><span class="go">false
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Until we discuss <a href="methods.html#Parametric-Methods-1">Parametric Methods</a> and <a href="@ref">conversions</a>, it is difficult to explain the utility of the singleton type construct, but in short, it allows one to specialize function behavior on specific type <em>values</em>. This is useful for writing methods (especially parametric ones) whose behavior depends on a type that is given as an explicit argument rather than implied by the type of one of its arguments.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>A few popular languages have singleton types, including Haskell, Scala and Ruby. In general usage, the term &quot;singleton type&quot; refers to a type whose only instance is a single value. This meaning applies to Julia&#39;s singleton types, but with that caveat that only type objects have singleton types.</p><a id="Parametric-Bits-Types-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>Parametric Bits Types</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Bits types can also be declared parametrically. For example, pointers are represented as boxed bits types which would be declared in Julia like this:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="c"># 32-bit system:</span><span>
</span><span class="k">bitstype</span><span> </span><span class="mi">32</span><span> </span><span class="n">Ptr</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span>
</span><span>
</span><span class="c"># 64-bit system:</span><span>
</span><span class="k">bitstype</span><span> </span><span class="mi">64</span><span> </span><span class="n">Ptr</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The slightly odd feature of these declarations as compared to typical parametric composite types, is that the type parameter <code>T</code> is not used in the definition of the type itself – it is just an abstract tag, essentially defining an entire family of types with identical structure, differentiated only by their type parameter. Thus, <code>Ptr{Float64}</code> and <code>Ptr{Int64}</code> are distinct types, even though they have identical representations. And of course, all specific pointer types are subtype of the umbrella <code>Ptr</code> type:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Ptr</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Ptr</span><span>
</span><span class="go">true
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Ptr</span><span class="p">{</span><span class="kt">Int64</span><span class="p">}</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Ptr</span><span>
</span><span class="go">true
</span></code></pre><a id="Type-Aliases-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Type Aliases</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Sometimes it is convenient to introduce a new name for an already expressible type. For such occasions, Julia provides the <code>typealias</code> mechanism. For example, <code>UInt</code> is type aliased to either <code>UInt32</code> or <code>UInt64</code> as is appropriate for the size of pointers on the system:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span class="go"># 32-bit system:
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">UInt</span><span>
</span><span class="go">UInt32
</span><span class="go">
</span><span class="go"># 64-bit system:
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">UInt</span><span>
</span><span class="go">UInt64
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This is accomplished via the following code in <code>base/boot.jl</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">if</span><span> </span><span class="nb">is</span><span class="p">(</span><span class="kt">Int</span><span class="p">,</span><span class="kt">Int64</span><span class="p">)</span><span>
</span><span>    </span><span class="k">typealias</span><span class="nc"> </span><span class="nc">UInt</span><span> </span><span class="n">UInt64</span><span>
</span><span class="k">else</span><span>
</span><span>    </span><span class="k">typealias</span><span class="nc"> </span><span class="nc">UInt</span><span> </span><span class="n">UInt32</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Of course, this depends on what <code>Int</code> is aliased to – but that is predefined to be the correct type – either <code>Int32</code> or <code>Int64</code>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>For parametric types, <code>typealias</code> can be convenient for providing names for cases where some of the parameter choices are fixed. Julia&#39;s arrays have type <code>Array{T,N}</code> where <code>T</code> is the element type and <code>N</code> is the number of array dimensions. For convenience, writing <code>Array{Float64}</code> allows one to specify the element type without specifying the dimension:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Array</span><span>
</span><span class="go">true
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>However, there is no way to equally simply restrict just the dimension but not the element type. Yet, one often needs to ensure an object is a vector or a matrix (imposing restrictions on the number of dimensions). For that reason, the following type aliases are provided:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">typealias</span><span class="nc"> </span><span class="nc">Vector</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span> </span><span class="n">Array</span><span class="p">{</span><span class="n">T</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span><span>
</span><span class="k">typealias</span><span class="nc"> </span><span class="nc">Matrix</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span> </span><span class="n">Array</span><span class="p">{</span><span class="n">T</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Writing <code>Vector{Float64}</code> is equivalent to writing <code>Array{Float64,1}</code>, and the umbrella type <code>Vector</code> has as instances all <code>Array</code> objects where the second parameter – the number of array dimensions – is 1, regardless of what the element type is. In languages where parametric types must always be specified in full, this is not especially helpful, but in Julia, this allows one to write just <code>Matrix</code> for the abstract type including all two-dimensional dense arrays of any element type.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This declaration of <code>Vector</code> creates a subtype relation <code>Vector{Int} &lt;: Vector</code>.  However, it is not always the case that a parametric <code>typealias</code> statement creates such a relation; for example, the statement:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">typealias</span><span class="nc"> </span><span class="nc">AA</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span> </span><span class="n">Array</span><span class="p">{</span><span class="n">Array</span><span class="p">{</span><span class="n">T</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>does not create the relation <code>AA{Int} &lt;: AA</code>.  The reason is that <code>Array{Array{T,1},1}</code> is not an abstract type at all; in fact, it is a concrete type describing a 1-dimensional array in which each entry is an object of type <code>Array{T,1}</code> for some value of <code>T</code>.</p><a id="Operations-on-Types-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Operations on Types</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Since types in Julia are themselves objects, ordinary functions can operate on them. Some functions that are particularly useful for working with or exploring types have already been introduced, such as the <code>&lt;:</code> operator, which indicates whether its left hand operand is a subtype of its right hand operand.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The <code>isa</code> function tests if an object is of a given type and returns true or false:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">isa</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="kt">Int</span><span class="p">)</span><span>
</span><span class="go">true
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">isa</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">AbstractFloat</span><span class="p">)</span><span>
</span><span class="go">false
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The <a href="../stdlib/base.html#Core.typeof"><code>typeof()</code></a> function, already used throughout the manual in examples, returns the type of its argument. Since, as noted above, types are objects, they also have types, and we can ask what their types are:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="n">Rational</span><span class="p">)</span><span>
</span><span class="go">DataType
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="n">Union</span><span class="p">{</span><span class="n">Real</span><span class="p">,</span><span class="kt">Float64</span><span class="p">,</span><span class="n">Rational</span><span class="p">}</span><span class="p">)</span><span>
</span><span class="go">DataType
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="n">Union</span><span class="p">{</span><span class="n">Real</span><span class="p">,</span><span class="n">String</span><span class="p">}</span><span class="p">)</span><span>
</span><span class="go">Union
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>What if we repeat the process? What is the type of a type of a type? As it happens, types are all composite values and thus all have a type of <code>DataType</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="n">DataType</span><span class="p">)</span><span>
</span><span class="go">DataType
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="n">Union</span><span class="p">)</span><span>
</span><span class="go">DataType
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p><code>DataType</code> is its own type.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Another operation that applies to some types is <a href="../stdlib/base.html#Base.supertype"><code>supertype()</code></a>, which reveals a type&#39;s supertype. Only declared types (<code>DataType</code>) have unambiguous supertypes:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">supertype</span><span class="p">(</span><span class="kt">Float64</span><span class="p">)</span><span>
</span><span class="go">AbstractFloat
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">supertype</span><span class="p">(</span><span class="n">Number</span><span class="p">)</span><span>
</span><span class="go">Any
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">supertype</span><span class="p">(</span><span class="n">AbstractString</span><span class="p">)</span><span>
</span><span class="go">Any
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">supertype</span><span class="p">(</span><span class="kt">Any</span><span class="p">)</span><span>
</span><span class="go">Any
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>If you apply <a href="../stdlib/base.html#Base.supertype"><code>supertype()</code></a> to other type objects (or non-type objects), a <a href="../stdlib/base.html#Base.MethodError"><code>MethodError</code></a> is raised:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">supertype</span><span class="p">(</span><span class="n">Union</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="kt">Int64</span><span class="p">}</span><span class="p">)</span><span>
</span><span class="go">ERROR: `supertype` has no method matching supertype(::Type{Union{Float64,Int64}})
</span></code></pre><a id="\"Value-types\"-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>&quot;Value types&quot;</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In Julia, you can&#39;t dispatch on a <em>value</em> such as <code>true</code> or <code>false</code>. However, you can dispatch on parametric types, and Julia allows you to include &quot;plain bits&quot; values (Types, Symbols, Integers, floating-point numbers, tuples, etc.) as type parameters.  A common example is the dimensionality parameter in <code>Array{T,N}</code>, where <code>T</code> is a type (e.g., <code>Float64</code>) but <code>N</code> is just an <code>Int</code>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>You can create your own custom types that take values as parameters, and use them to control dispatch of custom types. By way of illustration of this idea, let&#39;s introduce a parametric type, <code>Val{T}</code>, which serves as a customary way to exploit this technique for cases where you don&#39;t need a more elaborate hierarchy.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p><code>Val</code> is defined as:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">immutable</span><span> </span><span class="n">Val</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>There is no more to the implementation of <code>Val</code> than this.  Some functions in Julia&#39;s standard library accept <code>Val</code> types as arguments, and you can also use it to write your own functions.  For example:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span class="go">firstlast(::Type{Val{true}}) = &quot;First&quot;
</span><span class="go">firstlast(::Type{Val{false}}) = &quot;Last&quot;
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">firstlast</span><span class="p">(</span><span class="n">Val</span><span class="p">{</span><span class="n">true</span><span class="p">}</span><span class="p">)</span><span>
</span><span class="go">&quot;First&quot;
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">firstlast</span><span class="p">(</span><span class="n">Val</span><span class="p">{</span><span class="n">false</span><span class="p">}</span><span class="p">)</span><span>
</span><span class="go">&quot;Last&quot;
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>For consistency across Julia, the call site should always pass a <code>Val</code><em>type</em> rather than creating an <em>instance</em>, i.e., use <code>foo(Val{:bar})</code> rather than <code>foo(Val{:bar}())</code>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>It&#39;s worth noting that it&#39;s extremely easy to mis-use parametric &quot;value&quot; types, including <code>Val</code>; in unfavorable cases, you can easily end up making the performance of your code much <em>worse</em>.  In particular, you would never want to write actual code as illustrated above.  For more information about the proper (and improper) uses of <code>Val</code>, please read the more extensive discussion in <a href="@ref">the performance tips</a>.</p><a id="Nullable-Types:-Representing-Missing-Values-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Nullable Types: Representing Missing Values</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In many settings, you need to interact with a value of type <code>T</code> that may or may not exist. To handle these settings, Julia provides a parametric type called <code>Nullable{T}</code>, which can be thought of as a specialized container type that can contain either zero or one values. <code>Nullable{T}</code> provides a minimal interface designed to ensure that interactions with missing values are safe. At present, the interface consists of four possible interactions:</p><div class="mdnote debug">Base.Markdown.List</div><ul><li><p>Construct a <a href="../stdlib/base.html#Base.Nullable"><code>Nullable</code></a> object.</p></li><li><p>Check if a <a href="../stdlib/base.html#Base.Nullable"><code>Nullable</code></a> object has a missing value.</p></li><li><p>Access the value of a <a href="../stdlib/base.html#Base.Nullable"><code>Nullable</code></a> object with a guarantee that a <a href="../stdlib/base.html#Base.NullException"><code>NullException</code></a> will be thrown if the object&#39;s value is missing.</p></li><li><p>Access the value of a <a href="../stdlib/base.html#Base.Nullable"><code>Nullable</code></a> object with a guarantee that a default value of type <code>T</code> will be returned if the object&#39;s value is missing.</p></li></ul><a id="Constructing-[Nullable](@ref)-objects-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>Constructing <a href="@ref"><code>Nullable</code></a> objects</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>To construct an object representing a missing value of type <code>T</code>, use the <code>Nullable{T}()</code> function:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">x1</span><span> </span><span class="o">=</span><span> </span><span class="n">Nullable</span><span class="p">{</span><span class="kt">Int64</span><span class="p">}</span><span class="p">(</span><span class="p">)</span><span>
</span><span class="go">Nullable{Int64}()
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">x2</span><span> </span><span class="o">=</span><span> </span><span class="n">Nullable</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span><span class="p">(</span><span class="p">)</span><span>
</span><span class="go">Nullable{Float64}()
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">x3</span><span> </span><span class="o">=</span><span> </span><span class="n">Nullable</span><span class="p">{</span><span class="n">Vector</span><span class="p">{</span><span class="kt">Int64</span><span class="p">}</span><span class="p">}</span><span class="p">(</span><span class="p">)</span><span>
</span><span class="go">Nullable{Array{Int64,1}}()
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>To construct an object representing a non-missing value of type <code>T</code>, use the <code>Nullable(x::T)</code> function:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">x1</span><span> </span><span class="o">=</span><span> </span><span class="n">Nullable</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span>
</span><span class="go">Nullable{Int64}(1)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">x2</span><span> </span><span class="o">=</span><span> </span><span class="n">Nullable</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span><span>
</span><span class="go">Nullable{Float64}(1.0)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">x3</span><span> </span><span class="o">=</span><span> </span><span class="n">Nullable</span><span class="p">(</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span> </span><span class="mi">2</span><span class="p">,</span><span> </span><span class="mi">3</span><span class="p">]</span><span class="p">)</span><span>
</span><span class="go">Nullable{Array{Int64,1}}([1,2,3])
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Note the core distinction between these two ways of constructing a <a href="../stdlib/base.html#Base.Nullable"><code>Nullable</code></a> object: in one style, you provide a type, <code>T</code>, as a function parameter; in the other style, you provide a single value of type <code>T</code> as an argument.</p><a id="Checking-if-a-[Nullable](@ref)-object-has-a-value-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>Checking if a <a href="@ref"><code>Nullable</code></a> object has a value</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>You can check if a <a href="../stdlib/base.html#Base.Nullable"><code>Nullable</code></a> object has any value using <a href="../stdlib/base.html#Base.isnull"><code>isnull()</code></a>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">isnull</span><span class="p">(</span><span class="n">Nullable</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="go">true
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">isnull</span><span class="p">(</span><span class="n">Nullable</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="go">false
</span></code></pre><a id="Safely-accessing-the-value-of-a-[Nullable](@ref)-object-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>Safely accessing the value of a <a href="@ref"><code>Nullable</code></a> object</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>You can safely access the value of a <a href="../stdlib/base.html#Base.Nullable"><code>Nullable</code></a> object using <a href="../stdlib/collections.html#Base.get"><code>get()</code></a>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">get</span><span class="p">(</span><span class="n">Nullable</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="go">ERROR: NullException()
</span><span class="go"> in get(::Nullable{Float64}) at ./nullable.jl:62
</span><span class="go"> ...
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">get</span><span class="p">(</span><span class="n">Nullable</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="go">1.0
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>If the value is not present, as it would be for <code>Nullable{Float64}</code>, a <a href="../stdlib/base.html#Base.NullException"><code>NullException</code></a> error will be thrown. The error-throwing nature of the <a href="../stdlib/collections.html#Base.get"><code>get()</code></a> function ensures that any attempt to access a missing value immediately fails.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In cases for which a reasonable default value exists that could be used when a <a href="../stdlib/base.html#Base.Nullable"><code>Nullable</code></a> object&#39;s value turns out to be missing, you can provide this default value as a second argument to <a href="../stdlib/collections.html#Base.get"><code>get()</code></a>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">get</span><span class="p">(</span><span class="n">Nullable</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span><span class="p">(</span><span class="p">)</span><span class="p">,</span><span> </span><span class="mf">0.0</span><span class="p">)</span><span>
</span><span class="go">0.0
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">get</span><span class="p">(</span><span class="n">Nullable</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span><span class="p">,</span><span> </span><span class="mf">0.0</span><span class="p">)</span><span>
</span><span class="go">1.0
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Note that this default value will automatically be converted to the type of the <a href="../stdlib/base.html#Base.Nullable"><code>Nullable</code></a> object that you attempt to access using the <a href="../stdlib/collections.html#Base.get"><code>get()</code></a> function. For example, in the code shown above the value <code>0</code> would be automatically converted to a <a href="../stdlib/numbers.html#Core.Float64"><code>Float64</code></a> value before being returned. The presence of default replacement values makes it easy to use the <a href="../stdlib/collections.html#Base.get"><code>get()</code></a> function to write type-stable code that interacts with sources of potentially missing values.</p><footer><hr/><a class="previous" href="style-guide.html"><span class="direction">Previous</span><span class="title">Style Guide</span></a><a class="next" href="unicode-input.html"><span class="direction">Next</span><span class="title">Unicode Input</span></a></footer></article></body></html>
