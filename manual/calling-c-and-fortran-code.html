<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Documenter.jl</title><link href="../normalize.css" rel="stylesheet" type="text/css"/><link href="../style.css" rel="stylesheet" type="text/css"/><link href="../highlight.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="../require.js" data-main="../documenter.js"></script><script src="../search-index.js"></script></head><body><nav class="toc"><a href="http://julialang.org/"><img class="logo" src="http://docs.julialang.org/en/release-0.4/_static/julia-logo.svg" alt="\$pkgname.jl logo"/></a><h1>$pkgname.jl</h1><input type="text" placeholder="Search docs"/><ul><li><a class="toctext" href="../index.html">Overview</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../man/guide.html">Guide</a></li><li><a class="toctext" href="../man/examples.html">Examples</a></li><li><a class="toctext" href="../man/syntax.html">Syntax</a></li><li><a class="toctext" href="../man/doctests.html">Doctests</a></li><li><a class="toctext" href="../man/hosting.html">Hosting Documentation</a></li><li><a class="toctext" href="../man/latex.html"><span>$\LaTeX$</span> syntax</a></li><li><a class="toctext" href="../man/internals.html">Package Internals</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../lib/public.html">Public Documentation</a></li><li><a class="toctext" href="../lib/internals.html">Internal Documentation</a></li></ul></li><li><span class="toctext">Dynamic pages</span><ul><li><a class="toctext" href="../dynamic/code.html">Code examples</a></li><li><a class="toctext" href="../dynamic/admonitions.html">Admonitions &amp; Co</a></li><li><a class="toctext" href="../dynamic/styles.html">Demonstrating <em>styles</em> of MD elements</a></li><li><a class="toctext" href="../dynamic/bugs.html">Some existing bugs</a></li></ul></li><li><span class="toctext">JuliaDocs - Manual</span><ul><li><a class="toctext" href="arrays.html">Multi-dimensional Arrays</a></li><li class="current"><a class="toctext" href="calling-c-and-fortran-code.html">Calling C and Fortran Code</a><ul class="internal"><li><a class="toctext" href="#Creating-C-Compatible-Julia-Function-Pointers-1">Creating C-Compatible Julia Function Pointers</a></li><li><a class="toctext" href="#Mapping-C-Types-to-Julia-1">Mapping C Types to Julia</a></li><li><a class="toctext" href="#Mapping-C-Functions-to-Julia-1">Mapping C Functions to Julia</a></li><li><a class="toctext" href="#Some-Examples-of-C-Wrappers-1">Some Examples of C Wrappers</a></li><li><a class="toctext" href="#Garbage-Collection-Safety-1">Garbage Collection Safety</a></li><li><a class="toctext" href="#Non-constant-Function-Specifications-1">Non-constant Function Specifications</a></li><li><a class="toctext" href="#Indirect-Calls-1">Indirect Calls</a></li><li><a class="toctext" href="#Calling-Convention-1">Calling Convention</a></li><li><a class="toctext" href="#Accessing-Global-Variables-1">Accessing Global Variables</a></li><li><a class="toctext" href="#Accessing-Data-through-a-Pointer-1">Accessing Data through a Pointer</a></li><li><a class="toctext" href="#Thread-safety-1">Thread-safety</a></li><li><a class="toctext" href="#More-About-Callbacks-1">More About Callbacks</a></li><li><a class="toctext" href="#C-1">C++</a></li></ul></li><li><a class="toctext" href="complex-and-rational-numbers.html">Complex and Rational Numbers</a></li><li><a class="toctext" href="constructors.html">Constructors</a></li><li><a class="toctext" href="control-flow.html">Control Flow</a></li><li><a class="toctext" href="conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="toctext" href="dates.html">Date and DateTime</a></li><li><a class="toctext" href="documentation.html">Documentation</a></li><li><a class="toctext" href="embedding.html">Embedding Julia</a></li><li><a class="toctext" href="faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="functions.html">Functions</a></li><li><a class="toctext" href="getting-started.html">Getting Started</a></li><li><a class="toctext" href="handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="index.html">The Julia Manual</a></li><li><a class="toctext" href="integers-and-floating-point-numbers.html">Integers and Floating-Point Numbers</a></li><li><a class="toctext" href="interacting-with-julia.html">Interacting With Julia</a></li><li><a class="toctext" href="interfaces.html">Interfaces</a></li><li><a class="toctext" href="introduction.html">Introduction</a></li><li><a class="toctext" href="linear-algebra.html">Linear algebra</a></li><li><a class="toctext" href="mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="metaprogramming.html">Metaprogramming</a></li><li><a class="toctext" href="methods.html">Methods</a></li><li><a class="toctext" href="modules.html">Modules</a></li><li><a class="toctext" href="networking-and-streams.html">Networking and Streams</a></li><li><a class="toctext" href="noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="packages.html">Packages</a></li><li><a class="toctext" href="parallel-computing.html">Parallel Computing</a></li><li><a class="toctext" href="performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="profile.html">Profiling</a></li><li><a class="toctext" href="running-external-programs.html">Running External Programs</a></li><li><a class="toctext" href="stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="strings.html">Strings</a></li><li><a class="toctext" href="style-guide.html">Style Guide</a></li><li><a class="toctext" href="types.html">Types</a></li><li><a class="toctext" href="unicode-input.html">Unicode Input</a></li><li><a class="toctext" href="variables-and-scoping.html">Scope of Variables</a></li><li><a class="toctext" href="variables.html">Variables</a></li><li><a class="toctext" href="workflow-tips.html">Workflow Tips</a></li></ul></li><li><span class="toctext">JuliaDocs - Standard Libary</span><ul><li><a class="toctext" href="../stdlib/arrays.html">Arrays</a></li><li><a class="toctext" href="../stdlib/base.html">Essentials</a></li><li><a class="toctext" href="../stdlib/c.html">C Interface</a></li><li><a class="toctext" href="../stdlib/collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="../stdlib/constants.html">Constants</a></li><li><a class="toctext" href="../stdlib/dates.html">Dates and Time</a></li><li><a class="toctext" href="../stdlib/file.html">Filesystem</a></li><li><a class="toctext" href="../stdlib/index.html">The Julia Standard Library</a></li><li><a class="toctext" href="../stdlib/io-network.html">I/O and Network</a></li><li><a class="toctext" href="../stdlib/libc.html">C Standard Library</a></li><li><a class="toctext" href="../stdlib/libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="../stdlib/linalg.html">Linear Algebra</a></li><li><a class="toctext" href="../stdlib/math.html">Mathematics</a></li><li><a class="toctext" href="../stdlib/numbers.html">Numbers</a></li><li><a class="toctext" href="../stdlib/parallel.html">Tasks and Parallel Computing</a></li><li><a class="toctext" href="../stdlib/pkg.html">Package Manager Functions</a></li><li><a class="toctext" href="../stdlib/profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/punctuation.html">Punctuation</a></li><li><a class="toctext" href="../stdlib/simd-types.html">SIMD Support</a></li><li><a class="toctext" href="../stdlib/sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="../stdlib/stacktraces.html">StackTraces</a></li><li><a class="toctext" href="../stdlib/strings.html">Strings</a></li><li><a class="toctext" href="../stdlib/test.html">Unit Testing</a></li></ul></li><li><span class="toctext">JuliaDocs - DevDocs</span><ul><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/C.html">Developing/debugging Julia&#39;s C code</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../devdocs/julia.html">Documentation of Julia&#39;s Internals</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/promote-op.html">Operator-sensitive promotion</a></li><li><a class="toctext" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/types.html">More about types</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>JuliaDocs - Manual</li><li><a href="calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li></ul><a class="edit-page" href="https://github.com/"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><a id="Calling-C-and-Fortran-Code-1"></a><div class="mdnote debug">Base.Markdown.Header{1}</div><h1>Calling C and Fortran Code</h1><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Though most code can be written in Julia, there are many high-quality, mature libraries for numerical computing already written in C and Fortran. To allow easy use of this existing code, Julia makes it simple and efficient to call C and Fortran functions. Julia has a &quot;no boilerplate&quot; philosophy: functions can be called directly from Julia without any &quot;glue&quot; code, code generation, or compilation – even from the interactive prompt. This is accomplished just by making an appropriate call with <a href="@ref"><code>ccall()</code></a> syntax, which looks like an ordinary function call.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The code to be called must be available as a shared library. Most C and Fortran libraries ship compiled as shared libraries already, but if you are compiling the code yourself using GCC (or Clang), you will need to use the <code>-shared</code> and <code>-fPIC</code> options. The machine instructions generated by Julia&#39;s JIT are the same as a native C call would be, so the resulting overhead is the same as calling a library function from C code. (Non-library function calls in both C and Julia can be inlined and thus may have even less overhead than calls to shared library functions. When both libraries and executables are generated by LLVM, it is possible to perform whole-program optimizations that can even optimize across this boundary, but Julia does not yet support that. In the future, however, it may do so, yielding even greater performance gains.)</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Shared libraries and functions are referenced by a tuple of the form <code>(:function, &quot;library&quot;)</code> or <code>(&quot;function&quot;, &quot;library&quot;)</code> where <code>function</code> is the C-exported function name. <code>library</code> refers to the shared library name: shared libraries available in the (platform-specific) load path will be resolved by name, and if necessary a direct path may be specified.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>A function name may be used alone in place of the tuple (just <code>:function</code> or <code>&quot;function&quot;</code>). In this case the name is resolved within the current process. This form can be used to call C library functions, functions in the Julia runtime, or functions in an application linked to Julia.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>By default, Fortran compilers <a href="https://en.wikipedia.org/wiki/Name_mangling#Name_mangling_in_Fortran">generate mangled names</a> (for example, converting function names to lowercase or uppercase, often appending an underscore), and so to call a Fortran function via <a href="@ref"><code>ccall()</code></a> you must pass the mangled identifier corresponding to the rule followed by your Fortran compiler.  Also, when calling a Fortran function, all inputs must be passed by reference.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Finally, you can use <a href="@ref"><code>ccall()</code></a> to actually generate a call to the library function. Arguments to <a href="@ref"><code>ccall()</code></a> are as follows:</p><div class="mdnote debug">Base.Markdown.List</div><ol><li><p>(:function, &quot;library&quot;) pair (must be a constant, but see below).</p></li><li><p>Return type (see below for mapping the declared C type to Julia)</p><ul><li><p>This argument will be evaluated at compile-time.</p></li></ul></li><li><p>A tuple of input types. The input types must be written as a literal tuple, not a tuple-valued variable or expression.</p><ul><li><p>This argument will be evaluated at compile-time.</p></li></ul></li><li><p>The following arguments, if any, are the actual argument values passed to the function.</p></li></ol><div class="mdnote debug">Base.Markdown.Paragraph</div><p>As a complete but simple example, the following calls the <code>clock</code> function from the standard C library:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">t</span><span> </span><span class="o">=</span><span> </span><span class="k">ccall</span><span class="p">(</span><span> </span><span class="p">(</span><span class="p">:</span><span class="n">clock</span><span class="p">,</span><span> </span><span class="s">&quot;</span><span class="s">libc</span><span class="s">&quot;</span><span class="p">)</span><span class="p">,</span><span> </span><span class="kt">Int32</span><span class="p">,</span><span> </span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="go">2292761
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">t</span><span>
</span><span class="go">2292761
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span><span>
</span><span class="go">Int32
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p><code>clock</code> takes no arguments and returns an <code>Int32</code>. One common gotcha is that a 1-tuple must be written with a trailing comma. For example, to call the <code>getenv</code> function to get a pointer to the value of an environment variable, one makes a call like this:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">path</span><span> </span><span class="o">=</span><span> </span><span class="k">ccall</span><span class="p">(</span><span class="p">(</span><span class="p">:</span><span class="n">getenv</span><span class="p">,</span><span> </span><span class="s">&quot;</span><span class="s">libc</span><span class="s">&quot;</span><span class="p">)</span><span class="p">,</span><span> </span><span class="n">Cstring</span><span class="p">,</span><span> </span><span class="p">(</span><span class="n">Cstring</span><span class="p">,</span><span class="p">)</span><span class="p">,</span><span> </span><span class="s">&quot;</span><span class="s">SHELL</span><span class="s">&quot;</span><span class="p">)</span><span>
</span><span class="go">Cstring(@0x00007fff5fbffc45)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">unsafe_string</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span>
</span><span class="go">&quot;/bin/bash&quot;
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Note that the argument type tuple must be written as <code>(Cstring,)</code>, rather than <code>(Cstring)</code>. This is because <code>(Cstring)</code> is just the expression <code>Cstring</code> surrounded by parentheses, rather than a 1-tuple containing <code>Cstring</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="p">(</span><span class="n">Cstring</span><span class="p">)</span><span>
</span><span class="go">Cstring
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="p">(</span><span class="n">Cstring</span><span class="p">,</span><span class="p">)</span><span>
</span><span class="go">(Cstring,)
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In practice, especially when providing reusable functionality, one generally wraps <a href="@ref"><code>ccall()</code></a> uses in Julia functions that set up arguments and then check for errors in whatever manner the C or Fortran function indicates them, propagating to the Julia caller as exceptions. This is especially important since C and Fortran APIs are notoriously inconsistent about how they indicate error conditions. For example, the <code>getenv</code> C library function is wrapped in the following Julia function, which is a simplified version of the actual definition from <a href="https://github.com/JuliaLang/julia/blob/master/base/env.jl">env.jl</a>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">function</span><span class="nf"> </span><span class="nf">getenv</span><span class="p">(</span><span class="n">var</span><span class="p">:</span><span class="p">:</span><span class="n">AbstractString</span><span class="p">)</span><span>
</span><span>  </span><span class="n">val</span><span> </span><span class="o">=</span><span> </span><span class="k">ccall</span><span class="p">(</span><span class="p">(</span><span class="p">:</span><span class="n">getenv</span><span class="p">,</span><span> </span><span class="s">&quot;</span><span class="s">libc</span><span class="s">&quot;</span><span class="p">)</span><span class="p">,</span><span>
</span><span>              </span><span class="n">Cstring</span><span class="p">,</span><span> </span><span class="p">(</span><span class="n">Cstring</span><span class="p">,</span><span class="p">)</span><span class="p">,</span><span> </span><span class="n">var</span><span class="p">)</span><span>
</span><span>  </span><span class="k">if</span><span> </span><span class="n">val</span><span> </span><span class="o">==</span><span> </span><span class="n">C_NULL</span><span>
</span><span>    </span><span class="nb">error</span><span class="p">(</span><span class="s">&quot;</span><span class="s">getenv: undefined variable: </span><span class="s">&quot;</span><span class="p">,</span><span> </span><span class="n">var</span><span class="p">)</span><span>
</span><span>  </span><span class="k">end</span><span>
</span><span>  </span><span class="n">unsafe_string</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The C <code>getenv</code> function indicates an error by returning <code>NULL</code>, but other standard C functions indicate errors in various different ways, including by returning -1, 0, 1 and other special values. This wrapper throws an exception clearly indicating the problem if the caller tries to get a non-existent environment variable:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">getenv</span><span class="p">(</span><span class="s">&quot;</span><span class="s">SHELL</span><span class="s">&quot;</span><span class="p">)</span><span>
</span><span class="go">&quot;/bin/bash&quot;
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">getenv</span><span class="p">(</span><span class="s">&quot;</span><span class="s">FOOBAR</span><span class="s">&quot;</span><span class="p">)</span><span>
</span><span class="go">getenv: undefined variable: FOOBAR
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Here is a slightly more complex example that discovers the local machine&#39;s hostname:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">function</span><span class="nf"> </span><span class="nf">gethostname</span><span class="p">(</span><span class="p">)</span><span>
</span><span>  </span><span class="n">hostname</span><span> </span><span class="o">=</span><span> </span><span class="n">Array</span><span class="p">{</span><span class="n">UInt8</span><span class="p">}</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span><span>
</span><span>  </span><span class="k">ccall</span><span class="p">(</span><span class="p">(</span><span class="p">:</span><span class="n">gethostname</span><span class="p">,</span><span> </span><span class="s">&quot;</span><span class="s">libc</span><span class="s">&quot;</span><span class="p">)</span><span class="p">,</span><span> </span><span class="kt">Int32</span><span class="p">,</span><span>
</span><span>        </span><span class="p">(</span><span class="n">Ptr</span><span class="p">{</span><span class="n">UInt8</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">Csize_t</span><span class="p">)</span><span class="p">,</span><span>
</span><span>        </span><span class="n">hostname</span><span class="p">,</span><span> </span><span class="nb">sizeof</span><span class="p">(</span><span class="n">hostname</span><span class="p">)</span><span class="p">)</span><span>
</span><span>  </span><span class="n">hostname</span><span class="p">[</span><span class="k">end</span><span class="p">]</span><span> </span><span class="o">=</span><span> </span><span class="mi">0</span><span class="p">;</span><span> </span><span class="c"># ensure null-termination</span><span>
</span><span>  </span><span class="k">return</span><span> </span><span class="n">unsafe_string</span><span class="p">(</span><span class="n">pointer</span><span class="p">(</span><span class="n">hostname</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This example first allocates an array of bytes, then calls the C library function <code>gethostname</code> to fill the array in with the hostname, takes a pointer to the hostname buffer, and converts the pointer to a Julia string, assuming that it is a NUL-terminated C string. It is common for C libraries to use this pattern of requiring the caller to allocate memory to be passed to the callee and filled in. Allocation of memory from Julia like this is generally accomplished by creating an uninitialized array and passing a pointer to its data to the C function. This is why we don&#39;t use the <code>Cstring</code> type here: as the array is uninitialized, it could contain NUL bytes. Converting to a <code>Cstring</code> as part of the <a href="@ref"><code>ccall()</code></a> checks for contained NUL bytes and could therefore throw a conversion error.</p><a id="Creating-C-Compatible-Julia-Function-Pointers-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Creating C-Compatible Julia Function Pointers</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>It is possible to pass Julia functions to native C functions that accept function pointer arguments. For example, to match C prototypes of the form:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">typedef returntype (*functiontype)(argumenttype,...)</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The function <a href="@ref"><code>cfunction()</code></a> generates the C-compatible function pointer for a call to a Julia library function. Arguments to <a href="@ref"><code>cfunction()</code></a> are as follows:</p><div class="mdnote debug">Base.Markdown.List</div><ol><li><p>A Julia Function</p></li><li><p>Return type</p></li><li><p>A tuple of input types</p></li></ol><div class="mdnote debug">Base.Markdown.Paragraph</div><p>A classic example is the standard C library <code>qsort</code> function, declared as:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">void qsort(void *base, size_t nmemb, size_t size,
           int(*compare)(const void *a, const void *b));</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The <code>base</code> argument is a pointer to an array of length <code>nmemb</code>, with elements of <code>size</code> bytes each. <code>compare</code> is a callback function which takes pointers to two elements <code>a</code> and <code>b</code> and returns an integer less/greater than zero if <code>a</code> should appear before/after <code>b</code> (or zero if any order is permitted). Now, suppose that we have a 1d array <code>A</code> of values in Julia that we want to sort using the <code>qsort</code> function (rather than Julia&#39;s built-in <code>sort</code> function). Before we worry about calling <code>qsort</code> and passing arguments, we need to write a comparison function that works for some arbitrary type T:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">function</span><span class="nf"> </span><span class="nf">mycompare</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="p">:</span><span class="n">T</span><span class="p">,</span><span> </span><span class="n">b</span><span class="p">:</span><span class="p">:</span><span class="n">T</span><span class="p">)</span><span>
</span><span>    </span><span class="k">return</span><span> </span><span class="nb">convert</span><span class="p">(</span><span class="n">Cint</span><span class="p">,</span><span> </span><span class="n">a</span><span> </span><span class="o">&lt;</span><span> </span><span class="n">b</span><span> </span><span class="o">?</span><span> </span><span class="o">-</span><span class="mi">1</span><span> </span><span class="p">:</span><span> </span><span class="n">a</span><span> </span><span class="o">&gt;</span><span> </span><span class="n">b</span><span> </span><span class="o">?</span><span> </span><span class="o">+</span><span class="mi">1</span><span> </span><span class="p">:</span><span> </span><span class="mi">0</span><span class="p">)</span><span class="p">:</span><span class="p">:</span><span class="n">Cint</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Notice that we have to be careful about the return type: <code>qsort</code> expects a function returning a C <code>int</code>, so we must be sure to return <code>Cint</code> via a call to <code>convert</code> and a <code>typeassert</code>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In order to pass this function to C, we obtain its address using the function <code>cfunction</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="kd">const</span><span> </span><span class="n">mycompare_c</span><span> </span><span class="o">=</span><span> </span><span class="n">cfunction</span><span class="p">(</span><span class="n">mycompare</span><span class="p">,</span><span> </span><span class="n">Cint</span><span class="p">,</span><span> </span><span class="p">(</span><span class="n">Ref</span><span class="p">{</span><span class="n">Cdouble</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">Ref</span><span class="p">{</span><span class="n">Cdouble</span><span class="p">}</span><span class="p">)</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p><a href="@ref"><code>cfunction()</code></a> accepts three arguments: the Julia function (<code>mycompare</code>), the return type (<code>Cint</code>), and a tuple of the argument types, in this case to sort an array of <code>Cdouble</code> (<code>Float64</code>) elements.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The final call to <code>qsort</code> looks like this:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">A</span><span> </span><span class="o">=</span><span> </span><span class="p">[</span><span class="mf">1.3</span><span class="p">,</span><span> </span><span class="o">-</span><span class="mf">2.7</span><span class="p">,</span><span> </span><span class="mf">4.4</span><span class="p">,</span><span> </span><span class="mf">3.1</span><span class="p">]</span><span>
</span><span class="k">ccall</span><span class="p">(</span><span class="p">:</span><span class="n">qsort</span><span class="p">,</span><span> </span><span class="n">Void</span><span class="p">,</span><span> </span><span class="p">(</span><span class="n">Ptr</span><span class="p">{</span><span class="n">Cdouble</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">Csize_t</span><span class="p">,</span><span> </span><span class="n">Csize_t</span><span class="p">,</span><span> </span><span class="n">Ptr</span><span class="p">{</span><span class="n">Void</span><span class="p">}</span><span class="p">)</span><span class="p">,</span><span>
</span><span>      </span><span class="n">A</span><span class="p">,</span><span> </span><span class="n">length</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="p">,</span><span> </span><span class="nb">sizeof</span><span class="p">(</span><span class="n">eltype</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="p">)</span><span class="p">,</span><span> </span><span class="n">mycompare_c</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>After this executes, <code>A</code> is changed to the sorted array <code>[-2.7, 1.3, 3.1, 4.4]</code>. Note that Julia knows how to convert an array into a <code>Ptr{Cdouble}</code>, how to compute the size of a type in bytes (identical to C&#39;s <code>sizeof</code> operator), and so on. For fun, try inserting a <code>println(&quot;mycompare($a,$b)&quot;)</code> line into <code>mycompare</code>, which will allow you to see the comparisons that <code>qsort</code> is performing (and to verify that it is really calling the Julia function that you passed to it).</p><a id="Mapping-C-Types-to-Julia-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Mapping C Types to Julia</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>It is critical to exactly match the declared C type with its declaration in Julia. Inconsistencies can cause code that works correctly on one system to fail or produce indeterminate results on a different system.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Note that no C header files are used anywhere in the process of calling C functions: you are responsible for making sure that your Julia types and call signatures accurately reflect those in the C header file. (The <a href="https://github.com/ihnorton/Clang.jl">Clang package</a> can be used to auto-generate Julia code from a C header file.)</p><a id="Auto-conversion:-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>Auto-conversion:</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Julia automatically inserts calls to the <a href="@ref"><code>cconvert()</code></a> function to convert each argument to the specified type. For example, the following call:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">ccall</span><span class="p">(</span><span class="p">(</span><span class="p">:</span><span class="n">foo</span><span class="p">,</span><span> </span><span class="s">&quot;</span><span class="s">libfoo</span><span class="s">&quot;</span><span class="p">)</span><span class="p">,</span><span> </span><span class="n">Void</span><span class="p">,</span><span> </span><span class="p">(</span><span class="kt">Int32</span><span class="p">,</span><span> </span><span class="kt">Float64</span><span class="p">)</span><span class="p">,</span><span> </span><span class="n">x</span><span class="p">,</span><span> </span><span class="n">y</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>will behave as if the following were written:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">ccall</span><span class="p">(</span><span class="p">(</span><span class="p">:</span><span class="n">foo</span><span class="p">,</span><span> </span><span class="s">&quot;</span><span class="s">libfoo</span><span class="s">&quot;</span><span class="p">)</span><span class="p">,</span><span> </span><span class="n">Void</span><span class="p">,</span><span> </span><span class="p">(</span><span class="kt">Int32</span><span class="p">,</span><span> </span><span class="kt">Float64</span><span class="p">)</span><span class="p">,</span><span>
</span><span>      </span><span class="n">Base</span><span class="o">.</span><span class="n">unsafe_convert</span><span class="p">(</span><span class="kt">Int32</span><span class="p">,</span><span> </span><span class="n">Base</span><span class="o">.</span><span class="n">cconvert</span><span class="p">(</span><span class="kt">Int32</span><span class="p">,</span><span> </span><span class="n">x</span><span class="p">)</span><span class="p">)</span><span class="p">,</span><span>
</span><span>      </span><span class="n">Base</span><span class="o">.</span><span class="n">unsafe_convert</span><span class="p">(</span><span class="kt">Float64</span><span class="p">,</span><span> </span><span class="n">Base</span><span class="o">.</span><span class="n">cconvert</span><span class="p">(</span><span class="kt">Float64</span><span class="p">,</span><span> </span><span class="n">y</span><span class="p">)</span><span class="p">)</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p><a href="@ref"><code>cconvert()</code></a> normally just calls <a href="../stdlib/base.html#Base.convert"><code>convert()</code></a>, but can be defined to return an arbitrary new object more appropriate for passing to C. For example, this is used to convert an <code>Array</code> of objects (e.g. strings) to an array of pointers.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p><a href="@ref"><code>unsafe_convert()</code></a> handles conversion to <code>Ptr</code> types. It is considered unsafe because converting an object to a native pointer can hide the object from the garbage collector, causing it to be freed prematurely.</p><a id="Type-Correspondences:-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>Type Correspondences:</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>First, a review of some relevant Julia type terminology:</p><div class="mdnote debug">Base.Markdown.Table</div><table><tr><th>Syntax / Keyword</th><th>Example</th><th>Description</th></tr><tr><td><code>type</code></td><td><code>String</code></td><td>&quot;Leaf Type&quot; :: A group of related data that includes a type-tag, is managed by the Julia GC, and is defined by object-identity. The type parameters of a leaf type must be fully defined (no <code>TypeVars</code> are allowed) in order for the instance to be constructed.</td></tr><tr><td><code>abstract</code></td><td><code>Any</code>, <code>AbstractArray{T,N}</code>, <code>Complex{T}</code></td><td>&quot;Super Type&quot; :: A super-type (not a leaf-type) that cannot be instantiated, but can be used to describe a group of types.</td></tr><tr><td><code>{T}</code></td><td><code>Vector{Int}</code></td><td>&quot;Type Parameter&quot; :: A specialization of a type (typically used for dispatch or storage optimization).&quot;TypeVar&quot; :: The <code>T</code> in the type parameter declaration is referred to as a TypeVar (short for type variable).</td></tr><tr><td><code>bitstype</code></td><td><code>Int</code>, <code>Float64</code></td><td>&quot;Bits Type&quot; :: A type with no fields, but a size. It is stored and defined by-value.</td></tr><tr><td><code>immutable</code></td><td><code>Pair{Int,Int}</code><code>Complex128</code> (<code>isbits</code>)</td><td>&quot;Immutable&quot; :: A type with all fields defined to be constant. It is defined by-value. And may be stored with a type-tag.&quot;Is-Bits&quot; :: A <code>bitstype</code>, or an <code>immutable</code> type where all fields are other <code>isbits</code> types. It is defined by-value, and is stored without a type-tag.</td></tr><tr><td><code>type ...; end</code></td><td><code>nothing</code></td><td>&quot;Singleton&quot; :: a Leaf Type or Immutable with no fields.</td></tr><tr><td><code>(...)</code> or <code>tuple(...)`</code></td><td><code>(1,2,3)</code></td><td>&quot;Tuple&quot; :: an immutable data-structure similar to an anonymous immutable type, or a constant array. Represented as either an array or a struct.</td></tr><tr><td><code>typealias</code></td><td>Not applicable here</td><td>Type aliases, and other similar mechanisms of doing type indirection, are resolved to their base type (this includes assigning a type to another name, or getting the type out of a function call).</td></tr></table><a id="Bits-Types:-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>Bits Types:</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>There are several special types to be aware of, as no other type can be defined to behave the same:</p><div class="mdnote debug">Base.Markdown.List</div><ul><li><p><code>Float32</code></p><p>Exactly corresponds to the <code>float</code> type in C (or <code>REAL*4</code> in Fortran).</p></li><li><p><code>Float64</code></p><p>Exactly corresponds to the <code>double</code> type in C (or <code>REAL*8</code> in Fortran).</p></li><li><p><code>Complex64</code></p><p>Exactly corresponds to the <code>complex float</code> type in C (or <code>COMPLEX*8</code> in Fortran).</p></li><li><p><code>Complex128</code></p><p>Exactly corresponds to the <code>complex double</code> type in C (or <code>COMPLEX*16</code> in Fortran).</p></li><li><p><code>Signed</code></p><p>Exactly corresponds to the <code>signed</code> type annotation in C (or any <code>INTEGER</code> type in Fortran). Any Julia type that is not a subtype of <code>Signed</code> is assumed to be unsigned.</p></li><li><p><code>Ref{T}</code></p><p>Behaves like a <code>Ptr{T}</code> that owns its memory.</p></li><li><p><code>Array{T,N}</code></p><p>When an array is passed to C as a <code>Ptr{T}</code> argument, it is not reinterpret-cast: Julia requires that the element type of the array matches <code>T</code>, and the address of the first element is passed.</p><p>Therefore, if an <code>Array</code> contains data in the wrong format, it will have to be explicitly converted using a call such as <code>trunc(Int32,a)</code>.</p><p>To pass an array <code>A</code> as a pointer of a different type <em>without</em> converting the data beforehand (for example, to pass a <code>Float64</code> array to a function that operates on uninterpreted bytes), you can declare the argument as <code>Ptr{Void}</code>.</p><p>If an array of eltype <code>Ptr{T}</code> is passed as a <code>Ptr{Ptr{T}}</code> argument, <a href="@ref"><code>Base.cconvert()</code></a> will attempt to first make a null-terminated copy of the array with each element replaced by its <a href="@ref"><code>cconvert()</code></a> version. This allows, for example, passing an <code>argv</code> pointer array of type <code>Vector{String}</code> to an argument of type <code>Ptr{Ptr{Cchar}}</code>.</p></li></ul><div class="mdnote debug">Base.Markdown.Paragraph</div><p>On all systems we currently support, basic C/C++ value types may be translated to Julia types as follows. Every C type also has a corresponding Julia type with the same name, prefixed by C. This can help for writing portable code (and remembering that an <code>int</code> in C is not the same as an <code>Int</code> in Julia).</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p><strong>System Independent:</strong></p><div class="mdnote debug">Base.Markdown.Table</div><table><tr><th>C name</th><th>Fortran name</th><th>Standard Julia Alias</th><th>Julia Base Type</th></tr><tr><td><code>unsigned char</code><code>bool</code> (C++)</td><td><code>CHARACTER</code></td><td><code>Cuchar</code></td><td><code>UInt8</code></td></tr><tr><td><code>short</code></td><td><code>INTEGER*2</code><code>LOGICAL*2</code></td><td><code>Cshort</code></td><td><code>Int16</code></td></tr><tr><td><code>unsigned short</code></td><td> </td><td><code>Cushort</code></td><td><code>UInt16</code></td></tr><tr><td><code>int</code><code>BOOL</code> (C, typical)</td><td><code>INTEGER*4</code><code>LOGICAL*4</code></td><td><code>Cint</code></td><td><code>Int32</code></td></tr><tr><td><code>unsigned int</code></td><td> </td><td><code>Cuint</code></td><td><code>UInt32</code></td></tr><tr><td><code>long long</code></td><td><code>INTEGER*8</code><code>LOGICAL*8</code></td><td><code>Clonglong</code></td><td><code>Int64</code></td></tr><tr><td><code>unsigned long long</code></td><td> </td><td><code>Culonglong</code></td><td><code>UInt64</code></td></tr><tr><td><code>intmax_t</code></td><td> </td><td><code>Cintmax_t</code></td><td><code>Int64</code></td></tr><tr><td><code>uintmax_t</code></td><td> </td><td><code>Cuintmax_t</code></td><td><code>UInt64</code></td></tr><tr><td><code>float</code></td><td><code>REAL*4i</code></td><td><code>Cfloat</code></td><td><code>Float32</code></td></tr><tr><td><code>double</code></td><td><code>REAL*8</code></td><td><code>Cdouble</code></td><td><code>Float64</code></td></tr><tr><td><code>complex float</code></td><td><code>COMPLEX*8</code></td><td><code>Complex64</code></td><td><code>Complex{Float32}</code></td></tr><tr><td><code>complex double</code></td><td><code>COMPLEX*16</code></td><td><code>Complex128</code></td><td><code>Complex{Float64}</code></td></tr><tr><td><code>ptrdiff_t</code></td><td> </td><td><code>Cptrdiff_t</code></td><td><code>Int</code></td></tr><tr><td><code>ssize_t</code></td><td> </td><td><code>Cssize_t</code></td><td><code>Int</code></td></tr><tr><td><code>size_t</code></td><td> </td><td><code>Csize_t</code></td><td><code>UInt</code></td></tr><tr><td><code>void</code></td><td> </td><td> </td><td><code>Void</code></td></tr><tr><td><code>void</code> and <code>[[noreturn]]</code> or <code>_Noreturn</code></td><td> </td><td> </td><td><code>Union{}</code></td></tr><tr><td><code>void*</code></td><td> </td><td> </td><td><code>Ptr{Void}</code></td></tr><tr><td><code>T*</code> (where T represents an appropriately defined type)</td><td> </td><td> </td><td><code>Ref{T}</code></td></tr><tr><td><code>char*</code> (or <code>char[]</code>, e.g. a string)</td><td><code>CHARACTER*N</code></td><td> </td><td><code>Cstring</code> if NUL-terminated, or <code>Ptr{UInt8}</code> if not</td></tr><tr><td><code>char**</code> (or <code>*char[]</code>)</td><td> </td><td> </td><td><code>Ptr{Ptr{UInt8}}</code></td></tr><tr><td><code>jl_value_t*</code> (any Julia Type)</td><td> </td><td> </td><td><code>Any</code></td></tr><tr><td><code>jl_value_t**</code> (a reference to a Julia Type)</td><td> </td><td> </td><td><code>Ref{Any}</code></td></tr><tr><td><code>va_arg</code></td><td> </td><td> </td><td>Not supported</td></tr><tr><td><code>...</code> (variadic function specification)</td><td> </td><td> </td><td><code>T...</code> (where <code>T</code> is one of the above types, variadic functions of different argument types are not supported)</td></tr></table><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The <code>Cstring</code> type is essentially a synonym for <code>Ptr{UInt8}</code>, except the conversion to <code>Cstring</code> throws an error if the Julia string contains any embedded NUL characters (which would cause the string to be silently truncated if the C routine treats NUL as the terminator).  If you are passing a <code>char*</code> to a C routine that does not assume NUL termination (e.g. because you pass an explicit string length), or if you know for certain that your Julia string does not contain NUL and want to skip the check, you can use <code>Ptr{UInt8}</code> as the argument type. <code>Cstring</code> can also be used as the <a href="@ref"><code>ccall()</code></a> return type, but in that case it obviously does not introduce any extra checks and is only meant to improve readability of the call.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p><strong>System-dependent:</strong></p><div class="mdnote debug">Base.Markdown.Table</div><table><tr><th>C name</th><th>Standard Julia Alias</th><th>Julia Base Type</th></tr><tr><td><code>char</code></td><td><code>Cchar</code></td><td><code>Int8</code> (x86, x86_64)<code>UInt8</code> (powerpc, arm)</td></tr><tr><td><code>long</code></td><td><code>Clong</code></td><td><code>Int</code> (UNIX)<code>Int32</code> (Windows)</td></tr><tr><td><code>unsigned long</code></td><td><code>Culong</code></td><td><code>UInt</code> (UNIX)<code>UInt32</code> (Windows)</td></tr><tr><td><code>wchar_t</code></td><td><code>Cwchar_t</code></td><td><code>Int32</code> (UNIX)<code>UInt16</code> (Windows)</td></tr></table><div class="mdnote debug">Base.Markdown.Admonition</div><div class="admonition note"><div class="admonition-title"></div><div class="admonition-text"><p>When calling a Fortran function, all inputs must be passed by reference, so all type correspondences above should contain an additional <code>Ptr{..}</code> or <code>Ref{..}</code> wrapper around their type specification.</p></div></div><div class="mdnote debug">Base.Markdown.Admonition</div><div class="admonition warning"><div class="admonition-title"></div><div class="admonition-text"><p>For string arguments (<code>char*</code>) the Julia type should be <code>Cstring</code> (if NUL- terminated data is expected) or either <code>Ptr{Cchar}</code> or <code>Ptr{UInt8}</code> otherwise (these two pointer types have the same effect), as described above, not <code>String</code>. Similarly, for array arguments (<code>T[]</code> or <code>T*</code>), the Julia type should again be <code>Ptr{T}</code>, not <code>Vector{T}</code>.</p></div></div><div class="mdnote debug">Base.Markdown.Admonition</div><div class="admonition warning"><div class="admonition-title"></div><div class="admonition-text"><p>Julia&#39;s <code>Char</code> type is 32 bits, which is not the same as the wide character type (<code>wchar_t</code> or <code>wint_t</code>) on all platforms.</p></div></div><div class="mdnote debug">Base.Markdown.Admonition</div><div class="admonition warning"><div class="admonition-title"></div><div class="admonition-text"><p>A return type of <code>Union{}</code> means the function will not return i.e. C++11 <code>[[noreturn]]</code> or C11 <code>_Noreturn</code> (e.g. <code>jl_throw</code> or <code>longjmp</code>). Do not use this for functions that return no value (<code>void</code>) but do return.</p></div></div><div class="mdnote debug">Base.Markdown.Admonition</div><div class="admonition note"><div class="admonition-title"></div><div class="admonition-text"><p>For <code>wchar_t*</code> arguments, the Julia type should be <code>Cwstring</code> (if the C routine expects a NUL-terminated string) or <code>Ptr{Cwchar_t}</code> otherwise. Note also that UTF-8 string data in Julia is internally NUL-terminated, so it can be passed to C functions expecting NUL-terminated data without making a copy (but using the <code>Cwstring</code> type will cause an error to be thrown if the string itself contains NUL characters).</p></div></div><div class="mdnote debug">Base.Markdown.Admonition</div><div class="admonition note"><div class="admonition-title"></div><div class="admonition-text"><p>C functions that take an argument of the type <code>char**</code> can be called by using a <code>Ptr{Ptr{UInt8}}</code> type within Julia. For example, C functions of the form:</p><code>int main(int argc, char **argv);</code><p>can be called via the following Julia code:</p><code>argv = [ &quot;a.out&quot;, &quot;arg1&quot;, &quot;arg2&quot; ]
ccall(:main, Int32, (Int32, Ptr{Ptr{UInt8}}), length(argv), argv)</code></div></div><div class="mdnote debug">Base.Markdown.Admonition</div><div class="admonition note"><div class="admonition-title"></div><div class="admonition-text"><p>A C function declared to return <code>Void</code> will return the value <code>nothing</code> in Julia.</p></div></div><a id="Struct-Type-correspondences-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>Struct Type correspondences</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Composite types, aka <code>struct</code> in C or <code>TYPE</code> in Fortran90 (or <code>STRUCTURE</code> / <code>RECORD</code> in some variants of F77), can be mirrored in Julia by creating a <code>type</code> or <code>immutable</code> definition with the same field layout.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>When used recursively, <code>isbits</code> types are stored inline. All other types are stored as a pointer to the data. When mirroring a struct used by-value inside another struct in C, it is imperative that you do not attempt to manually copy the fields over, as this will not preserve the correct field alignment. Instead, declare an immutable <code>isbits</code> type and use that instead. Unnamed structs are not possible in the translation to Julia.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Packed structs and union declarations are not supported by Julia.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>You can get a near approximation of a <code>union</code> if you know, a priori, the field that will have the greatest size (potentially including padding). When translating your fields to Julia, declare the Julia field to be only of that type.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Arrays of parameters must be expanded manually, currently (either inline, or in an immutable helper type). For example:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">in C:
struct B {
    int A[3];
};
b_a_2 = B.A[2];

in Julia:
immutable B_A
    A_1::Cint
    A_2::Cint
    A_3::Cint
end
type B
    A::B_A
end
b_a_2 = B.A.(2)</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Arrays of unknown size are not supported.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In the future, some of these restrictions may be reduced or eliminated.</p><a id="SIMD-Values-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>SIMD Values</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Note: This feature is currently implemented on 64-bit x86 and AArch64 platforms only.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>If a C/C++ routine has an argument or return value that is a native SIMD type, the corresponding Julia type is a homogeneous tuple of <code>VecElement</code> that naturally maps to the SIMD type.  Specifically:</p><div class="mdnote debug">Base.Markdown.List</div><ul><li><p>The tuple must be the same size as the SIMD type. For example, a tuple representing an <code>__m128</code> on x86 must have a size of 16 bytes.</p></li><li><p>The element type of the tuple must be an instance of <code>VecElement{T}</code> where <code>T</code> is a bitstype that is 1, 2, 4 or 8 bytes.</p></li></ul><div class="mdnote debug">Base.Markdown.Paragraph</div><p>For instance, consider this C routine that uses AVX intrinsics:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">#include &lt;immintrin.h&gt;

__m256 dist( __m256 a, __m256 b ) {
    return _mm256_sqrt_ps(_mm256_add_ps(_mm256_mul_ps(a, a),
                                        _mm256_mul_ps(b, b)));
}</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The following Julia code calls <code>dist</code> using <code>ccall</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">typealias</span><span class="nc"> </span><span class="nc">m256</span><span> </span><span class="n">NTuple</span><span class="p">{</span><span class="mi">8</span><span class="p">,</span><span class="n">VecElement</span><span class="p">{</span><span class="kt">Float32</span><span class="p">}</span><span class="p">}</span><span>
</span><span>
</span><span class="n">a</span><span> </span><span class="o">=</span><span> </span><span class="n">m256</span><span class="p">(</span><span class="nb">ntuple</span><span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">VecElement</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="kt">Float32</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="p">)</span><span class="p">)</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="n">b</span><span> </span><span class="o">=</span><span> </span><span class="n">m256</span><span class="p">(</span><span class="nb">ntuple</span><span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">VecElement</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="kt">Float32</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="p">)</span><span class="p">)</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span><span class="p">)</span><span>
</span><span>
</span><span class="k">function</span><span class="nf"> </span><span class="nf">call_dist</span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="p">:</span><span class="n">m256</span><span class="p">,</span><span> </span><span class="n">b</span><span class="p">:</span><span class="p">:</span><span class="n">m256</span><span class="p">)</span><span>
</span><span>    </span><span class="k">ccall</span><span class="p">(</span><span class="p">(</span><span class="p">:</span><span class="n">dist</span><span class="p">,</span><span> </span><span class="s">&quot;</span><span class="s">libdist</span><span class="s">&quot;</span><span class="p">)</span><span class="p">,</span><span> </span><span class="n">m256</span><span class="p">,</span><span> </span><span class="p">(</span><span class="n">m256</span><span class="p">,</span><span> </span><span class="n">m256</span><span class="p">)</span><span class="p">,</span><span> </span><span class="n">a</span><span class="p">,</span><span> </span><span class="n">b</span><span class="p">)</span><span>
</span><span class="k">end</span><span>
</span><span>
</span><span class="n">println</span><span class="p">(</span><span class="n">call_dist</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The host machine must have the requisite SIMD registers.  For example, the code above will not work on hosts without AVX support.</p><a id="Memory-Ownership-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>Memory Ownership</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p><strong>malloc/free</strong></p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Memory allocation and deallocation of such objects must be handled by calls to the appropriate cleanup routines in the libraries being used, just like in any C program. Do not try to free an object received from a C library with <code>Libc.free</code> in Julia, as this may result in the <code>free</code> function being called via the wrong <code>libc</code> library and cause Julia to crash. The reverse (passing an object allocated in Julia to be freed by an external library) is equally invalid.</p><a id="When-to-use-T,-Ptr{T}-and-Ref{T}-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>When to use T, Ptr{T} and Ref{T}</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In Julia code wrapping calls to external C routines, ordinary (non-pointer) data should be declared to be of type <code>T</code> inside the <a href="@ref"><code>ccall()</code></a>, as they are passed by value.  For C code accepting pointers, <code>Ref{T}</code> should generally be used for the types of input arguments, allowing the use of pointers to memory managed by either Julia or C through the implicit call to <a href="@ref"><code>cconvert()</code></a>.  In contrast, pointers returned by the C function called should be declared to be of output type <code>Ptr{T}</code>, reflecting that the memory pointed to is managed by C only. Pointers contained in C structs should be represented as fields of type <code>Ptr{T}</code> within the corresponding Julia immutable types designed to mimic the internal structure of corresponding C structs.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In Julia code wrapping calls to external Fortran routines, all input arguments should be declared as of type <code>Ref{T}</code>, as Fortran passes all variables by reference. The return type should either be <code>Void</code> for Fortran subroutines, or a <code>T</code> for Fortran functions returning the type <code>T</code>.</p><a id="Mapping-C-Functions-to-Julia-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Mapping C Functions to Julia</h2><a id="ccall/cfunction-argument-translation-guide-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3><code>ccall</code>/<code>cfunction</code> argument translation guide</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>For translating a C argument list to Julia:</p><div class="mdnote debug">Base.Markdown.List</div><ul><li><p><code>T</code>, where <code>T</code> is one of the primitive types: <code>char</code>, <code>int</code>, <code>long</code>, <code>short</code>, <code>float</code>, <code>double</code>, <code>complex</code>, <code>enum</code> or any of their <code>typedef</code> equivalents</p><ul><li><p><code>T</code>, where <code>T</code> is an equivalent Julia Bits Type (per the table above)</p></li><li><p>if <code>T</code> is an <code>enum</code>, the argument type should be equivalent to <code>Cint</code> or <code>Cuint</code></p></li><li><p>argument value will be copied (passed by value)</p></li></ul></li><li><p><code>struct T</code> (including typedef to a struct)</p><ul><li><p><code>T</code>, where <code>T</code> is a Julia leaf type</p></li><li><p>argument value will be copied (passed by value)</p></li></ul></li><li><p><code>void*</code></p><ul><li><p>depends on how this parameter is used, first translate this to the intended pointer type, then determine the Julia equivalent using the remaining rules in this list</p></li><li><p>this argument may be declared as <code>Ptr{Void}</code>, if it really is just an unknown pointer</p></li></ul></li><li><p><code>jl_value_t*</code></p><ul><li><p><code>Any</code></p></li><li><p>argument value must be a valid Julia object</p></li><li><p>currently unsupported by <a href="@ref"><code>cfunction()</code></a></p></li></ul></li><li><p><code>jl_value_t**</code></p><ul><li><p><code>Ref{Any}</code></p></li><li><p>argument value must be a valid Julia object (or <code>C_NULL</code>)</p></li><li><p>currently unsupported by <a href="@ref"><code>cfunction()</code></a></p></li></ul></li><li><p><code>T*</code></p><ul><li><p><code>Ref{T}</code>, where <code>T</code> is the Julia type corresponding to <code>T</code></p></li><li><p>argument value will be copied if it is an <code>isbits</code> type otherwise, the value must be a valid Julia object</p></li></ul></li><li><p><code>(T*)(...)</code> (e.g. a pointer to a function)</p><ul><li><p><code>Ptr{Void}</code> (you may need to use <a href="@ref"><code>cfunction()</code></a> explicitly to create this pointer)</p></li></ul></li><li><p><code>...</code> (e.g. a vararg)</p><ul><li><p><code>T...</code>, where <code>T</code> is the Julia type</p></li></ul></li><li><p><code>va_arg</code></p><ul><li><p>not supported</p></li></ul></li></ul><a id="ccall/cfunction-return-type-translation-guide-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3><code>ccall</code>/<code>cfunction</code> return type translation guide</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>For translating a C return type to Julia:</p><div class="mdnote debug">Base.Markdown.List</div><ul><li><p><code>void</code></p><ul><li><p><code>Void</code> (this will return the singleton instance <code>nothing::Void</code>)</p></li></ul></li><li><p><code>T</code>, where <code>T</code> is one of the primitive types: <code>char</code>, <code>int</code>, <code>long</code>, <code>short</code>, <code>float</code>, <code>double</code>, <code>complex</code>, <code>enum</code> or any of their <code>typedef</code> equivalents</p><ul><li><p><code>T</code>, where <code>T</code> is an equivalent Julia Bits Type (per the table above)</p></li><li><p>if <code>T</code> is an <code>enum</code>, the argument type should be equivalent to <code>Cint</code> or <code>Cuint</code></p></li><li><p>argument value will be copied (returned by-value)</p></li></ul></li><li><p><code>struct T</code> (including typedef to a struct)</p><ul><li><p><code>T</code>, where <code>T</code> is a Julia Leaf Type</p></li><li><p>argument value will be copied (returned by-value)</p></li></ul></li><li><p><code>void*</code></p><ul><li><p>depends on how this parameter is used, first translate this to the intended pointer type, then determine the Julia equivalent using the remaining rules in this list</p></li><li><p>this argument may be declared as <code>Ptr{Void}</code>, if it really is just an unknown pointer</p></li></ul></li><li><p><code>jl_value_t*</code></p><ul><li><p><code>Any</code></p></li><li><p>argument value must be a valid Julia object</p></li></ul></li><li><p><code>jl_value_t**</code></p><ul><li><p><code>Ref{Any}</code></p></li><li><p>argument value must be a valid Julia object (or <code>C_NULL</code>)</p></li></ul></li><li><p><code>T*</code></p><ul><li><p>If the memory is already owned by Julia, or is an <code>isbits</code> type, and is known to be non-null:</p><ul><li><p><code>Ref{T}</code>, where <code>T</code> is the Julia type corresponding to <code>T</code></p></li><li><p>a return type of <code>Ref{Any}</code> is invalid, it should either be <code>Any</code> (corresponding to <code>jl_value_t*</code>) or <code>Ptr{Any}</code> (corresponding to <code>Ptr{Any}</code>)</p></li><li><p>C <strong>MUST NOT</strong> modify the memory returned via <code>Ref{T}</code> if <code>T</code> is an <code>isbits</code> type</p></li></ul></li><li><p>If the memory is owned by C:</p><ul><li><p><code>Ptr{T}</code>, where <code>T</code> is the Julia type corresponding to <code>T</code></p></li></ul></li></ul></li><li><p><code>(T*)(...)</code> (e.g. a pointer to a function)</p><ul><li><p><code>Ptr{Void}</code> (you may need to use <a href="@ref"><code>cfunction()</code></a> explicitly to create this pointer)</p></li></ul></li></ul><a id="Passing-Pointers-for-Modifying-Inputs-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>Passing Pointers for Modifying Inputs</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Because C doesn&#39;t support multiple return values, often C functions will take pointers to data that the function will modify. To accomplish this within a <a href="@ref"><code>ccall()</code></a>, you need to first encapsulate the value inside an <code>Ref{T}</code> of the appropriate type. When you pass this <code>Ref</code> object as an argument, Julia will automatically pass a C pointer to the encapsulated data:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">width</span><span> </span><span class="o">=</span><span> </span><span class="n">Ref</span><span class="p">{</span><span class="n">Cint</span><span class="p">}</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span>
</span><span class="n">range</span><span> </span><span class="o">=</span><span> </span><span class="n">Ref</span><span class="p">{</span><span class="n">Cfloat</span><span class="p">}</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span>
</span><span class="k">ccall</span><span class="p">(</span><span class="p">:</span><span class="n">foo</span><span class="p">,</span><span> </span><span class="n">Void</span><span class="p">,</span><span> </span><span class="p">(</span><span class="n">Ref</span><span class="p">{</span><span class="n">Cint</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">Ref</span><span class="p">{</span><span class="n">Cfloat</span><span class="p">}</span><span class="p">)</span><span class="p">,</span><span> </span><span class="n">width</span><span class="p">,</span><span> </span><span class="n">range</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Upon return, the contents of <code>width</code> and <code>range</code> can be retrieved (if they were changed by <code>foo</code>) by <code>width[]</code> and <code>range[]</code>; that is, they act like zero-dimensional arrays.</p><a id="Special-Reference-Syntax-for-ccall-(deprecated):-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>Special Reference Syntax for ccall (deprecated):</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The <code>&amp;</code> syntax is deprecated, use the <code>Ref{T}</code> argument type instead.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>A prefix <code>&amp;</code> is used on an argument to <a href="@ref"><code>ccall()</code></a> to indicate that a pointer to a scalar argument should be passed instead of the scalar value itself (required for all Fortran function arguments, as noted above). The following example computes a dot product using a BLAS function.</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">function</span><span class="nf"> </span><span class="nf">compute_dot</span><span class="p">(</span><span class="n">DX</span><span class="p">:</span><span class="p">:</span><span class="n">Vector</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">DY</span><span class="p">:</span><span class="p">:</span><span class="n">Vector</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span><span class="p">)</span><span>
</span><span>  </span><span class="nb">assert</span><span class="p">(</span><span class="n">length</span><span class="p">(</span><span class="n">DX</span><span class="p">)</span><span> </span><span class="o">==</span><span> </span><span class="n">length</span><span class="p">(</span><span class="n">DY</span><span class="p">)</span><span class="p">)</span><span>
</span><span>  </span><span class="n">n</span><span> </span><span class="o">=</span><span> </span><span class="n">length</span><span class="p">(</span><span class="n">DX</span><span class="p">)</span><span>
</span><span>  </span><span class="n">incx</span><span> </span><span class="o">=</span><span> </span><span class="n">incy</span><span> </span><span class="o">=</span><span> </span><span class="mi">1</span><span>
</span><span>  </span><span class="n">product</span><span> </span><span class="o">=</span><span> </span><span class="k">ccall</span><span class="p">(</span><span class="p">(</span><span class="p">:</span><span class="n">ddot_</span><span class="p">,</span><span> </span><span class="s">&quot;</span><span class="s">libLAPACK</span><span class="s">&quot;</span><span class="p">)</span><span class="p">,</span><span>
</span><span>                  </span><span class="kt">Float64</span><span class="p">,</span><span>
</span><span>                  </span><span class="p">(</span><span class="n">Ptr</span><span class="p">{</span><span class="kt">Int32</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">Ptr</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">Ptr</span><span class="p">{</span><span class="kt">Int32</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">Ptr</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">Ptr</span><span class="p">{</span><span class="kt">Int32</span><span class="p">}</span><span class="p">)</span><span class="p">,</span><span>
</span><span>                  </span><span class="o">&amp;</span><span class="n">n</span><span class="p">,</span><span> </span><span class="n">DX</span><span class="p">,</span><span> </span><span class="o">&amp;</span><span class="n">incx</span><span class="p">,</span><span> </span><span class="n">DY</span><span class="p">,</span><span> </span><span class="o">&amp;</span><span class="n">incy</span><span class="p">)</span><span>
</span><span>  </span><span class="k">return</span><span> </span><span class="n">product</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The meaning of prefix <code>&amp;</code> is not quite the same as in C. In particular, any changes to the referenced variables will not be visible in Julia unless the type is mutable (declared via <code>type</code>). However, even for immutable types it will not cause any harm for called functions to attempt such modifications (that is, writing through the passed pointers). Moreover, <code>&amp;</code> may be used with any expression, such as <code>&amp;0</code> or <code>&amp;f(x)</code>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>When a scalar value is passed with <code>&amp;</code> as an argument of type <code>Ptr{T}</code>, the value will first be converted to type <code>T</code>.</p><a id="Some-Examples-of-C-Wrappers-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Some Examples of C Wrappers</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Here is a simple example of a C wrapper that returns a <code>Ptr</code> type:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">type</span><span class="nc"> </span><span class="nc">gsl_permutation</span><span>
</span><span class="k">end</span><span>
</span><span>
</span><span class="c"># The corresponding C signature is</span><span>
</span><span class="c">#     gsl_permutation * gsl_permutation_alloc (size_t n);</span><span>
</span><span class="k">function</span><span class="nf"> </span><span class="nf">permutation_alloc</span><span class="p">(</span><span class="n">n</span><span class="p">:</span><span class="p">:</span><span class="n">Integer</span><span class="p">)</span><span>
</span><span>    </span><span class="n">output_ptr</span><span> </span><span class="o">=</span><span> </span><span class="k">ccall</span><span class="p">(</span><span>
</span><span>        </span><span class="p">(</span><span class="p">:</span><span class="n">gsl_permutation_alloc</span><span class="p">,</span><span> </span><span class="p">:</span><span class="n">libgsl</span><span class="p">)</span><span class="p">,</span><span> </span><span class="c">#name of C function and library</span><span>
</span><span>        </span><span class="n">Ptr</span><span class="p">{</span><span class="n">gsl_permutation</span><span class="p">}</span><span class="p">,</span><span>              </span><span class="c">#output type</span><span>
</span><span>        </span><span class="p">(</span><span class="n">Csize_t</span><span class="p">,</span><span class="p">)</span><span class="p">,</span><span>                        </span><span class="c">#tuple of input types</span><span>
</span><span>        </span><span class="n">n</span><span>                                  </span><span class="c">#name of Julia variable to pass in</span><span>
</span><span>    </span><span class="p">)</span><span>
</span><span>    </span><span class="k">if</span><span> </span><span class="n">output_ptr</span><span class="o">==</span><span class="n">C_NULL</span><span> </span><span class="c"># Could not allocate memory</span><span>
</span><span>        </span><span class="nb">throw</span><span class="p">(</span><span class="n">OutOfMemoryError</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span>
</span><span>    </span><span class="k">end</span><span>
</span><span>    </span><span class="k">return</span><span> </span><span class="n">output_ptr</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The <a href="https://www.gnu.org/software/gsl/">GNU Scientific Library</a> (here assumed to be accessible through <code>:libgsl</code>) defines an opaque pointer, <code>gsl_permutation *</code>, as the return type of the C function <code>gsl_permutation_alloc()</code>. As user code never has to look inside the <code>gsl_permutation</code> struct, the corresponding Julia wrapper simply needs a new type declaration, <code>gsl_permutation</code>, that has no internal fields and whose sole purpose is to be placed in the type parameter of a <code>Ptr</code> type.  The return type of the <a href="@ref"><code>ccall()</code></a> is declared as <code>Ptr{gsl_permutation}</code>, since the memory allocated and pointed to by <code>output_ptr</code> is controlled by C (and not Julia).</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The input <code>n</code> is passed by value, and so the function&#39;s input signature is simply declared as <code>(Csize_t,)</code> without any <code>Ref</code> or <code>Ptr</code> necessary. (If the wrapper was calling a Fortran function instead, the corresponding function input signature should instead be <code>(Ref{Csize_t},)</code>, since Fortran variables are passed by reference.) Furthermore, <code>n</code> can be any type that is convertable to a <code>Csize_t</code> integer; the <a href="@ref"><code>ccall()</code></a> implicitly calls <a href="@ref"><code>Base.cconvert(Csize_t, n)</code></a>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Here is a second example wrapping the corresponding destructor:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="c"># The corresponding C signature is</span><span>
</span><span class="c">#     void gsl_permutation_free (gsl_permutation * p);</span><span>
</span><span class="k">function</span><span class="nf"> </span><span class="nf">permutation_free</span><span class="p">(</span><span class="n">p</span><span class="p">:</span><span class="p">:</span><span class="n">Ref</span><span class="p">{</span><span class="n">gsl_permutation</span><span class="p">}</span><span class="p">)</span><span>
</span><span>    </span><span class="k">ccall</span><span class="p">(</span><span>
</span><span>        </span><span class="p">(</span><span class="p">:</span><span class="n">gsl_permutation_free</span><span class="p">,</span><span> </span><span class="p">:</span><span class="n">libgsl</span><span class="p">)</span><span class="p">,</span><span> </span><span class="c">#name of C function and library</span><span>
</span><span>        </span><span class="n">Void</span><span class="p">,</span><span>                             </span><span class="c">#output type</span><span>
</span><span>        </span><span class="p">(</span><span class="n">Ref</span><span class="p">{</span><span class="n">gsl_permutation</span><span class="p">}</span><span class="p">,</span><span class="p">)</span><span class="p">,</span><span>          </span><span class="c">#tuple of input types</span><span>
</span><span>        </span><span class="n">p</span><span>                                 </span><span class="c">#name of Julia variable to pass in</span><span>
</span><span>    </span><span class="p">)</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Here, the input <code>p</code> is declared to be of type <code>Ref{gsl_permutation}</code>, meaning that the memory that <code>p</code> points to may be managed by Julia or by C. A pointer to memory allocated by C should be of type <code>Ptr{gsl_permutation}</code>, but it is convertable using <a href="@ref"><code>cconvert()</code></a> and therefore can be used in the same (covariant) context of the input argument to a <a href="@ref"><code>ccall()</code></a>. A pointer to memory allocated by Julia must be of type <code>Ref{gsl_permutation}</code>, to ensure that the memory address pointed to is valid and that Julia&#39;s garbage collector manages the chunk of memory pointed to correctly. Therefore, the <code>Ref{gsl_permutation}</code> declaration allows pointers managed by C or Julia to be used.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>If the C wrapper never expects the user to pass pointers to memory managed by Julia, then using <code>p::Ptr{gsl_permutation}</code> for the method signature of the wrapper and similarly in the <a href="@ref"><code>ccall()</code></a> is also acceptable.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Here is a third example passing Julia arrays:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="c"># The corresponding C signature is</span><span>
</span><span class="c">#    int gsl_sf_bessel_Jn_array (int nmin, int nmax, double x,</span><span>
</span><span class="c">#                                double result_array[])</span><span>
</span><span class="k">function</span><span class="nf"> </span><span class="nf">sf_bessel_Jn_array</span><span class="p">(</span><span class="n">nmin</span><span class="p">:</span><span class="p">:</span><span class="n">Integer</span><span class="p">,</span><span> </span><span class="n">nmax</span><span class="p">:</span><span class="p">:</span><span class="n">Integer</span><span class="p">,</span><span> </span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">Real</span><span class="p">)</span><span>
</span><span>    </span><span class="k">if</span><span> </span><span class="n">nmax</span><span class="o">&lt;</span><span class="n">nmin</span><span> </span><span class="nb">throw</span><span class="p">(</span><span class="n">DomainError</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span> </span><span class="k">end</span><span>
</span><span>    </span><span class="n">result_array</span><span> </span><span class="o">=</span><span> </span><span class="n">Array</span><span class="p">{</span><span class="n">Cdouble</span><span class="p">}</span><span class="p">(</span><span class="n">nmax</span><span class="o">-</span><span class="n">nmin</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span>
</span><span>    </span><span class="n">errorcode</span><span> </span><span class="o">=</span><span> </span><span class="k">ccall</span><span class="p">(</span><span>
</span><span>        </span><span class="p">(</span><span class="p">:</span><span class="n">gsl_sf_bessel_Jn_array</span><span class="p">,</span><span> </span><span class="p">:</span><span class="n">libgsl</span><span class="p">)</span><span class="p">,</span><span> </span><span class="c">#name of C function and library</span><span>
</span><span>        </span><span class="n">Cint</span><span class="p">,</span><span>                               </span><span class="c">#output type</span><span>
</span><span>        </span><span class="p">(</span><span class="n">Cint</span><span class="p">,</span><span> </span><span class="n">Cint</span><span class="p">,</span><span> </span><span class="n">Cdouble</span><span class="p">,</span><span> </span><span class="n">Ref</span><span class="p">{</span><span class="n">Cdouble</span><span class="p">}</span><span class="p">)</span><span class="p">,</span><span class="c">#tuple of input types</span><span>
</span><span>        </span><span class="n">nmin</span><span class="p">,</span><span> </span><span class="n">nmax</span><span class="p">,</span><span> </span><span class="n">x</span><span class="p">,</span><span> </span><span class="n">result_array</span><span>         </span><span class="c">#names of Julia variables to pass in</span><span>
</span><span>    </span><span class="p">)</span><span>
</span><span>    </span><span class="k">if</span><span> </span><span class="n">errorcode!</span><span class="o">=</span><span> </span><span class="mi">0</span><span> </span><span class="nb">error</span><span class="p">(</span><span class="s">&quot;</span><span class="s">GSL error code </span><span class="si">$</span><span class="s">errorcode</span><span class="s">&quot;</span><span class="p">)</span><span> </span><span class="k">end</span><span>
</span><span>    </span><span class="k">return</span><span> </span><span class="n">result_array</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The C function wrapped returns an integer error code; the results of the actual evaluation of the Bessel J function populate the Julia array <code>result_array</code>. This variable can only be used with corresponding input type declaration <code>Ref{Cdouble}</code>, since its memory is allocated and managed by Julia, not C. The implicit call to <a href="@ref"><code>Base.cconvert(Ref{Cdouble}, result_array)</code></a> unpacks the Julia pointer to a Julia array data structure into a form understandable by C.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Note that for this code to work correctly, <code>result_array</code> must be declared to be of type <code>Ref{Cdouble}</code> and not <code>Ptr{Cdouble}</code>. The memory is managed by Julia and the <code>Ref</code> signature alerts Julia&#39;s garbage collector to keep managing the memory for <code>result_array</code> while the <a href="@ref"><code>ccall()</code></a> executes. If <code>Ptr{Cdouble}</code> were used instead, the <a href="@ref"><code>ccall()</code></a> may still work, but Julia&#39;s garbage collector would not be aware that the memory declared for <code>result_array</code> is being used by the external C function. As a result, the code may produce a memory leak if <code>result_array</code> never gets freed by the garbage collector, or if the garbage collector prematurely frees <code>result_array</code>, the C function may end up throwing an invalid memory access exception.</p><a id="Garbage-Collection-Safety-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Garbage Collection Safety</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>When passing data to a <a href="@ref"><code>ccall()</code></a>, it is best to avoid using the <a href="@ref"><code>pointer()</code></a> function. Instead define a convert method and pass the variables directly to the <a href="@ref"><code>ccall()</code></a>. <a href="@ref"><code>ccall()</code></a> automatically arranges that all of its arguments will be preserved from garbage collection until the call returns. If a C API will store a reference to memory allocated by Julia, after the <a href="@ref"><code>ccall()</code></a> returns, you must arrange that the object remains visible to the garbage collector. The suggested way to handle this is to make a global variable of type <code>Array{Ref,1}</code> to hold these values, until the C library notifies you that it is finished with them.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Whenever you have created a pointer to Julia data, you must ensure the original data exists until you are done with using the pointer. Many methods in Julia such as <a href="@ref"><code>unsafe_load()</code></a> and <a href="../stdlib/strings.html#Core.String"><code>String()</code></a> make copies of data instead of taking ownership of the buffer, so that it is safe to free (or alter) the original data without affecting Julia. A notable exception is <a href="../stdlib/strings.html#Base.unsafe_wrap"><code>unsafe_wrap()</code></a> which, for performance reasons, shares (or can be told to take ownership of) the underlying buffer.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The garbage collector does not guarantee any order of finalization. That is, if <code>a</code> contained a reference to <code>b</code> and both <code>a</code> and <code>b</code> are due for garbage collection, there is no guarantee that <code>b</code> would be finalized after <code>a</code>. If proper finalization of <code>a</code> depends on <code>b</code> being valid, it must be handled in other ways.</p><a id="Non-constant-Function-Specifications-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Non-constant Function Specifications</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>A <code>(name, library)</code> function specification must be a constant expression. However, it is possible to use computed values as function names by staging through <code>eval</code> as follows:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">@eval ccall(($(string(&quot;a&quot;,&quot;b&quot;)),&quot;lib&quot;), ...</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This expression constructs a name using <code>string</code>, then substitutes this name into a new <a href="@ref"><code>ccall()</code></a> expression, which is then evaluated. Keep in mind that <code>eval</code> only operates at the top level, so within this expression local variables will not be available (unless their values are substituted with <code>$</code>). For this reason, <code>eval</code> is typically only used to form top-level definitions, for example when wrapping libraries that contain many similar functions.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>If your usage is more dynamic, use indirect calls as described in the next section.</p><a id="Indirect-Calls-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Indirect Calls</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The first argument to <a href="@ref"><code>ccall()</code></a> can also be an expression evaluated at run time. In this case, the expression must evaluate to a <code>Ptr</code>, which will be used as the address of the native function to call. This behavior occurs when the first <a href="@ref"><code>ccall()</code></a> argument contains references to non-constants, such as local variables, function arguments, or non-constant globals.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>For example, you might lookup the function via <code>dlsym</code>, then cache it in a global variable for that session. For example:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">macro</span><span> </span><span class="nb">dlsym</span><span class="p">(</span><span class="n">func</span><span class="p">,</span><span> </span><span class="n">lib</span><span class="p">)</span><span>
</span><span>    </span><span class="n">z</span><span class="p">,</span><span> </span><span class="n">zlocal</span><span> </span><span class="o">=</span><span> </span><span class="n">gensym</span><span class="p">(</span><span class="n">string</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="p">)</span><span class="p">,</span><span> </span><span class="n">gensym</span><span class="p">(</span><span class="p">)</span><span>
</span><span>    </span><span class="n">eval</span><span class="p">(</span><span class="n">current_module</span><span class="p">(</span><span class="p">)</span><span class="p">,</span><span class="p">:</span><span class="p">(</span><span class="kd">global</span><span> </span><span class="o">$</span><span class="n">z</span><span> </span><span class="o">=</span><span> </span><span class="n">C_NULL</span><span class="p">)</span><span class="p">)</span><span>
</span><span>    </span><span class="n">z</span><span> </span><span class="o">=</span><span> </span><span class="n">esc</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span>
</span><span>    </span><span class="k">quote</span><span>
</span><span>        </span><span class="k">let</span><span> </span><span class="o">$</span><span class="n">zlocal</span><span class="p">:</span><span class="p">:</span><span class="n">Ptr</span><span class="p">{</span><span class="n">Void</span><span class="p">}</span><span> </span><span class="o">=</span><span> </span><span class="o">$</span><span class="n">z</span><span class="p">:</span><span class="p">:</span><span class="n">Ptr</span><span class="p">{</span><span class="n">Void</span><span class="p">}</span><span>
</span><span>            </span><span class="k">if</span><span> </span><span class="o">$</span><span class="n">zlocal</span><span> </span><span class="o">==</span><span> </span><span class="n">C_NULL</span><span>
</span><span>               </span><span class="o">$</span><span class="n">zlocal</span><span> </span><span class="o">=</span><span> </span><span class="nb">dlsym</span><span class="p">(</span><span class="o">$</span><span class="p">(</span><span class="n">esc</span><span class="p">(</span><span class="n">lib</span><span class="p">)</span><span class="p">)</span><span class="p">:</span><span class="p">:</span><span class="n">Ptr</span><span class="p">{</span><span class="n">Void</span><span class="p">}</span><span class="p">,</span><span> </span><span class="o">$</span><span class="p">(</span><span class="n">esc</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="p">)</span><span class="p">)</span><span>
</span><span>               </span><span class="kd">global</span><span> </span><span class="o">$</span><span class="n">z</span><span> </span><span class="o">=</span><span> </span><span class="o">$</span><span class="n">zlocal</span><span>
</span><span>            </span><span class="k">end</span><span>
</span><span>            </span><span class="o">$</span><span class="n">zlocal</span><span>
</span><span>        </span><span class="k">end</span><span>
</span><span>    </span><span class="k">end</span><span>
</span><span class="k">end</span><span>
</span><span>
</span><span class="n">mylibvar</span><span> </span><span class="o">=</span><span> </span><span class="nb">dlopen</span><span class="p">(</span><span class="s">&quot;</span><span class="s">mylib</span><span class="s">&quot;</span><span class="p">)</span><span>
</span><span class="k">ccall</span><span class="p">(</span><span class="p">@</span><span class="nb">dlsym</span><span class="p">(</span><span class="s">&quot;</span><span class="s">myfunc</span><span class="s">&quot;</span><span class="p">,</span><span> </span><span class="n">mylibvar</span><span class="p">)</span><span class="p">,</span><span> </span><span class="n">Void</span><span class="p">,</span><span> </span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span>
</span></code></pre><a id="Calling-Convention-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Calling Convention</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The second argument to <a href="@ref"><code>ccall()</code></a> can optionally be a calling convention specifier (immediately preceding return type). Without any specifier, the platform-default C calling convention is used. Other supported conventions are: <code>stdcall</code>, <code>cdecl</code>, <code>fastcall</code>, and <code>thiscall</code>. For example (from <code>base/libc.jl</code>) we see the same <code>gethostname</code><a href="@ref"><code>ccall()</code></a> as above, but with the correct signature for Windows:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">hn</span><span> </span><span class="o">=</span><span> </span><span class="n">Array</span><span class="p">{</span><span class="n">UInt8</span><span class="p">}</span><span class="p">(</span><span class="mi">256</span><span class="p">)</span><span>
</span><span class="n">err</span><span> </span><span class="o">=</span><span> </span><span class="k">ccall</span><span class="p">(</span><span class="p">:</span><span class="n">gethostname</span><span class="p">,</span><span> </span><span class="n">stdcall</span><span class="p">,</span><span> </span><span class="kt">Int32</span><span class="p">,</span><span> </span><span class="p">(</span><span class="n">Ptr</span><span class="p">{</span><span class="n">UInt8</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">UInt32</span><span class="p">)</span><span class="p">,</span><span> </span><span class="n">hn</span><span class="p">,</span><span> </span><span class="n">length</span><span class="p">(</span><span class="n">hn</span><span class="p">)</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>For more information, please see the <a href="http://llvm.org/docs/LangRef.html#calling-conventions">LLVM Language Reference</a>.</p><a id="Accessing-Global-Variables-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Accessing Global Variables</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Global variables exported by native libraries can be accessed by name using the <a href="@ref"><code>cglobal()</code></a> function. The arguments to <a href="@ref"><code>cglobal()</code></a> are a symbol specification identical to that used by <a href="@ref"><code>ccall()</code></a>, and a type describing the value stored in the variable:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">cglobal</span><span class="p">(</span><span class="p">(</span><span class="p">:</span><span class="n">errno</span><span class="p">,</span><span class="p">:</span><span class="n">libc</span><span class="p">)</span><span class="p">,</span><span> </span><span class="kt">Int32</span><span class="p">)</span><span>
</span><span class="go">Ptr{Int32} @0x00007f418d0816b8
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The result is a pointer giving the address of the value. The value can be manipulated through this pointer using <a href="@ref"><code>unsafe_load()</code></a> and <code>unsafe_store()</code>.</p><a id="Accessing-Data-through-a-Pointer-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Accessing Data through a Pointer</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The following methods are described as &quot;unsafe&quot; because a bad pointer or type declaration can cause Julia to terminate abruptly.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Given a <code>Ptr{T}</code>, the contents of type <code>T</code> can generally be copied from the referenced memory into a Julia object using <code>unsafe_load(ptr, [index])</code>. The index argument is optional (default is 1), and follows the Julia-convention of 1-based indexing. This function is intentionally similar to the behavior of <a href="../stdlib/collections.html#Base.getindex"><code>getindex()</code></a> and <a href="../stdlib/collections.html#Base.setindex!"><code>setindex!()</code></a> (e.g. <code>[]</code> access syntax).</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The return value will be a new object initialized to contain a copy of the contents of the referenced memory. The referenced memory can safely be freed or released.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>If <code>T</code> is <code>Any</code>, then the memory is assumed to contain a reference to a Julia object (a <code>jl_value_t*</code>), the result will be a reference to this object, and the object will not be copied. You must be careful in this case to ensure that the object was always visible to the garbage collector (pointers do not count, but the new reference does) to ensure the memory is not prematurely freed. Note that if the object was not originally allocated by Julia, the new object will never be finalized by Julia&#39;s garbage collector.  If the <code>Ptr</code> itself is actually a <code>jl_value_t*</code>, it can be converted back to a Julia object reference by <a href="@ref"><code>unsafe_pointer_to_objref(ptr)</code></a>. (Julia values <code>v</code> can be converted to <code>jl_value_t*</code> pointers, as <code>Ptr{Void}</code>, by calling <a href="@ref"><code>pointer_from_objref(v)</code></a>.)</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The reverse operation (writing data to a <code>Ptr{T}</code>), can be performed using <a href="@ref"><code>unsafe_store!(ptr, value, [index])</code></a>.  Currently, this is only supported for bitstypes or other pointer-free (<code>isbits</code>) immutable types.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Any operation that throws an error is probably currently unimplemented and should be posted as a bug so that it can be resolved.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>If the pointer of interest is a plain-data array (bitstype or immutable), the function <a href="../stdlib/strings.html#Base.unsafe_wrap"><code>unsafe_wrap(Array, ptr,dims,[own])</code></a> may be more useful. The final parameter should be true if Julia should &quot;take ownership&quot; of the underlying buffer and call <code>free(ptr)</code> when the returned <code>Array</code> object is finalized.  If the <code>own</code> parameter is omitted or false, the caller must ensure the buffer remains in existence until all access is complete.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Arithmetic on the <code>Ptr</code> type in Julia (e.g. using <code>+</code>) does not behave the same as C&#39;s pointer arithmetic. Adding an integer to a <code>Ptr</code> in Julia always moves the pointer by some number of <em>bytes</em>, not elements. This way, the address values obtained from pointer arithmetic do not depend on the element types of pointers.</p><a id="Thread-safety-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Thread-safety</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Some C libraries execute their callbacks from a different thread, and since Julia isn&#39;t thread-safe you&#39;ll need to take some extra precautions. In particular, you&#39;ll need to set up a two-layered system: the C callback should only <em>schedule</em> (via Julia&#39;s event loop) the execution of your &quot;real&quot; callback. To do this, create a <code>AsyncCondition</code> object and wait on it:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">cond</span><span> </span><span class="o">=</span><span> </span><span class="n">Base</span><span class="o">.</span><span class="n">AsyncCondition</span><span class="p">(</span><span class="p">)</span><span>
</span><span class="n">wait</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The callback you pass to C should only execute a <a href="@ref"><code>ccall()</code></a> to <code>:uv_async_send</code>, passing <code>cb.handle</code> as the argument, taking care to avoid any allocations or other interactions with the Julia runtime.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Note that events may be coalesced, so multiple calls to uv_async_send may result in a single wakeup notification to the condition.</p><a id="More-About-Callbacks-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>More About Callbacks</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>For more details on how to pass callbacks to C libraries, see this <a href="http://julialang.org/blog/2013/05/callback/">blog post</a>.</p><a id="C-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>C++</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Limited support for C++ is provided by the <a href="https://github.com/timholy/Cpp.jl">Cpp</a>, <a href="https://github.com/ihnorton/Clang.jl">Clang</a>, and <a href="https://github.com/Keno/Cxx.jl">Cxx</a> packages.</p><footer><hr/><a class="previous" href="arrays.html"><span class="direction">Previous</span><span class="title">Multi-dimensional Arrays</span></a><a class="next" href="complex-and-rational-numbers.html"><span class="direction">Next</span><span class="title">Complex and Rational Numbers</span></a></footer></article></body></html>
