<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Documenter.jl</title><link href="../normalize.css" rel="stylesheet" type="text/css"/><link href="../style.css" rel="stylesheet" type="text/css"/><link href="../highlight.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="../require.js" data-main="../documenter.js"></script><script src="../search-index.js"></script></head><body><nav class="toc"><a href="http://julialang.org/"><img class="logo" src="http://docs.julialang.org/en/release-0.4/_static/julia-logo.svg" alt="\$pkgname.jl logo"/></a><h1>$pkgname.jl</h1><input type="text" placeholder="Search docs"/><ul><li><a class="toctext" href="../index.html">Overview</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../man/guide.html">Guide</a></li><li><a class="toctext" href="../man/examples.html">Examples</a></li><li><a class="toctext" href="../man/syntax.html">Syntax</a></li><li><a class="toctext" href="../man/doctests.html">Doctests</a></li><li><a class="toctext" href="../man/hosting.html">Hosting Documentation</a></li><li><a class="toctext" href="../man/latex.html"><span>$\LaTeX$</span> syntax</a></li><li><a class="toctext" href="../man/internals.html">Package Internals</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../lib/public.html">Public Documentation</a></li><li><a class="toctext" href="../lib/internals.html">Internal Documentation</a></li></ul></li><li><span class="toctext">Dynamic pages</span><ul><li><a class="toctext" href="../dynamic/code.html">Code examples</a></li><li><a class="toctext" href="../dynamic/admonitions.html">Admonitions &amp; Co</a></li><li><a class="toctext" href="../dynamic/styles.html">Demonstrating <em>styles</em> of MD elements</a></li><li><a class="toctext" href="../dynamic/bugs.html">Some existing bugs</a></li></ul></li><li><span class="toctext">JuliaDocs - Manual</span><ul><li><a class="toctext" href="arrays.html">Multi-dimensional Arrays</a></li><li><a class="toctext" href="calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="toctext" href="complex-and-rational-numbers.html">Complex and Rational Numbers</a></li><li><a class="toctext" href="constructors.html">Constructors</a></li><li><a class="toctext" href="control-flow.html">Control Flow</a></li><li><a class="toctext" href="conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="toctext" href="dates.html">Date and DateTime</a></li><li><a class="toctext" href="documentation.html">Documentation</a></li><li><a class="toctext" href="embedding.html">Embedding Julia</a></li><li><a class="toctext" href="faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="functions.html">Functions</a></li><li><a class="toctext" href="getting-started.html">Getting Started</a></li><li><a class="toctext" href="handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="index.html">The Julia Manual</a></li><li><a class="toctext" href="integers-and-floating-point-numbers.html">Integers and Floating-Point Numbers</a></li><li><a class="toctext" href="interacting-with-julia.html">Interacting With Julia</a></li><li><a class="toctext" href="interfaces.html">Interfaces</a></li><li><a class="toctext" href="introduction.html">Introduction</a></li><li><a class="toctext" href="linear-algebra.html">Linear algebra</a></li><li><a class="toctext" href="mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="metaprogramming.html">Metaprogramming</a></li><li><a class="toctext" href="methods.html">Methods</a></li><li><a class="toctext" href="modules.html">Modules</a></li><li class="current"><a class="toctext" href="networking-and-streams.html">Networking and Streams</a><ul class="internal"><li><a class="toctext" href="#Basic-Stream-I/O-1">Basic Stream I/O</a></li><li><a class="toctext" href="#Text-I/O-1">Text I/O</a></li><li><a class="toctext" href="#IO-Output-Contextual-Properties-1">IO Output Contextual Properties</a></li><li><a class="toctext" href="#Working-with-Files-1">Working with Files</a></li><li><a class="toctext" href="#A-simple-TCP-example-1">A simple TCP example</a></li><li><a class="toctext" href="#Resolving-IP-Addresses-1">Resolving IP Addresses</a></li></ul></li><li><a class="toctext" href="noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="packages.html">Packages</a></li><li><a class="toctext" href="parallel-computing.html">Parallel Computing</a></li><li><a class="toctext" href="performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="profile.html">Profiling</a></li><li><a class="toctext" href="running-external-programs.html">Running External Programs</a></li><li><a class="toctext" href="stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="strings.html">Strings</a></li><li><a class="toctext" href="style-guide.html">Style Guide</a></li><li><a class="toctext" href="types.html">Types</a></li><li><a class="toctext" href="unicode-input.html">Unicode Input</a></li><li><a class="toctext" href="variables-and-scoping.html">Scope of Variables</a></li><li><a class="toctext" href="variables.html">Variables</a></li><li><a class="toctext" href="workflow-tips.html">Workflow Tips</a></li></ul></li><li><span class="toctext">JuliaDocs - Standard Libary</span><ul><li><a class="toctext" href="../stdlib/arrays.html">Arrays</a></li><li><a class="toctext" href="../stdlib/base.html">Essentials</a></li><li><a class="toctext" href="../stdlib/c.html">C Interface</a></li><li><a class="toctext" href="../stdlib/collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="../stdlib/constants.html">Constants</a></li><li><a class="toctext" href="../stdlib/dates.html">Dates and Time</a></li><li><a class="toctext" href="../stdlib/file.html">Filesystem</a></li><li><a class="toctext" href="../stdlib/index.html">The Julia Standard Library</a></li><li><a class="toctext" href="../stdlib/io-network.html">I/O and Network</a></li><li><a class="toctext" href="../stdlib/libc.html">C Standard Library</a></li><li><a class="toctext" href="../stdlib/libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="../stdlib/linalg.html">Linear Algebra</a></li><li><a class="toctext" href="../stdlib/math.html">Mathematics</a></li><li><a class="toctext" href="../stdlib/numbers.html">Numbers</a></li><li><a class="toctext" href="../stdlib/parallel.html">Tasks and Parallel Computing</a></li><li><a class="toctext" href="../stdlib/pkg.html">Package Manager Functions</a></li><li><a class="toctext" href="../stdlib/profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/punctuation.html">Punctuation</a></li><li><a class="toctext" href="../stdlib/simd-types.html">SIMD Support</a></li><li><a class="toctext" href="../stdlib/sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="../stdlib/stacktraces.html">StackTraces</a></li><li><a class="toctext" href="../stdlib/strings.html">Strings</a></li><li><a class="toctext" href="../stdlib/test.html">Unit Testing</a></li></ul></li><li><span class="toctext">JuliaDocs - DevDocs</span><ul><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/C.html">Developing/debugging Julia&#39;s C code</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../devdocs/julia.html">Documentation of Julia&#39;s Internals</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/promote-op.html">Operator-sensitive promotion</a></li><li><a class="toctext" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/types.html">More about types</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>JuliaDocs - Manual</li><li><a href="networking-and-streams.html">Networking and Streams</a></li></ul><a class="edit-page" href="https://github.com/"><span class="fa">ï‚›</span> Edit on GitHub</a></nav><hr/></header><a id="Networking-and-Streams-1"></a><div class="mdnote debug">Base.Markdown.Header{1}</div><h1>Networking and Streams</h1><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Julia provides a rich interface to deal with streaming I/O objects such as terminals, pipes and TCP sockets. This interface, though asynchronous at the system level, is presented in a synchronous manner to the programmer and it is usually unnecessary to think about the underlying asynchronous operation. This is achieved by making heavy use of Julia cooperative threading (<a href="@ref">coroutine</a>) functionality.</p><a id="Basic-Stream-I/O-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Basic Stream I/O</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>All Julia streams expose at least a <a href="../stdlib/io-network.html#Base.read"><code>read()</code></a> and a <a href="../stdlib/io-network.html#Base.write"><code>write()</code></a> method, taking the stream as their first argument, e.g.:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">write</span><span class="p">(</span><span class="n">STDOUT</span><span class="p">,</span><span class="s">&quot;</span><span class="s">Hello World</span><span class="s">&quot;</span><span class="p">)</span><span class="p">;</span><span>  </span><span class="c"># suppress return value 11 with ;</span><span>
</span><span class="go">Hello World
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">read</span><span class="p">(</span><span class="n">STDIN</span><span class="p">,</span><span class="n">Char</span><span class="p">)</span><span>
</span><span class="go">
</span><span class="go">&#39;\n&#39;
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Note that <a href="../stdlib/io-network.html#Base.write"><code>write()</code></a> returns 11, the number of bytes (in <code>&quot;Hello World&quot;</code>) written to <a href="../stdlib/io-network.html#Base.STDOUT"><code>STDOUT</code></a>, but this return value is suppressed with the <code>;</code>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Here Enter was pressed again so that Julia would read the newline. Now, as you can see from this example, <a href="../stdlib/io-network.html#Base.write"><code>write()</code></a> takes the data to write as its second argument, while <a href="../stdlib/io-network.html#Base.read"><code>read()</code></a> takes the type of the data to be read as the second argument.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>For example, to read a simple byte array, we could do:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">x</span><span> </span><span class="o">=</span><span> </span><span class="n">zeros</span><span class="p">(</span><span class="n">UInt8</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span>
</span><span class="go">4-element Array{UInt8,1}:
</span><span class="go"> 0x00
</span><span class="go"> 0x00
</span><span class="go"> 0x00
</span><span class="go"> 0x00
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">read!</span><span class="p">(</span><span class="n">STDIN</span><span class="p">,</span><span class="n">x</span><span class="p">)</span><span>
</span><span class="go">abcd
</span><span class="go">4-element Array{UInt8,1}:
</span><span class="go"> 0x61
</span><span class="go"> 0x62
</span><span class="go"> 0x63
</span><span class="go"> 0x64
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>However, since this is slightly cumbersome, there are several convenience methods provided. For example, we could have written the above as:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">read</span><span class="p">(</span><span class="n">STDIN</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span>
</span><span class="go">abcd
</span><span class="go">4-element Array{UInt8,1}:
</span><span class="go"> 0x61
</span><span class="go"> 0x62
</span><span class="go"> 0x63
</span><span class="go"> 0x64
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>or if we had wanted to read the entire line instead:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">readline</span><span class="p">(</span><span class="n">STDIN</span><span class="p">)</span><span>
</span><span class="go">abcd
</span><span class="go">&quot;abcd\n&quot;
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Note that depending on your terminal settings, your TTY may be line buffered and might thus require an additional enter before the data is sent to Julia.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>To read every line from <a href="../stdlib/io-network.html#Base.STDIN"><code>STDIN</code></a> you can use <a href="../stdlib/io-network.html#Base.eachline"><code>eachline()</code></a>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">for</span><span> </span><span class="n">line</span><span> </span><span class="k">in</span><span> </span><span class="n">eachline</span><span class="p">(</span><span class="n">STDIN</span><span class="p">)</span><span>
</span><span>    </span><span class="n">print</span><span class="p">(</span><span class="s">&quot;</span><span class="s">Found </span><span class="si">$</span><span class="s">line</span><span class="s">&quot;</span><span class="p">)</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>or <a href="../stdlib/io-network.html#Base.read"><code>read()</code></a> if you wanted to read by character instead:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">while</span><span> </span><span class="o">!</span><span class="n">eof</span><span class="p">(</span><span class="n">STDIN</span><span class="p">)</span><span>
</span><span>    </span><span class="n">x</span><span> </span><span class="o">=</span><span> </span><span class="n">read</span><span class="p">(</span><span class="n">STDIN</span><span class="p">,</span><span> </span><span class="n">Char</span><span class="p">)</span><span>
</span><span>    </span><span class="n">println</span><span class="p">(</span><span class="s">&quot;</span><span class="s">Found: </span><span class="si">$</span><span class="s">x</span><span class="s">&quot;</span><span class="p">)</span><span>
</span><span class="k">end</span><span>
</span></code></pre><a id="Text-I/O-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Text I/O</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Note that the <a href="../stdlib/io-network.html#Base.write"><code>write()</code></a> method mentioned above operates on binary streams. In particular, values do not get converted to any canonical text representation but are written out as is:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">write</span><span class="p">(</span><span class="n">STDOUT</span><span class="p">,</span><span class="mh">0x61</span><span class="p">)</span><span class="p">;</span><span>  </span><span class="c"># suppress return value 1 with ;</span><span>
</span><span class="go">a
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Note that <code>a</code> is written to <a href="../stdlib/io-network.html#Base.STDOUT"><code>STDOUT</code></a> by the <a href="../stdlib/io-network.html#Base.write"><code>write()</code></a> function and that the returned value is <code>1</code> (since <code>0x61</code> is one byte).</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>For text I/O, use the <a href="../stdlib/io-network.html#Base.print"><code>print()</code></a> or <a href="../stdlib/io-network.html#Base.show"><code>show()</code></a> methods, depending on your needs (see the standard library reference for a detailed discussion of the difference between the two):</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">print</span><span class="p">(</span><span class="n">STDOUT</span><span class="p">,</span><span class="mh">0x61</span><span class="p">)</span><span>
</span><span class="go">97
</span></code></pre><a id="IO-Output-Contextual-Properties-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>IO Output Contextual Properties</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Sometimes IO output can benefit from the ability to pass contextual information into show methods. The <code>IOContext</code> object provides this framework for associating arbitrary metadata with an IO object. For example, <code>showcompact</code> adds a hinting parameter to the IO object that the invoked show method should print a shorter output (if applicable).</p><a id="Working-with-Files-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Working with Files</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Like many other environments, Julia has an <a href="../stdlib/io-network.html#Base.open"><code>open()</code></a> function, which takes a filename and returns an <code>IOStream</code> object that you can use to read and write things from the file. For example if we have a file, <code>hello.txt</code>, whose contents are <code>Hello, World!</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">f</span><span> </span><span class="o">=</span><span> </span><span class="n">open</span><span class="p">(</span><span class="s">&quot;</span><span class="s">hello.txt</span><span class="s">&quot;</span><span class="p">)</span><span>
</span><span class="go">IOStream(&lt;file hello.txt&gt;)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">readlines</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span>
</span><span class="go">1-element Array{String,1}:
</span><span class="go"> &quot;Hello, World!\n&quot;
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>If you want to write to a file, you can open it with the write (<code>&quot;w&quot;</code>) flag:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">f</span><span> </span><span class="o">=</span><span> </span><span class="n">open</span><span class="p">(</span><span class="s">&quot;</span><span class="s">hello.txt</span><span class="s">&quot;</span><span class="p">,</span><span class="s">&quot;</span><span class="s">w</span><span class="s">&quot;</span><span class="p">)</span><span>
</span><span class="go">IOStream(&lt;file hello.txt&gt;)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">write</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="s">&quot;</span><span class="s">Hello again.</span><span class="s">&quot;</span><span class="p">)</span><span>
</span><span class="go">12
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>If you examine the contents of <code>hello.txt</code> at this point, you will notice that it is empty; nothing has actually been written to disk yet. This is because the <code>IOStream</code> must be closed before the write is actually flushed to disk:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">close</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Examining <code>hello.txt</code> again will show its contents have been changed.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Opening a file, doing something to its contents, and closing it again is a very common pattern. To make this easier, there exists another invocation of <a href="../stdlib/io-network.html#Base.open"><code>open()</code></a> which takes a function as its first argument and filename as its second, opens the file, calls the function with the file as an argument, and then closes it again. For example, given a function:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">function</span><span class="nf"> </span><span class="nf">read_and_capitalize</span><span class="p">(</span><span class="n">f</span><span class="p">:</span><span class="p">:</span><span class="n">IOStream</span><span class="p">)</span><span>
</span><span>    </span><span class="k">return</span><span> </span><span class="n">uppercase</span><span class="p">(</span><span class="n">readstring</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>You can call:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">open</span><span class="p">(</span><span class="n">read_and_capitalize</span><span class="p">,</span><span> </span><span class="s">&quot;</span><span class="s">hello.txt</span><span class="s">&quot;</span><span class="p">)</span><span>
</span><span class="go">&quot;HELLO AGAIN.&quot;
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>to open <code>hello.txt</code>, call <code>read_and_capitalize on it</code>, close <code>hello.txt</code> and return the capitalized contents.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>To avoid even having to define a named function, you can use the <code>do</code> syntax, which creates an anonymous function on the fly:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">open</span><span class="p">(</span><span class="s">&quot;</span><span class="s">hello.txt</span><span class="s">&quot;</span><span class="p">)</span><span> </span><span class="k">do</span><span> </span><span class="n">f</span><span>
</span><span class="gt">
          uppercase(readstring(f))
</span><span></span><span class="gt">
       end
</span><span></span><span class="go">&quot;HELLO AGAIN.&quot;
</span></code></pre><a id="A-simple-TCP-example-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>A simple TCP example</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Let&#39;s jump right in with a simple example involving TCP sockets. Let&#39;s first create a simple server:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="p">@</span><span class="n">async</span><span> </span><span class="k">begin</span><span>
</span><span class="gt">
         server = listen(2000)
</span><span></span><span class="gt">
         while true
</span><span></span><span class="gt">
           sock = accept(server)
</span><span></span><span class="gt">
           println(&quot;Hello World\n&quot;)
</span><span></span><span class="gt">
         end
</span><span></span><span class="gt">
       end
</span><span></span><span class="go">Task (runnable) @0x00007fd31dc11ae0
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>To those familiar with the Unix socket API, the method names will feel familiar, though their usage is somewhat simpler than the raw Unix socket API. The first call to <a href="../stdlib/io-network.html#Base.listen"><code>listen()</code></a> will create a server waiting for incoming connections on the specified port (2000) in this case. The same function may also be used to create various other kinds of servers:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">listen</span><span class="p">(</span><span class="mi">2000</span><span class="p">)</span><span> </span><span class="c"># Listens on localhost:2000 (IPv4)</span><span>
</span><span class="go">TCPServer(active)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">listen</span><span class="p">(</span><span class="n">ip</span><span class="s">&quot;</span><span class="s">127.0.0.1</span><span class="s">&quot;</span><span class="p">,</span><span class="mi">2000</span><span class="p">)</span><span> </span><span class="c"># Equivalent to the first</span><span>
</span><span class="go">TCPServer(active)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">listen</span><span class="p">(</span><span class="n">ip</span><span class="s">&quot;</span><span class="s">::1</span><span class="s">&quot;</span><span class="p">,</span><span class="mi">2000</span><span class="p">)</span><span> </span><span class="c"># Listens on localhost:2000 (IPv6)</span><span>
</span><span class="go">TCPServer(active)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">listen</span><span class="p">(</span><span class="n">IPv4</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="p">,</span><span class="mi">2001</span><span class="p">)</span><span> </span><span class="c"># Listens on port 2001 on all IPv4 interfaces</span><span>
</span><span class="go">TCPServer(active)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">listen</span><span class="p">(</span><span class="n">IPv6</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="p">,</span><span class="mi">2001</span><span class="p">)</span><span> </span><span class="c"># Listens on port 2001 on all IPv6 interfaces</span><span>
</span><span class="go">TCPServer(active)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">listen</span><span class="p">(</span><span class="s">&quot;</span><span class="s">testsocket</span><span class="s">&quot;</span><span class="p">)</span><span> </span><span class="c"># Listens on a domain socket/named pipe</span><span>
</span><span class="go">PipeServer(active)
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Note that the return type of the last invocation is different. This is because this server does not listen on TCP, but rather on a named pipe (Windows) or domain socket (UNIX). The difference is subtle and has to do with the <a href="../stdlib/io-network.html#Base.accept"><code>accept()</code></a> and <a href="../stdlib/io-network.html#Base.connect"><code>connect()</code></a> methods. The <a href="../stdlib/io-network.html#Base.accept"><code>accept()</code></a> method retrieves a connection to the client that is connecting on the server we just created, while the <a href="../stdlib/io-network.html#Base.connect"><code>connect()</code></a> function connects to a server using the specified method. The <a href="../stdlib/io-network.html#Base.connect"><code>connect()</code></a> function takes the same arguments as <a href="../stdlib/io-network.html#Base.listen"><code>listen()</code></a>, so, assuming the environment (i.e. host, cwd, etc.) is the same you should be able to pass the same arguments to <a href="../stdlib/io-network.html#Base.connect"><code>connect()</code></a> as you did to listen to establish the connection. So let&#39;s try that out (after having created the server above):</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">connect</span><span class="p">(</span><span class="mi">2000</span><span class="p">)</span><span>
</span><span class="go">TCPSocket(open, 0 bytes waiting)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Hello</span><span> </span><span class="n">World</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>As expected we saw &quot;Hello World&quot; printed. So, let&#39;s actually analyze what happened behind the scenes. When we called <a href="../stdlib/io-network.html#Base.connect"><code>connect()</code></a>, we connect to the server we had just created. Meanwhile, the accept function returns a server-side connection to the newly created socket and prints &quot;Hello World&quot; to indicate that the connection was successful.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>A great strength of Julia is that since the API is exposed synchronously even though the I/O is actually happening asynchronously, we didn&#39;t have to worry callbacks or even making sure that the server gets to run. When we called <a href="../stdlib/io-network.html#Base.connect"><code>connect()</code></a> the current task waited for the connection to be established and only continued executing after that was done. In this pause, the server task resumed execution (because a connection request was now available), accepted the connection, printed the message and waited for the next client. Reading and writing works in the same way. To see this, consider the following simple echo server:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="p">@</span><span class="n">async</span><span> </span><span class="k">begin</span><span>
</span><span class="gt">
         server = listen(2001)
</span><span></span><span class="gt">
         while true
</span><span></span><span class="gt">
           sock = accept(server)
</span><span></span><span class="gt">
           @async while isopen(sock)
</span><span></span><span class="gt">
             write(sock,readline(sock))
</span><span></span><span class="gt">
           end
</span><span></span><span class="gt">
         end
</span><span></span><span class="gt">
       end
</span><span></span><span class="go">Task (runnable) @0x00007fd31dc12e60
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">clientside</span><span class="o">=</span><span class="n">connect</span><span class="p">(</span><span class="mi">2001</span><span class="p">)</span><span>
</span><span class="go">TCPSocket(open, 0 bytes waiting)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="p">@</span><span class="n">async</span><span> </span><span class="k">while</span><span> </span><span class="n">true</span><span>
</span><span class="gt">
          write(STDOUT,readline(clientside))
</span><span></span><span class="gt">
       end
</span><span></span><span class="go">Task (runnable) @0x00007fd31dc11870
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">println</span><span class="p">(</span><span class="n">clientside</span><span class="p">,</span><span class="s">&quot;</span><span class="s">Hello World from the Echo Server</span><span class="s">&quot;</span><span class="p">)</span><span>
</span><span class="go">Hello World from the Echo Server
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>As with other streams, use <a href="../stdlib/io-network.html#Base.close"><code>close()</code></a> to disconnect the socket:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">close</span><span class="p">(</span><span class="n">clientside</span><span class="p">)</span><span>
</span></code></pre><a id="Resolving-IP-Addresses-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Resolving IP Addresses</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>One of the <a href="../stdlib/io-network.html#Base.connect"><code>connect()</code></a> methods that does not follow the <a href="../stdlib/io-network.html#Base.listen"><code>listen()</code></a> methods is <code>connect(host::String,port)</code>, which will attempt to connect to the host given by the <code>host</code> parameter on the port given by the port parameter. It allows you to do things like:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">connect</span><span class="p">(</span><span class="s">&quot;</span><span class="s">google.com</span><span class="s">&quot;</span><span class="p">,</span><span class="mi">80</span><span class="p">)</span><span>
</span><span class="go">TCPSocket(open, 0 bytes waiting)
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>At the base of this functionality is <a href="../stdlib/io-network.html#Base.getaddrinfo"><code>getaddrinfo()</code></a>, which will do the appropriate address resolution:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">getaddrinfo</span><span class="p">(</span><span class="s">&quot;</span><span class="s">google.com</span><span class="s">&quot;</span><span class="p">)</span><span>
</span><span class="go">IPv4(74.125.226.225)
</span></code></pre><footer><hr/><a class="previous" href="modules.html"><span class="direction">Previous</span><span class="title">Modules</span></a><a class="next" href="noteworthy-differences.html"><span class="direction">Next</span><span class="title">Noteworthy Differences from other Languages</span></a></footer></article></body></html>
