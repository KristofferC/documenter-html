<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Documenter.jl</title><link href="../normalize.css" rel="stylesheet" type="text/css"/><link href="../style.css" rel="stylesheet" type="text/css"/><link href="../highlight.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="../require.js" data-main="../documenter.js"></script><script src="../search-index.js"></script></head><body><nav class="toc"><a href="http://julialang.org/"><img class="logo" src="http://docs.julialang.org/en/release-0.4/_static/julia-logo.svg" alt="\$pkgname.jl logo"/></a><h1>$pkgname.jl</h1><input type="text" placeholder="Search docs"/><ul><li><a class="toctext" href="../index.html">Overview</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../man/guide.html">Guide</a></li><li><a class="toctext" href="../man/examples.html">Examples</a></li><li><a class="toctext" href="../man/syntax.html">Syntax</a></li><li><a class="toctext" href="../man/doctests.html">Doctests</a></li><li><a class="toctext" href="../man/hosting.html">Hosting Documentation</a></li><li><a class="toctext" href="../man/latex.html"><span>$\LaTeX$</span> syntax</a></li><li><a class="toctext" href="../man/internals.html">Package Internals</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../lib/public.html">Public Documentation</a></li><li><a class="toctext" href="../lib/internals.html">Internal Documentation</a></li></ul></li><li><span class="toctext">Dynamic pages</span><ul><li><a class="toctext" href="../dynamic/code.html">Code examples</a></li><li><a class="toctext" href="../dynamic/admonitions.html">Admonitions &amp; Co</a></li><li><a class="toctext" href="../dynamic/styles.html">Demonstrating <em>styles</em> of MD elements</a></li><li><a class="toctext" href="../dynamic/bugs.html">Some existing bugs</a></li></ul></li><li><span class="toctext">JuliaDocs - Manual</span><ul><li><a class="toctext" href="arrays.html">Multi-dimensional Arrays</a></li><li><a class="toctext" href="calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="toctext" href="complex-and-rational-numbers.html">Complex and Rational Numbers</a></li><li class="current"><a class="toctext" href="constructors.html">Constructors</a><ul class="internal"><li><a class="toctext" href="#Outer-Constructor-Methods-1">Outer Constructor Methods</a></li><li><a class="toctext" href="#Inner-Constructor-Methods-1">Inner Constructor Methods</a></li><li><a class="toctext" href="#Incomplete-Initialization-1">Incomplete Initialization</a></li><li><a class="toctext" href="#Parametric-Constructors-1">Parametric Constructors</a></li><li><a class="toctext" href="#Case-Study:-Rational-1">Case Study: Rational</a></li><li><a class="toctext" href="#Constructors-and-Conversion-1">Constructors and Conversion</a></li><li><a class="toctext" href="#Outer-only-constructors-1">Outer-only constructors</a></li></ul></li><li><a class="toctext" href="control-flow.html">Control Flow</a></li><li><a class="toctext" href="conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="toctext" href="dates.html">Date and DateTime</a></li><li><a class="toctext" href="documentation.html">Documentation</a></li><li><a class="toctext" href="embedding.html">Embedding Julia</a></li><li><a class="toctext" href="faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="functions.html">Functions</a></li><li><a class="toctext" href="getting-started.html">Getting Started</a></li><li><a class="toctext" href="handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="index.html">The Julia Manual</a></li><li><a class="toctext" href="integers-and-floating-point-numbers.html">Integers and Floating-Point Numbers</a></li><li><a class="toctext" href="interacting-with-julia.html">Interacting With Julia</a></li><li><a class="toctext" href="interfaces.html">Interfaces</a></li><li><a class="toctext" href="introduction.html">Introduction</a></li><li><a class="toctext" href="linear-algebra.html">Linear algebra</a></li><li><a class="toctext" href="mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="metaprogramming.html">Metaprogramming</a></li><li><a class="toctext" href="methods.html">Methods</a></li><li><a class="toctext" href="modules.html">Modules</a></li><li><a class="toctext" href="networking-and-streams.html">Networking and Streams</a></li><li><a class="toctext" href="noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="packages.html">Packages</a></li><li><a class="toctext" href="parallel-computing.html">Parallel Computing</a></li><li><a class="toctext" href="performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="profile.html">Profiling</a></li><li><a class="toctext" href="running-external-programs.html">Running External Programs</a></li><li><a class="toctext" href="stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="strings.html">Strings</a></li><li><a class="toctext" href="style-guide.html">Style Guide</a></li><li><a class="toctext" href="types.html">Types</a></li><li><a class="toctext" href="unicode-input.html">Unicode Input</a></li><li><a class="toctext" href="variables-and-scoping.html">Scope of Variables</a></li><li><a class="toctext" href="variables.html">Variables</a></li><li><a class="toctext" href="workflow-tips.html">Workflow Tips</a></li></ul></li><li><span class="toctext">JuliaDocs - Standard Libary</span><ul><li><a class="toctext" href="../stdlib/arrays.html">Arrays</a></li><li><a class="toctext" href="../stdlib/base.html">Essentials</a></li><li><a class="toctext" href="../stdlib/c.html">C Interface</a></li><li><a class="toctext" href="../stdlib/collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="../stdlib/constants.html">Constants</a></li><li><a class="toctext" href="../stdlib/dates.html">Dates and Time</a></li><li><a class="toctext" href="../stdlib/file.html">Filesystem</a></li><li><a class="toctext" href="../stdlib/index.html">The Julia Standard Library</a></li><li><a class="toctext" href="../stdlib/io-network.html">I/O and Network</a></li><li><a class="toctext" href="../stdlib/libc.html">C Standard Library</a></li><li><a class="toctext" href="../stdlib/libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="../stdlib/linalg.html">Linear Algebra</a></li><li><a class="toctext" href="../stdlib/math.html">Mathematics</a></li><li><a class="toctext" href="../stdlib/numbers.html">Numbers</a></li><li><a class="toctext" href="../stdlib/parallel.html">Tasks and Parallel Computing</a></li><li><a class="toctext" href="../stdlib/pkg.html">Package Manager Functions</a></li><li><a class="toctext" href="../stdlib/profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/punctuation.html">Punctuation</a></li><li><a class="toctext" href="../stdlib/simd-types.html">SIMD Support</a></li><li><a class="toctext" href="../stdlib/sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="../stdlib/stacktraces.html">StackTraces</a></li><li><a class="toctext" href="../stdlib/strings.html">Strings</a></li><li><a class="toctext" href="../stdlib/test.html">Unit Testing</a></li></ul></li><li><span class="toctext">JuliaDocs - DevDocs</span><ul><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/C.html">Developing/debugging Julia&#39;s C code</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../devdocs/julia.html">Documentation of Julia&#39;s Internals</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/promote-op.html">Operator-sensitive promotion</a></li><li><a class="toctext" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/types.html">More about types</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>JuliaDocs - Manual</li><li><a href="constructors.html">Constructors</a></li></ul><a class="edit-page" href="https://github.com/"><span class="fa">ï‚›</span> Edit on GitHub</a></nav><hr/></header><a id="Constructors-1"></a><div class="mdnote debug">Base.Markdown.Header{1}</div><h1>Constructors</h1><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Constructors <a href="#footnote-1">[1]</a> are functions that create new objects â€“ specifically, instances of <a href="types.html#Composite-Types-1">Composite Types</a>. In Julia, type objects also serve as constructor functions: they create new instances of themselves when applied to an argument tuple as a function. This much was already mentioned briefly when composite types were introduced. For example:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span class="go">type Foo
</span><span class="go">  bar
</span><span class="go">  baz
</span><span class="go">end
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">foo</span><span> </span><span class="o">=</span><span> </span><span class="n">Foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span>
</span><span class="go">Foo(1,2)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">foo</span><span class="o">.</span><span class="n">bar</span><span>
</span><span class="go">1
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">foo</span><span class="o">.</span><span class="n">baz</span><span>
</span><span class="go">2
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>For many types, forming new objects by binding their field values together is all that is ever needed to create instances. There are, however, cases where more functionality is required when creating composite objects. Sometimes invariants must be enforced, either by checking arguments or by transforming them. <a href="https://en.wikipedia.org/wiki/Recursion_%28computer_science%29#Recursive_data_structures_.28structural_recursion.29">Recursive data structures</a>, especially those that may be self-referential, often cannot be constructed cleanly without first being created in an incomplete state and then altered programmatically to be made whole, as a separate step from object creation. Sometimes, it&#39;s just convenient to be able to construct objects with fewer or different types of parameters than they have fields. Julia&#39;s system for object construction addresses all of these cases and more.</p><div class="mdnote debug">Base.Markdown.Admonition</div><div class="admonition footnote"><div class="admonition-title">[1]</div><div class="admonition-text"><p>Nomenclature: while the term &quot;constructor&quot; generally refers to the entire function which constructs objects of a type, it is common to abuse terminology slightly and refer to specific constructor methods as &quot;constructors&quot;. In such situations, it is generally clear from context that the term is used to mean &quot;constructor method&quot; rather than &quot;constructor function&quot;, especially as it is often used in the sense of singling out a particular method of the constructor from all of the others.</p></div></div><a id="Outer-Constructor-Methods-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Outer Constructor Methods</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>A constructor is just like any other function in Julia in that its overall behavior is defined by the combined behavior of its methods. Accordingly, you can add functionality to a constructor by simply defining new methods. For example, let&#39;s say you want to add a constructor method for <code>Foo</code> objects that takes only one argument and uses the given value for both the <code>bar</code> and <code>baz</code> fields. This is simple:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span class="go">Foo(x) = Foo(x,x)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Foo</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span>
</span><span class="go">Foo(1,1)
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>You could also add a zero-argument <code>Foo</code> constructor method that supplies default values for both of the <code>bar</code> and <code>baz</code> fields:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span class="go">Foo() = Foo(0)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Foo</span><span class="p">(</span><span class="p">)</span><span>
</span><span class="go">Foo(0,0)
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Here the zero-argument constructor method calls the single-argument constructor method, which in turn calls the automatically provided two-argument constructor method. For reasons that will become clear very shortly, additional constructor methods declared as normal methods like this are called <em>outer</em> constructor methods. Outer constructor methods can only ever create a new instance by calling another constructor method, such as the automatically provided default ones.</p><a id="Inner-Constructor-Methods-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Inner Constructor Methods</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>While outer constructor methods succeed in addressing the problem of providing additional convenience methods for constructing objects, they fail to address the other two use cases mentioned in the introduction of this chapter: enforcing invariants, and allowing construction of self-referential objects. For these problems, one needs <em>inner</em> constructor methods. An inner constructor method is much like an outer constructor method, with two differences:</p><div class="mdnote debug">Base.Markdown.List</div><ol><li><p>It is declared inside the block of a type declaration, rather than outside of it like normal methods.</p></li><li><p>It has access to a special locally existent function called <code>new</code> that creates objects of the block&#39;s type.</p></li></ol><div class="mdnote debug">Base.Markdown.Paragraph</div><p>For example, suppose one wants to declare a type that holds a pair of real numbers, subject to the constraint that the first number is not greater than the second one. One could declare it like this:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">type</span><span class="nc"> </span><span class="nc">OrderedPair</span><span>
</span><span>  </span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">Real</span><span>
</span><span>  </span><span class="n">y</span><span class="p">:</span><span class="p">:</span><span class="n">Real</span><span>
</span><span>
</span><span>  </span><span class="n">OrderedPair</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">x</span><span> </span><span class="o">&gt;</span><span> </span><span class="n">y</span><span> </span><span class="o">?</span><span> </span><span class="nb">error</span><span class="p">(</span><span class="s">&quot;</span><span class="s">out of order</span><span class="s">&quot;</span><span class="p">)</span><span> </span><span class="p">:</span><span> </span><span class="nb">new</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Now <code>OrderedPair</code> objects can only be constructed such that <code>x &lt;= y</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">OrderedPair</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span>
</span><span class="go">OrderedPair(1,2)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">OrderedPair</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span>
</span><span class="go">ERROR: out of order
</span><span class="go"> in OrderedPair(::Int64, ::Int64) at ./none:5
</span><span class="go"> ...
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>You can still reach in and directly change the field values to violate this invariant, but messing around with an object&#39;s internals uninvited is considered poor form. You (or someone else) can also provide additional outer constructor methods at any later point, but once a type is declared, there is no way to add more inner constructor methods. Since outer constructor methods can only create objects by calling other constructor methods, ultimately, some inner constructor must be called to create an object. This guarantees that all objects of the declared type must come into existence by a call to one of the inner constructor methods provided with the type, thereby giving some degree of enforcement of a type&#39;s invariants.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Of course, if the type is declared as <code>immutable</code>, then its constructor-provided invariants are fully enforced. This is an important consideration when deciding whether a type should be immutable.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>If any inner constructor method is defined, no default constructor method is provided: it is presumed that you have supplied yourself with all the inner constructors you need. The default constructor is equivalent to writing your own inner constructor method that takes all of the object&#39;s fields as parameters (constrained to be of the correct type, if the corresponding field has a type), and passes them to <code>new</code>, returning the resulting object:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">type</span><span class="nc"> </span><span class="nc">Foo</span><span>
</span><span>  </span><span class="n">bar</span><span>
</span><span>  </span><span class="n">baz</span><span>
</span><span>
</span><span>  </span><span class="n">Foo</span><span class="p">(</span><span class="n">bar</span><span class="p">,</span><span class="n">baz</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="nb">new</span><span class="p">(</span><span class="n">bar</span><span class="p">,</span><span class="n">baz</span><span class="p">)</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This declaration has the same effect as the earlier definition of the <code>Foo</code> type without an explicit inner constructor method. The following two types are equivalent â€“ one with a default constructor, the other with an explicit constructor:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span class="go">type T1
</span><span class="go">  x::Int64
</span><span class="go">end
</span><span class="go">
</span><span class="go">type T2
</span><span class="go">  x::Int64
</span><span class="go">  T2(x) = new(x)
</span><span class="go">end
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">T1</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span>
</span><span class="go">T1(1)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">T2</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span>
</span><span class="go">T2(1)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">T1</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span><span>
</span><span class="go">T1(1)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">T2</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span><span>
</span><span class="go">T2(1)
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>It is considered good form to provide as few inner constructor methods as possible: only those taking all arguments explicitly and enforcing essential error checking and transformation. Additional convenience constructor methods, supplying default values or auxiliary transformations, should be provided as outer constructors that call the inner constructors to do the heavy lifting. This separation is typically quite natural.</p><a id="Incomplete-Initialization-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Incomplete Initialization</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The final problem which has still not been addressed is construction of self-referential objects, or more generally, recursive data structures. Since the fundamental difficulty may not be immediately obvious, let us briefly explain it. Consider the following recursive type declaration:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">type</span><span class="nc"> </span><span class="nc">SelfReferential</span><span>
</span><span>  </span><span class="n">obj</span><span class="p">:</span><span class="p">:</span><span class="n">SelfReferential</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This type may appear innocuous enough, until one considers how to construct an instance of it. If <code>a</code> is an instance of <code>SelfReferential</code>, then a second instance can be created by the call:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">b</span><span> </span><span class="o">=</span><span> </span><span class="n">SelfReferential</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>But how does one construct the first instance when no instance exists to provide as a valid value for its <code>obj</code> field? The only solution is to allow creating an incompletely initialized instance of <code>SelfReferential</code> with an unassigned <code>obj</code> field, and using that incomplete instance as a valid value for the <code>obj</code> field of another instance, such as, for example, itself.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>To allow for the creation of incompletely initialized objects, Julia allows the <code>new</code> function to be called with fewer than the number of fields that the type has, returning an object with the unspecified fields uninitialized. The inner constructor method can then use the incomplete object, finishing its initialization before returning it. Here, for example, we take another crack at defining the <code>SelfReferential</code> type, with a zero-argument inner constructor returning instances having <code>obj</code> fields pointing to themselves:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">type</span><span class="nc"> </span><span class="nc">SelfReferential</span><span>
</span><span>  </span><span class="n">obj</span><span class="p">:</span><span class="p">:</span><span class="n">SelfReferential</span><span>
</span><span>
</span><span>  </span><span class="n">SelfReferential</span><span class="p">(</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="p">(</span><span class="n">x</span><span> </span><span class="o">=</span><span> </span><span class="nb">new</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span> </span><span class="n">x</span><span class="o">.</span><span class="n">obj</span><span> </span><span class="o">=</span><span> </span><span class="n">x</span><span class="p">)</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>We can verify that this constructor works and constructs objects that are, in fact, self-referential:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">x</span><span> </span><span class="o">=</span><span> </span><span class="n">SelfReferential</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span>
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">is</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span> </span><span class="n">x</span><span class="p">)</span><span>
</span><span class="go">true
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">is</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span> </span><span class="n">x</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span><span>
</span><span class="go">true
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">is</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span> </span><span class="n">x</span><span class="o">.</span><span class="n">obj</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span><span>
</span><span class="go">true
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Although it is generally a good idea to return a fully initialized object from an inner constructor, incompletely initialized objects can be returned:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="k">type</span><span class="nc"> </span><span class="nc">Incomplete</span><span>
</span><span class="gt">
         xx
</span><span></span><span class="gt">
         Incomplete() = new()
</span><span></span><span class="gt">
       end
</span><span></span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">z</span><span> </span><span class="o">=</span><span> </span><span class="n">Incomplete</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>While you are allowed to create objects with uninitialized fields, any access to an uninitialized reference is an immediate error:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">z</span><span class="o">.</span><span class="n">xx</span><span>
</span><span class="go">ERROR: UndefRefError: access to undefined reference
</span><span class="go"> ...
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This avoids the need to continually check for <code>null</code> values. However, not all object fields are references. Julia considers some types to be &quot;plain data&quot;, meaning all of their data is self-contained and does not reference other objects. The plain data types consist of bits types (e.g. <code>Int</code>) and immutable structs of other plain data types. The initial contents of a plain data type is undefined:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="k">type</span><span class="nc"> </span><span class="nc">HasPlain</span><span>
</span><span class="gt">
         n::Int
</span><span></span><span class="gt">
         HasPlain() = new()
</span><span></span><span class="gt">
       end
</span><span></span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">HasPlain</span><span class="p">(</span><span class="p">)</span><span>
</span><span class="go">HasPlain(438103441441)
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Arrays of plain data types exhibit the same behavior.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>You can pass incomplete objects to other functions from inner constructors to delegate their completion:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">type</span><span class="nc"> </span><span class="nc">Lazy</span><span>
</span><span>  </span><span class="n">xx</span><span>
</span><span>
</span><span>  </span><span class="n">Lazy</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">complete_me</span><span class="p">(</span><span class="nb">new</span><span class="p">(</span><span class="p">)</span><span class="p">,</span><span> </span><span class="n">v</span><span class="p">)</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>As with incomplete objects returned from constructors, if <code>complete_me</code> or any of its callees try to access the <code>xx</code> field of the <code>Lazy</code> object before it has been initialized, an error will be thrown immediately.</p><a id="Parametric-Constructors-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Parametric Constructors</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Parametric types add a few wrinkles to the constructor story. Recall from <a href="types.html#Parametric-Types-1">Parametric Types</a> that, by default, instances of parametric composite types can be constructed either with explicitly given type parameters or with type parameters implied by the types of the arguments given to the constructor. Here are some examples:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="k">type</span><span class="nc"> </span><span class="nc">Point</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Real</span><span class="p">}</span><span>
</span><span class="gt">
         x::T
</span><span></span><span class="gt">
         y::T
</span><span></span><span class="gt">
       end
</span><span></span><span class="go">
</span><span class="go">## implicit T ##
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Point</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span>
</span><span class="go">Point{Int64}(1,2)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Point</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">2.5</span><span class="p">)</span><span>
</span><span class="go">Point{Float64}(1.0,2.5)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Point</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mf">2.5</span><span class="p">)</span><span>
</span><span class="go">ERROR: MethodError: no method matching Point{T&lt;:Real}(::Int64, ::Float64)
</span><span class="go">Closest candidates are:
</span><span class="go">  Point{T&lt;:Real}{T&lt;:Real}(::T&lt;:Real, !Matched::T&lt;:Real)
</span><span class="go">  Point{T&lt;:Real}{T}(::Any)
</span><span class="go"> ...
</span><span class="go">
</span><span class="go">## explicit T ##
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Point</span><span class="p">{</span><span class="kt">Int64</span><span class="p">}</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span>
</span><span class="go">Point{Int64}(1,2)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Point</span><span class="p">{</span><span class="kt">Int64</span><span class="p">}</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">2.5</span><span class="p">)</span><span>
</span><span class="go">ERROR: InexactError()
</span><span class="go"> in Point{Int64}(::Float64, ::Float64) at ./none:2
</span><span class="go"> ...
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Point</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">2.5</span><span class="p">)</span><span>
</span><span class="go">Point{Float64}(1.0,2.5)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Point</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span>
</span><span class="go">Point{Float64}(1.0,2.0)
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>As you can see, for constructor calls with explicit type parameters, the arguments are converted to the implied field types: <code>Point{Int64}(1,2)</code> works, but <code>Point{Int64}(1.0,2.5)</code> raises an <code>InexactError</code> when converting <code>2.5</code> to <code>Int64</code>. When the type is implied by the arguments to the constructor call, as in <code>Point(1,2)</code>, then the types of the arguments must agree â€“ otherwise the <code>T</code> cannot be determined â€“ but any pair of real arguments with matching type may be given to the generic <code>Point</code> constructor.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>What&#39;s really going on here is that <code>Point</code>, <code>Point{Float64}</code> and <code>Point{Int64}</code> are all different constructor functions. In fact, <code>Point{T}</code> is a distinct constructor function for each type <code>T</code>. Without any explicitly provided inner constructors, the declaration of the composite type <code>Point{T&lt;:Real}</code> automatically provides an inner constructor, <code>Point{T}</code>, for each possible type <code>T&lt;:Real</code>, that behaves just like non-parametric default inner constructors do. It also provides a single general outer <code>Point</code> constructor that takes pairs of real arguments, which must be of the same type. This automatic provision of constructors is equivalent to the following explicit declaration:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">type</span><span class="nc"> </span><span class="nc">Point</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Real</span><span class="p">}</span><span>
</span><span>  </span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">T</span><span>
</span><span>  </span><span class="n">y</span><span class="p">:</span><span class="p">:</span><span class="n">T</span><span>
</span><span>
</span><span>  </span><span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="nb">new</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span>
</span><span class="k">end</span><span>
</span><span>
</span><span class="n">Point</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Real</span><span class="p">}</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">T</span><span class="p">,</span><span> </span><span class="n">y</span><span class="p">:</span><span class="p">:</span><span class="n">T</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">Point</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Some features of parametric constructor definitions at work here deserve comment. First, inner constructor declarations always define methods of <code>Point{T}</code> rather than methods of the general <code>Point</code> constructor function. Since <code>Point</code> is not a concrete type, it makes no sense for it to even have inner constructor methods at all. Thus, the inner method declaration <code>Point(x,y) = new(x,y)</code> provides an inner constructor method for each value of <code>T</code>. It is this method declaration that defines the behavior of constructor calls with explicit type parameters like <code>Point{Int64}(1,2)</code> and <code>Point{Float64}(1.0,2.0)</code>. The outer constructor declaration, on the other hand, defines a method for the general <code>Point</code> constructor which only applies to pairs of values of the same real type. This declaration makes constructor calls without explicit type parameters, like <code>Point(1,2)</code> and <code>Point(1.0,2.5)</code>, work. Since the method declaration restricts the arguments to being of the same type, calls like <code>Point(1,2.5)</code>, with arguments of different types, result in &quot;no method&quot; errors.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Suppose we wanted to make the constructor call <code>Point(1,2.5)</code> work by &quot;promoting&quot; the integer value <code>1</code> to the floating-point value <code>1.0</code>. The simplest way to achieve this is to define the following additional outer constructor method:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="kt">Int64</span><span class="p">,</span><span> </span><span class="n">y</span><span class="p">:</span><span class="p">:</span><span class="kt">Float64</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">Point</span><span class="p">(</span><span class="nb">convert</span><span class="p">(</span><span class="kt">Float64</span><span class="p">,</span><span class="n">x</span><span class="p">)</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="p">;</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This method uses the <a href="../stdlib/base.html#Base.convert"><code>convert()</code></a> function to explicitly convert <code>x</code> to <a href="../stdlib/numbers.html#Core.Float64"><code>Float64</code></a> and then delegates construction to the general constructor for the case where both arguments are <a href="../stdlib/numbers.html#Core.Float64"><code>Float64</code></a>. With this method definition what was previously a <a href="../stdlib/base.html#Base.MethodError"><code>MethodError</code></a> now successfully creates a point of type <code>Point{Float64}</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Point</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mf">2.5</span><span class="p">)</span><span>
</span><span class="go">Point{Float64}(1.0,2.5)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span><span>
</span><span class="go">Point{Float64}
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>However, other similar calls still don&#39;t work:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Point</span><span class="p">(</span><span class="mf">1.5</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span>
</span><span class="go">ERROR: MethodError: no method matching Point{T&lt;:Real}(::Float64, ::Int64)
</span><span class="go">Closest candidates are:
</span><span class="go">  Point{T&lt;:Real}{T&lt;:Real}(::T&lt;:Real, !Matched::T&lt;:Real)
</span><span class="go">  Point{T&lt;:Real}{T}(::Any)
</span><span class="go"> ...
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>For a much more general way of making all such calls work sensibly, see <a href="conversion-and-promotion.html#Conversion-and-Promotion-1">Conversion and Promotion</a>. At the risk of spoiling the suspense, we can reveal here that all it takes is the following outer method definition to make all calls to the general <code>Point</code> constructor work as one would expect:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">Real</span><span class="p">,</span><span> </span><span class="n">y</span><span class="p">:</span><span class="p">:</span><span class="n">Real</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">Point</span><span class="p">(</span><span class="nb">promote</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="p">)</span><span class="p">;</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The <code>promote</code> function converts all its arguments to a common type â€“ in this case <a href="../stdlib/numbers.html#Core.Float64"><code>Float64</code></a>. With this method definition, the <code>Point</code> constructor promotes its arguments the same way that numeric operators like <a href="../stdlib/math.html#Base.+"><code>+</code></a> do, and works for all kinds of real numbers:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Point</span><span class="p">(</span><span class="mf">1.5</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span>
</span><span class="go">Point{Float64}(1.5,2.0)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Point</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span>
</span><span class="go">Point{Rational{Int64}}(1//1,1//2)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Point</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span>
</span><span class="go">Point{Float64}(1.0,0.5)
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Thus, while the implicit type parameter constructors provided by default in Julia are fairly strict, it is possible to make them behave in a more relaxed but sensible manner quite easily. Moreover, since constructors can leverage all of the power of the type system, methods, and multiple dispatch, defining sophisticated behavior is typically quite simple.</p><a id="Case-Study:-Rational-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Case Study: Rational</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Perhaps the best way to tie all these pieces together is to present a real world example of a parametric composite type and its constructor methods. To that end, here is beginning of <a href="https://github.com/JuliaLang/julia/blob/master/base/rational.jl">rational.jl</a>, which implements Julia&#39;s <a href="complex-and-rational-numbers.html#Rational-Numbers-1">Rational Numbers</a>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">immutable</span><span> </span><span class="n">Rational</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Integer</span><span class="p">}</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Real</span><span>
</span><span>    </span><span class="n">num</span><span class="p">:</span><span class="p">:</span><span class="n">T</span><span>
</span><span>    </span><span class="n">den</span><span class="p">:</span><span class="p">:</span><span class="n">T</span><span>
</span><span>
</span><span>    </span><span class="k">function</span><span class="nf"> </span><span class="nf">Rational</span><span class="p">(</span><span class="n">num</span><span class="p">:</span><span class="p">:</span><span class="n">T</span><span class="p">,</span><span> </span><span class="n">den</span><span class="p">:</span><span class="p">:</span><span class="n">T</span><span class="p">)</span><span>
</span><span>        </span><span class="k">if</span><span> </span><span class="n">num</span><span> </span><span class="o">==</span><span> </span><span class="mi">0</span><span> </span><span class="o">&amp;&amp;</span><span> </span><span class="n">den</span><span> </span><span class="o">==</span><span> </span><span class="mi">0</span><span>
</span><span>            </span><span class="nb">error</span><span class="p">(</span><span class="s">&quot;</span><span class="s">invalid rational: 0//0</span><span class="s">&quot;</span><span class="p">)</span><span>
</span><span>        </span><span class="k">end</span><span>
</span><span>        </span><span class="n">g</span><span> </span><span class="o">=</span><span> </span><span class="n">gcd</span><span class="p">(</span><span class="n">den</span><span class="p">,</span><span> </span><span class="n">num</span><span class="p">)</span><span>
</span><span>        </span><span class="n">num</span><span> </span><span class="o">=</span><span> </span><span class="n">div</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span> </span><span class="n">g</span><span class="p">)</span><span>
</span><span>        </span><span class="n">den</span><span> </span><span class="o">=</span><span> </span><span class="n">div</span><span class="p">(</span><span class="n">den</span><span class="p">,</span><span> </span><span class="n">g</span><span class="p">)</span><span>
</span><span>        </span><span class="nb">new</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span> </span><span class="n">den</span><span class="p">)</span><span>
</span><span>    </span><span class="k">end</span><span>
</span><span class="k">end</span><span>
</span><span class="n">Rational</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Integer</span><span class="p">}</span><span class="p">(</span><span class="n">n</span><span class="p">:</span><span class="p">:</span><span class="n">T</span><span class="p">,</span><span> </span><span class="n">d</span><span class="p">:</span><span class="p">:</span><span class="n">T</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">Rational</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">d</span><span class="p">)</span><span>
</span><span class="n">Rational</span><span class="p">(</span><span class="n">n</span><span class="p">:</span><span class="p">:</span><span class="n">Integer</span><span class="p">,</span><span> </span><span class="n">d</span><span class="p">:</span><span class="p">:</span><span class="n">Integer</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">Rational</span><span class="p">(</span><span class="nb">promote</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="p">)</span><span>
</span><span class="n">Rational</span><span class="p">(</span><span class="n">n</span><span class="p">:</span><span class="p">:</span><span class="n">Integer</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">Rational</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">one</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="p">)</span><span>
</span><span>
</span><span class="o">/</span><span class="o">/</span><span class="p">(</span><span class="n">n</span><span class="p">:</span><span class="p">:</span><span class="n">Integer</span><span class="p">,</span><span> </span><span class="n">d</span><span class="p">:</span><span class="p">:</span><span class="n">Integer</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">Rational</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">d</span><span class="p">)</span><span>
</span><span class="o">/</span><span class="o">/</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">Rational</span><span class="p">,</span><span> </span><span class="n">y</span><span class="p">:</span><span class="p">:</span><span class="n">Integer</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">x</span><span class="o">.</span><span class="n">num</span><span> </span><span class="o">/</span><span class="o">/</span><span> </span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">den</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span>
</span><span class="o">/</span><span class="o">/</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">Integer</span><span class="p">,</span><span> </span><span class="n">y</span><span class="p">:</span><span class="p">:</span><span class="n">Rational</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">.</span><span class="n">den</span><span class="p">)</span><span> </span><span class="o">/</span><span class="o">/</span><span> </span><span class="n">y</span><span class="o">.</span><span class="n">num</span><span>
</span><span class="o">/</span><span class="o">/</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">Complex</span><span class="p">,</span><span> </span><span class="n">y</span><span class="p">:</span><span class="p">:</span><span class="n">Real</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">complex</span><span class="p">(</span><span class="n">real</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="o">/</span><span class="n">y</span><span class="p">,</span><span> </span><span class="n">imag</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span>
</span><span class="o">/</span><span class="o">/</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">Real</span><span class="p">,</span><span> </span><span class="n">y</span><span class="p">:</span><span class="p">:</span><span class="n">Complex</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">&#39;</span><span class="o">/</span><span class="o">/</span><span class="n">real</span><span class="p">(</span><span class="n">y</span><span class="o">*</span><span class="n">y</span><span class="o">&#39;</span><span class="p">)</span><span>
</span><span>
</span><span class="k">function</span><span class="nf"> </span><span class="o">//</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">Complex</span><span class="p">,</span><span> </span><span class="n">y</span><span class="p">:</span><span class="p">:</span><span class="n">Complex</span><span class="p">)</span><span>
</span><span>    </span><span class="n">xy</span><span> </span><span class="o">=</span><span> </span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">&#39;</span><span>
</span><span>    </span><span class="n">yy</span><span> </span><span class="o">=</span><span> </span><span class="n">real</span><span class="p">(</span><span class="n">y</span><span class="o">*</span><span class="n">y</span><span class="o">&#39;</span><span class="p">)</span><span>
</span><span>    </span><span class="n">complex</span><span class="p">(</span><span class="n">real</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span><span class="o">/</span><span class="o">/</span><span class="n">yy</span><span class="p">,</span><span> </span><span class="n">imag</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span><span class="o">/</span><span class="o">/</span><span class="n">yy</span><span class="p">)</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The first line â€“ <code>immutable Rational{T&lt;:Int} &lt;: Real</code> â€“ declares that <code>Rational</code> takes one type parameter of an integer type, and is itself a real type. The field declarations <code>num::T</code> and <code>den::T</code> indicate that the data held in a <code>Rational{T}</code> object are a pair of integers of type <code>T</code>, one representing the rational value&#39;s numerator and the other representing its denominator.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Now things get interesting. <code>Rational</code> has a single inner constructor method which checks that both of <code>num</code> and <code>den</code> aren&#39;t zero and ensures that every rational is constructed in &quot;lowest terms&quot; with a non-negative denominator. This is accomplished by dividing the given numerator and denominator values by their greatest common divisor, computed using the <code>gcd</code> function. Since <code>gcd</code> returns the greatest common divisor of its arguments with sign matching the first argument (<code>den</code> here), after this division the new value of <code>den</code> is guaranteed to be non-negative. Because this is the only inner constructor for <code>Rational</code>, we can be certain that <code>Rational</code> objects are always constructed in this normalized form.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p><code>Rational</code> also provides several outer constructor methods for convenience. The first is the &quot;standard&quot; general constructor that infers the type parameter <code>T</code> from the type of the numerator and denominator when they have the same type. The second applies when the given numerator and denominator values have different types: it promotes them to a common type and then delegates construction to the outer constructor for arguments of matching type. The third outer constructor turns integer values into rationals by supplying a value of <code>1</code> as the denominator.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Following the outer constructor definitions, we have a number of methods for the <a href="../stdlib/math.html#Base.//"><code>//</code></a> operator, which provides a syntax for writing rationals. Before these definitions, <a href="../stdlib/math.html#Base.//"><code>//</code></a> is a completely undefined operator with only syntax and no meaning. Afterwards, it behaves just as described in <a href="complex-and-rational-numbers.html#Rational-Numbers-1">Rational Numbers</a> â€“ its entire behavior is defined in these few lines. The first and most basic definition just makes <code>a//b</code> construct a <code>Rational</code> by applying the <code>Rational</code> constructor to <code>a</code> and <code>b</code> when they are integers. When one of the operands of <a href="../stdlib/math.html#Base.//"><code>//</code></a> is already a rational number, we construct a new rational for the resulting ratio slightly differently; this behavior is actually identical to division of a rational with an integer. Finally, applying <a href="../stdlib/math.html#Base.//"><code>//</code></a> to complex integral values creates an instance of <code>Complex{Rational}</code> â€“ a complex number whose real and imaginary parts are rationals:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="p">(</span><span class="mi">1</span><span> </span><span class="o">+</span><span> </span><span class="mi">2</span><span class="nb">im</span><span class="p">)</span><span class="o">/</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span> </span><span class="o">-</span><span> </span><span class="mi">2</span><span class="nb">im</span><span class="p">)</span><span>
</span><span class="go">-3//5 + 4//5*im
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span><span>
</span><span class="go">Complex{Rational{Int64}}
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">ans</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Complex</span><span class="p">{</span><span class="n">Rational</span><span class="p">}</span><span>
</span><span class="go">false
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Thus, although the <a href="../stdlib/math.html#Base.//"><code>//</code></a> operator usually returns an instance of <code>Rational</code>, if either of its arguments are complex integers, it will return an instance of <code>Complex{Rational}</code> instead. The interested reader should consider perusing the rest of <a href="https://github.com/JuliaLang/julia/blob/master/base/rational.jl">rational.jl</a>: it is short, self-contained, and implements an entire basic Julia type.</p><a id="Constructors-and-Conversion-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Constructors and Conversion</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Constructors <code>T(args...)</code> in Julia are implemented like other callable objects: methods are added to their types. The type of a type is <code>Type</code>, so all constructor methods are stored in the method table for the <code>Type</code> type. This means that you can declare more flexible constructors, e.g. constructors for abstract types, by explicitly defining methods for the appropriate types.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>However, in some cases you could consider adding methods to <code>Base.convert</code><em>instead</em> of defining a constructor, because Julia falls back to calling <a href="../stdlib/base.html#Base.convert"><code>convert()</code></a> if no matching constructor is found. For example, if no constructor <code>T(args...) = ...</code> exists <code>Base.convert(::Type{T}, args...) = ...</code> is called.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p><code>convert</code> is used extensively throughout Julia whenever one type needs to be converted to another (e.g. in assignment, <code>ccall</code>, etcetera), and should generally only be defined (or successful) if the conversion is lossless.  For example, <code>convert(Int, 3.0)</code> produces <code>3</code>, but <code>convert(Int, 3.2)</code> throws an <code>InexactError</code>.  If you want to define a constructor for a lossless conversion from one type to another, you should probably define a <code>convert</code> method instead.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>On the other hand, if your constructor does not represent a lossless conversion, or doesn&#39;t represent &quot;conversion&quot; at all, it is better to leave it as a constructor rather than a <code>convert</code> method.  For example, the <code>Array{Int}()</code> constructor creates a zero-dimensional <code>Array</code> of the type <code>Int</code>, but is not really a &quot;conversion&quot; from <code>Int</code> to an <code>Array</code>.</p><a id="Outer-only-constructors-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Outer-only constructors</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>As we have seen, a typical parametric type has inner constructors that are called when type parameters are known; e.g. they apply to <code>Point{Int}</code> but not to <code>Point</code>. Optionally, outer constructors that determine type parameters automatically can be added, for example constructing a <code>Point{Int}</code> from the call <code>Point(1,2)</code>. Outer constructors call inner constructors to do the core work of making an instance. However, in some cases one would rather not provide inner constructors, so that specific type parameters cannot be requested manually.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>For example, say we define a type that stores a vector along with an accurate representation of its sum:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">type</span><span class="nc"> </span><span class="nc">SummedArray</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Number</span><span class="p">,</span><span class="n">S</span><span class="o">&lt;:</span><span class="n">Number</span><span class="p">}</span><span>
</span><span>    </span><span class="n">data</span><span class="p">:</span><span class="p">:</span><span class="n">Vector</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span>
</span><span>    </span><span class="n">sum</span><span class="p">:</span><span class="p">:</span><span class="n">S</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The problem is that we want <code>S</code> to be a larger type than <code>T</code>, so that we can sum many elements with less information loss. For example, when <code>T</code> is <code>Int32</code>, we would like <code>S</code> to be <code>Int64</code>. Therefore we want to avoid an interface that allows the user to construct instances of the type <code>SummedArray{Int32,Int32}</code>. One way to do this is to provide only an outer constructor for <code>SummedArray</code>. This can be done using method definition by type:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">type</span><span class="nc"> </span><span class="nc">SummedArray</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Number</span><span class="p">,</span><span class="n">S</span><span class="o">&lt;:</span><span class="n">Number</span><span class="p">}</span><span>
</span><span>    </span><span class="n">data</span><span class="p">:</span><span class="p">:</span><span class="n">Vector</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span>
</span><span>    </span><span class="n">sum</span><span class="p">:</span><span class="p">:</span><span class="n">S</span><span>
</span><span>
</span><span>    </span><span class="k">function</span><span class="nf"> </span><span class="o">(:</span><span class="p">:</span><span class="n">Type</span><span class="p">{</span><span class="n">SummedArray</span><span class="p">}</span><span class="p">)</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="p">:</span><span class="n">Vector</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">)</span><span>
</span><span>        </span><span class="n">S</span><span> </span><span class="o">=</span><span> </span><span class="n">widen</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span>
</span><span>        </span><span class="nb">new</span><span class="p">{</span><span class="n">T</span><span class="p">,</span><span class="n">S</span><span class="p">}</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span> </span><span class="n">sum</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span> </span><span class="n">a</span><span class="p">)</span><span class="p">)</span><span>
</span><span>    </span><span class="k">end</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This constructor will be invoked by the syntax <code>SummedArray(a)</code>. The syntax <code>new{T,S}</code> allows specifying parameters for the type to be constructed, i.e. this call will return a <code>SummedArray{T,S}</code>.</p><footer><hr/><a class="previous" href="complex-and-rational-numbers.html"><span class="direction">Previous</span><span class="title">Complex and Rational Numbers</span></a><a class="next" href="control-flow.html"><span class="direction">Next</span><span class="title">Control Flow</span></a></footer></article></body></html>
