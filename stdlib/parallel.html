<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tasks and Parallel Computing · Julia language documentation</title><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../assets/debug.js"></script></head><body><nav class="toc"><a href><img class="logo" src="../logo.png" alt="Julia language logo"/></a><h1>Julia language</h1><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../manual/arrays.html">Multi-dimensional Arrays</a></li><li><a class="toctext" href="../manual/calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="toctext" href="../manual/complex-and-rational-numbers.html">Complex and Rational Numbers</a></li><li><a class="toctext" href="../manual/constructors.html">Constructors</a></li><li><a class="toctext" href="../manual/control-flow.html">Control Flow</a></li><li><a class="toctext" href="../manual/conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="toctext" href="../manual/dates.html">Date and DateTime</a></li><li><a class="toctext" href="../manual/documentation.html">Documentation</a></li><li><a class="toctext" href="../manual/embedding.html">Embedding Julia</a></li><li><a class="toctext" href="../manual/faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="../manual/functions.html">Functions</a></li><li><a class="toctext" href="../manual/getting-started.html">Getting Started</a></li><li><a class="toctext" href="../manual/handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="../manual/index.html">The Julia Manual</a></li><li><a class="toctext" href="../manual/integers-and-floating-point-numbers.html">Integers and Floating-Point Numbers</a></li><li><a class="toctext" href="../manual/interacting-with-julia.html">Interacting With Julia</a></li><li><a class="toctext" href="../manual/interfaces.html">Interfaces</a></li><li><a class="toctext" href="../manual/introduction.html">Introduction</a></li><li><a class="toctext" href="../manual/linear-algebra.html">Linear algebra</a></li><li><a class="toctext" href="../manual/mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="../manual/metaprogramming.html">Metaprogramming</a></li><li><a class="toctext" href="../manual/methods.html">Methods</a></li><li><a class="toctext" href="../manual/modules.html">Modules</a></li><li><a class="toctext" href="../manual/networking-and-streams.html">Networking and Streams</a></li><li><a class="toctext" href="../manual/noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="../manual/packages.html">Packages</a></li><li><a class="toctext" href="../manual/parallel-computing.html">Parallel Computing</a></li><li><a class="toctext" href="../manual/performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="../manual/profile.html">Profiling</a></li><li><a class="toctext" href="../manual/running-external-programs.html">Running External Programs</a></li><li><a class="toctext" href="../manual/stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="../manual/strings.html">Strings</a></li><li><a class="toctext" href="../manual/style-guide.html">Style Guide</a></li><li><a class="toctext" href="../manual/types.html">Types</a></li><li><a class="toctext" href="../manual/unicode-input.html">Unicode Input</a></li><li><a class="toctext" href="../manual/variables-and-scoping.html">Scope of Variables</a></li><li><a class="toctext" href="../manual/variables.html">Variables</a></li><li><a class="toctext" href="../manual/workflow-tips.html">Workflow Tips</a></li></ul></li><li><span class="toctext">Standard Libary</span><ul><li><a class="toctext" href="arrays.html">Arrays</a></li><li><a class="toctext" href="base.html">Essentials</a></li><li><a class="toctext" href="c.html">C Interface</a></li><li><a class="toctext" href="collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="constants.html">Constants</a></li><li><a class="toctext" href="dates.html">Dates and Time</a></li><li><a class="toctext" href="file.html">Filesystem</a></li><li><a class="toctext" href="index.html">The Julia Standard Library</a></li><li><a class="toctext" href="io-network.html">I/O and Network</a></li><li><a class="toctext" href="libc.html">C Standard Library</a></li><li><a class="toctext" href="libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="linalg.html">Linear Algebra</a></li><li><a class="toctext" href="math.html">Mathematics</a></li><li><a class="toctext" href="numbers.html">Numbers</a></li><li class="current"><a class="toctext" href="parallel.html">Tasks and Parallel Computing</a><ul class="internal"><li><a class="toctext" href="#Tasks-1">Tasks</a></li><li><a class="toctext" href="#General-Parallel-Computing-Support-1">General Parallel Computing Support</a></li><li><a class="toctext" href="#Shared-Arrays-1">Shared Arrays</a></li><li><a class="toctext" href="#Multi-Threading-1">Multi-Threading</a></li><li><a class="toctext" href="#Cluster-Manager-Interface-1">Cluster Manager Interface</a></li></ul></li><li><a class="toctext" href="pkg.html">Package Manager Functions</a></li><li><a class="toctext" href="profile.html">Profiling</a></li><li><a class="toctext" href="punctuation.html">Punctuation</a></li><li><a class="toctext" href="simd-types.html">SIMD Support</a></li><li><a class="toctext" href="sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="stacktraces.html">StackTraces</a></li><li><a class="toctext" href="strings.html">Strings</a></li><li><a class="toctext" href="test.html">Unit Testing</a></li></ul></li><li><span class="toctext">DevDocs</span><ul><li><a class="toctext" href="../devdocs/C.html">Developing/debugging Julia&#39;s C code</a></li><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../devdocs/julia.html">Documentation of Julia&#39;s Internals</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/promote-op.html">Operator-sensitive promotion</a></li><li><a class="toctext" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/types.html">More about types</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li></ul></li><li><span class="toctext">Dynamic pages</span><ul><li><a class="toctext" href="../dynamic/code.html">Code examples</a></li><li><a class="toctext" href="../dynamic/admonitions.html">Admonitions &amp; Co</a></li><li><a class="toctext" href="../dynamic/styles.html">Demonstrating <em>styles</em> of MD elements</a></li><li><a class="toctext" href="../dynamic/latex.html">The <span>$\sin(x^2)$</span> project</a></li><li><a class="toctext" href="../dynamic/bugs.html">Some existing bugs</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Standard Libary</li><li><a href="parallel.html">Tasks and Parallel Computing</a></li></ul><a class="edit-page" href="https://github.com/"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><a class="nav-anchor" id="Tasks-and-Parallel-Computing-1" href="#Tasks-and-Parallel-Computing-1"><h1>Tasks and Parallel Computing</h1></a><a class="nav-anchor" id="Tasks-1" href="#Tasks-1"><h2>Tasks</h2></a><pre><code class="language-none">Core.Task
Base.yieldto
Base.current_task
Base.istaskdone
Base.istaskstarted
Base.consume
Base.produce
Base.yield
Base.task_local_storage
Base.task_local_storage
Base.task_local_storage
Base.Condition
Base.notify
Base.schedule
Base.@schedule
Base.@task
Base.sleep
Base.ReentrantLock
Base.lock
Base.unlock
Base.Channel</code></pre><a class="nav-anchor" id="General-Parallel-Computing-Support-1" href="#General-Parallel-Computing-Support-1"><h2>General Parallel Computing Support</h2></a><pre><code class="language-none">Base.addprocs
Base.addprocs
Base.addprocs
Base.addprocs
Base.nprocs
Base.nworkers
Base.procs
Base.workers
Base.rmprocs
Base.interrupt
Base.myid
Base.asyncmap
Base.pmap
Base.remotecall
Base.Future
Base.Future
Base.RemoteChannel
Base.RemoteChannel
Base.RemoteChannel
Base.wait
Base.fetch
Base.remotecall_wait
Base.remotecall_fetch
Base.put!
Base.put!
Base.put!
Base.take!
Base.take!
Base.isready
Base.isready
Base.close
Base.WorkerPool
Base.CachingPool
Base._default_worker_pool
Base.remote
Base.remotecall
Base.remotecall_wait
Base.remotecall_fetch
Base.timedwait
Base.@spawn
Base.@spawnat
Base.@fetch
Base.@fetchfrom
Base.@async
Base.@sync
Base.@parallel
Base.@everywhere
Base.clear!
Base.remoteref_id
Base.channel_from_id
Base.worker_id_from_socket
Base.cluster_cookie</code></pre><a class="nav-anchor" id="Shared-Arrays-1" href="#Shared-Arrays-1"><h2>Shared Arrays</h2></a><pre><code class="language-none">Base.SharedArray
Base.SharedArray
Base.procs
Base.sdata
Base.indexpids
Base.localindexes</code></pre><a class="nav-anchor" id="Multi-Threading-1" href="#Multi-Threading-1"><h2>Multi-Threading</h2></a><p>This experimental interface supports Julia&#39;s multi-threading capabilities. Types and function described here might (and likely will) change in the future.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Threads.threadid" href="#Base.Threads.threadid"><code>Base.Threads.threadid</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Threads.threadid()</code></pre><p>Get the ID number of the current thread of execution. The master thread has ID <code>1</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/threadingconstructs.jl#L5-L9">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Threads.nthreads" href="#Base.Threads.nthreads"><code>Base.Threads.nthreads</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Threads.nthreads()</code></pre><p>Get the number of threads available to the Julia process. This is the inclusive upper bound on <code>threadid()</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/threadingconstructs.jl#L13-L18">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Threads.@threads" href="#Base.Threads.@threads"><code>Base.Threads.@threads</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">Threads.@threads</code></pre><p>A macro to parallelize a for-loop to run with multiple threads. This spawns <code>nthreads()</code> number of threads, splits the iteration space amongst them, and iterates in parallel. A barrier is placed at the end of the loop which waits for all the threads to finish execution, and the loop returns.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/threadingconstructs.jl#L60-L67">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Threads.Atomic" href="#Base.Threads.Atomic"><code>Base.Threads.Atomic</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Threads.Atomic{T}</code></pre><p>Holds a reference to an object of type <code>T</code>, ensuring that it is only accessed atomically, i.e. in a thread-safe manner.</p><p>Only certain &quot;simple&quot; types can be used atomically, namely the bitstypes integer and float-point types. These are <code>Int8</code>...<code>Int128</code>, <code>UInt8</code>...<code>UInt128</code>, and <code>Float16</code>...<code>Float64</code>.</p><p>New atomic objects can be created from a non-atomic values; if none is specified, the atomic object is initialized with zero.</p><p>Atomic objects can be accessed using the <code>[]</code> notation:</p><pre><code class="language-Julia">x::Atomic{Int}
x[] = 1
val = x[]</code></pre><p>Atomic operations use an <code>atomic_</code> prefix, such as <code>atomic_add!</code>, <code>atomic_xchg!</code>, etc.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/atomics.jl#L35-L58">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Threads.atomic_cas!" href="#Base.Threads.atomic_cas!"><code>Base.Threads.atomic_cas!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Threads.atomic_cas!{T}(x::Atomic{T}, cmp::T, newval::T)</code></pre><p>Atomically compare-and-set <code>x</code></p><p>Atomically compares the value in <code>x</code> with <code>cmp</code>. If equal, write <code>newval</code> to <code>x</code>. Otherwise, leaves <code>x</code> unmodified. Returns the old value in <code>x</code>. By comparing the returned value to <code>cmp</code> (via <code>===</code>) one knows whether <code>x</code> was modified and now holds the new value <code>newval</code>.</p><p>For further details, see LLVM&#39;s <code>cmpxchg</code> instruction.</p><p>This function can be used to implement transactional semantics. Before the transaction, one records the value in <code>x</code>. After the transaction, the new value is stored only if <code>x</code> has not been modified in the mean time.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/atomics.jl#L67-L83">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Threads.atomic_xchg!" href="#Base.Threads.atomic_xchg!"><code>Base.Threads.atomic_xchg!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Threads.atomic_xchg!{T}(x::Atomic{T}, newval::T)</code></pre><p>Atomically exchange the value in <code>x</code></p><p>Atomically exchanges the value in <code>x</code> with <code>newval</code>. Returns the old value.</p><p>For further details, see LLVM&#39;s <code>atomicrmw xchg</code> instruction.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/atomics.jl#L86-L95">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Threads.atomic_add!" href="#Base.Threads.atomic_add!"><code>Base.Threads.atomic_add!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Threads.atomic_add!{T}(x::Atomic{T}, val::T)</code></pre><p>Atomically add <code>val</code> to <code>x</code></p><p>Performs <code>x[] += val</code> atomically. Returns the old (!) value.</p><p>For further details, see LLVM&#39;s <code>atomicrmw add</code> instruction.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/atomics.jl#L98-L106">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Threads.atomic_sub!" href="#Base.Threads.atomic_sub!"><code>Base.Threads.atomic_sub!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Threads.atomic_sub!{T}(x::Atomic{T}, val::T)</code></pre><p>Atomically subtract <code>val</code> from <code>x</code></p><p>Performs <code>x[] -= val</code> atomically. Returns the old (!) value.</p><p>For further details, see LLVM&#39;s <code>atomicrmw sub</code> instruction.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/atomics.jl#L109-L117">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Threads.atomic_and!" href="#Base.Threads.atomic_and!"><code>Base.Threads.atomic_and!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Threads.atomic_and!{T}(x::Atomic{T}, val::T)</code></pre><p>Atomically bitwise-and <code>x</code> with <code>val</code></p><p>Performs <code>x[] &amp;= val</code> atomically. Returns the old (!) value.</p><p>For further details, see LLVM&#39;s <code>atomicrmw and</code> instruction.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/atomics.jl#L120-L128">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Threads.atomic_nand!" href="#Base.Threads.atomic_nand!"><code>Base.Threads.atomic_nand!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Threads.atomic_nand!{T}(x::Atomic{T}, val::T)</code></pre><p>Atomically bitwise-nand (not-and) <code>x</code> with <code>val</code></p><p>Performs <code>x[] = ~(x[] &amp; val)</code> atomically. Returns the old (!) value.</p><p>For further details, see LLVM&#39;s <code>atomicrmw nand</code> instruction.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/atomics.jl#L131-L139">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Threads.atomic_or!" href="#Base.Threads.atomic_or!"><code>Base.Threads.atomic_or!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Threads.atomic_or!{T}(x::Atomic{T}, val::T)</code></pre><p>Atomically bitwise-or <code>x</code> with <code>val</code></p><p>Performs <code>x[] |= val</code> atomically. Returns the old (!) value.</p><p>For further details, see LLVM&#39;s <code>atomicrmw or</code> instruction.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/atomics.jl#L142-L150">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Threads.atomic_xor!" href="#Base.Threads.atomic_xor!"><code>Base.Threads.atomic_xor!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Threads.atomic_xor!{T}(x::Atomic{T}, val::T)</code></pre><p>Atomically bitwise-xor (exclusive-or) <code>x</code> with <code>val</code></p><p>Performs <code>x[] $= val</code> atomically. Returns the old (!) value.</p><p>For further details, see LLVM&#39;s <code>atomicrmw xor</code> instruction.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/atomics.jl#L153-L161">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Threads.atomic_max!" href="#Base.Threads.atomic_max!"><code>Base.Threads.atomic_max!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Threads.atomic_max!{T}(x::Atomic{T}, val::T)</code></pre><p>Atomically store the maximum of <code>x</code> and <code>val</code> in <code>x</code></p><p>Performs <code>x[] = max(x[], val)</code> atomically. Returns the old (!) value.</p><p>For further details, see LLVM&#39;s <code>atomicrmw min</code> instruction.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/atomics.jl#L164-L172">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Threads.atomic_min!" href="#Base.Threads.atomic_min!"><code>Base.Threads.atomic_min!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Threads.atomic_min!{T}(x::Atomic{T}, val::T)</code></pre><p>Atomically store the minimum of <code>x</code> and <code>val</code> in <code>x</code></p><p>Performs <code>x[] = min(x[], val)</code> atomically. Returns the old (!) value.</p><p>For further details, see LLVM&#39;s <code>atomicrmw max</code> instruction.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/atomics.jl#L175-L183">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Threads.atomic_fence" href="#Base.Threads.atomic_fence"><code>Base.Threads.atomic_fence</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Threads.atomic_fence()</code></pre><p>Insert a sequential-consistency memory fence</p><p>Inserts a memory fence with sequentially-consistent ordering semantics. There are algorithms where this is needed, i.e. where an acquire/release ordering is insufficient.</p><p>This is likely a very expensive operation. Given that all other atomic operations in Julia already have acquire/release semantics, explicit fences should not be necessary in most cases.</p><p>For further details, see LLVM&#39;s <code>fence</code> instruction.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/atomics.jl#L342-L356">source</a><br/></section><a class="nav-anchor" id="Cluster-Manager-Interface-1" href="#Cluster-Manager-Interface-1"><h2>Cluster Manager Interface</h2></a><p>This interface provides a mechanism to launch and manage Julia workers on different cluster environments. LocalManager, for launching additional workers on the same host and SSHManager, for launching on remote hosts via ssh are present in Base. TCP/IP sockets are used to connect and transport messages between processes. It is possible for Cluster Managers to provide a different transport.</p><pre><code class="language-none">Base.launch
Base.manage
Base.kill
Base.init_worker
Base.connect
Base.process_messages</code></pre><footer><hr/><a class="previous" href="numbers.html"><span class="direction">Previous</span><span class="title">Numbers</span></a><a class="next" href="pkg.html"><span class="direction">Next</span><span class="title">Package Manager Functions</span></a></footer></article></body></html>
