<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Unit Testing · Julia language documentation</title><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../assets/debug.js"></script></head><body><nav class="toc"><a href><img class="logo" src="../logo.png" alt="Julia language logo"/></a><h1>Julia language</h1><input id="search-query" type="text" placeholder="Search docs"/><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../manual/arrays.html">Multi-dimensional Arrays</a></li><li><a class="toctext" href="../manual/calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="toctext" href="../manual/complex-and-rational-numbers.html">Complex and Rational Numbers</a></li><li><a class="toctext" href="../manual/constructors.html">Constructors</a></li><li><a class="toctext" href="../manual/control-flow.html">Control Flow</a></li><li><a class="toctext" href="../manual/conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="toctext" href="../manual/dates.html">Date and DateTime</a></li><li><a class="toctext" href="../manual/documentation.html">Documentation</a></li><li><a class="toctext" href="../manual/embedding.html">Embedding Julia</a></li><li><a class="toctext" href="../manual/faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="../manual/functions.html">Functions</a></li><li><a class="toctext" href="../manual/getting-started.html">Getting Started</a></li><li><a class="toctext" href="../manual/handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="../manual/index.html">The Julia Manual</a></li><li><a class="toctext" href="../manual/integers-and-floating-point-numbers.html">Integers and Floating-Point Numbers</a></li><li><a class="toctext" href="../manual/interacting-with-julia.html">Interacting With Julia</a></li><li><a class="toctext" href="../manual/interfaces.html">Interfaces</a></li><li><a class="toctext" href="../manual/introduction.html">Introduction</a></li><li><a class="toctext" href="../manual/linear-algebra.html">Linear algebra</a></li><li><a class="toctext" href="../manual/mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="../manual/metaprogramming.html">Metaprogramming</a></li><li><a class="toctext" href="../manual/methods.html">Methods</a></li><li><a class="toctext" href="../manual/modules.html">Modules</a></li><li><a class="toctext" href="../manual/networking-and-streams.html">Networking and Streams</a></li><li><a class="toctext" href="../manual/noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="../manual/packages.html">Packages</a></li><li><a class="toctext" href="../manual/parallel-computing.html">Parallel Computing</a></li><li><a class="toctext" href="../manual/performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="../manual/profile.html">Profiling</a></li><li><a class="toctext" href="../manual/running-external-programs.html">Running External Programs</a></li><li><a class="toctext" href="../manual/stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="../manual/strings.html">Strings</a></li><li><a class="toctext" href="../manual/style-guide.html">Style Guide</a></li><li><a class="toctext" href="../manual/types.html">Types</a></li><li><a class="toctext" href="../manual/unicode-input.html">Unicode Input</a></li><li><a class="toctext" href="../manual/variables-and-scoping.html">Scope of Variables</a></li><li><a class="toctext" href="../manual/variables.html">Variables</a></li><li><a class="toctext" href="../manual/workflow-tips.html">Workflow Tips</a></li></ul></li><li><span class="toctext">Standard Libary</span><ul><li><a class="toctext" href="arrays.html">Arrays</a></li><li><a class="toctext" href="base.html">Essentials</a></li><li><a class="toctext" href="c.html">C Interface</a></li><li><a class="toctext" href="collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="constants.html">Constants</a></li><li><a class="toctext" href="dates.html">Dates and Time</a></li><li><a class="toctext" href="file.html">Filesystem</a></li><li><a class="toctext" href="index.html">The Julia Standard Library</a></li><li><a class="toctext" href="io-network.html">I/O and Network</a></li><li><a class="toctext" href="libc.html">C Standard Library</a></li><li><a class="toctext" href="libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="linalg.html">Linear Algebra</a></li><li><a class="toctext" href="math.html">Mathematics</a></li><li><a class="toctext" href="numbers.html">Numbers</a></li><li><a class="toctext" href="parallel.html">Tasks and Parallel Computing</a></li><li><a class="toctext" href="pkg.html">Package Manager Functions</a></li><li><a class="toctext" href="profile.html">Profiling</a></li><li><a class="toctext" href="punctuation.html">Punctuation</a></li><li><a class="toctext" href="simd-types.html">SIMD Support</a></li><li><a class="toctext" href="sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="stacktraces.html">StackTraces</a></li><li><a class="toctext" href="strings.html">Strings</a></li><li class="current"><a class="toctext" href="test.html">Unit Testing</a><ul class="internal"><li><a class="toctext" href="#Testing-Base-Julia-1">Testing Base Julia</a></li><li><a class="toctext" href="#Basic-Unit-Tests-1">Basic Unit Tests</a></li><li><a class="toctext" href="#Working-with-Test-Sets-1">Working with Test Sets</a></li><li><a class="toctext" href="#Other-Test-Macros-1">Other Test Macros</a></li><li><a class="toctext" href="#Broken-Tests-1">Broken Tests</a></li><li><a class="toctext" href="#Creating-Custom-AbstractTestSet-Types-1">Creating Custom <code>AbstractTestSet</code> Types</a></li></ul></li></ul></li><li><span class="toctext">DevDocs</span><ul><li><a class="toctext" href="../devdocs/C.html">Developing/debugging Julia&#39;s C code</a></li><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../devdocs/julia.html">Documentation of Julia&#39;s Internals</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/promote-op.html">Operator-sensitive promotion</a></li><li><a class="toctext" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/types.html">More about types</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li></ul></li><li><span class="toctext">Dynamic pages</span><ul><li><a class="toctext" href="../dynamic/code.html">Code examples</a></li><li><a class="toctext" href="../dynamic/admonitions.html">Admonitions &amp; Co</a></li><li><a class="toctext" href="../dynamic/styles.html">Demonstrating <em>styles</em> of MD elements</a></li><li><a class="toctext" href="../dynamic/latex.html">The <span>$\sin(x^2)$</span> project</a></li><li><a class="toctext" href="../dynamic/bugs.html">Some existing bugs</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Standard Libary</li><li><a href="test.html">Unit Testing</a></li></ul><a class="edit-page" href="https://github.com/"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><a class="nav-anchor" id="Unit-Testing-1"><h1>Unit Testing</h1></a><a class="nav-anchor" id="Testing-Base-Julia-1"><h2>Testing Base Julia</h2></a><p>Julia is under rapid development and has an extensive test suite to verify functionality across multiple platforms. If you build Julia from source, you can run this test suite with <code>make test</code>. In a binary install, you can run the test suite using <code>Base.runtests()</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.runtests" href="#Base.runtests"><code>Base.runtests</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">runtests([tests=[&quot;all&quot;] [, numcores=ceil(Integer, Sys.CPU_CORES / 2) ]])</code></pre><p>Run the Julia unit tests listed in <code>tests</code>, which can be either a string or an array of strings, using <code>numcores</code> processors. (not exported)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/docs/helpdb/Base.jl#L8269-L8274">source</a><br/></section><a class="nav-anchor" id="Basic-Unit-Tests-1"><h2>Basic Unit Tests</h2></a><p>The <code>Base.Test</code> module provides simple <em>unit testing</em> functionality. Unit testing is a way to see if your code is correct by checking that the results are what you expect. It can be helpful to ensure your code still works after you make changes, and can be used when developing as a way of specifying the behaviors your code should have when complete.</p><p>Simple unit testing can be performed with the <code>@test()</code> and <code>@test_throws()</code> macros:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Test.@test" href="#Base.Test.@test"><code>Base.Test.@test</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@test ex</code></pre><p>Tests that the expression <code>ex</code> evaluates to <code>true</code>. Returns a <code>Pass</code> <code>Result</code> if it does, a <code>Fail</code> <code>Result</code> if it is <code>false</code>, and an <code>Error</code> <code>Result</code> if it could not be evaluated.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/test.jl#L181-L187">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Test.@test_throws" href="#Base.Test.@test_throws"><code>Base.Test.@test_throws</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@test_throws extype ex</code></pre><p>Tests that the expression <code>ex</code> throws an exception of type <code>extype</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/test.jl#L298-L302">source</a><br/></section><p>For example, suppose we want to check our new function <code>foo(x)</code> works as expected:</p><pre><code class="language-jlcon">julia&gt; using Base.Test

julia&gt; foo(x) = length(x)^2
foo (generic function with 1 method)</code></pre><p>If the condition is true, a <code>Pass</code> is returned:</p><pre><code class="language-jlcon">julia&gt; @test foo(&quot;bar&quot;) == 9
Test Passed
  Expression: foo(&quot;bar&quot;) == 9
   Evaluated: 9 == 9

julia&gt; @test foo(&quot;fizz&quot;) &gt;= 10
Test Passed
  Expression: foo(&quot;fizz&quot;) &gt;= 10
   Evaluated: 16 &gt;= 10</code></pre><p>If the condition is false, then a <code>Fail</code> is returned and an exception is thrown:</p><pre><code class="language-jlcon">julia&gt; @test foo(&quot;f&quot;) == 20
Test Failed
  Expression: foo(&quot;f&quot;) == 20
   Evaluated: 1 == 20
ERROR: There was an error during testing
 in record at test.jl:268
 in do_test at test.jl:191</code></pre><p>If the condition could not be evaluated because an exception was thrown, which occurs in this case because <code>length()</code> is not defined for symbols, an <code>Error</code> object is returned and an exception is thrown:</p><pre><code class="language-jlcon">julia&gt; @test foo(:cat) == 1
Error During Test
  Test threw an exception of type MethodError
  Expression: foo(:cat) == 1
  MethodError: `length` has no method matching length(::Symbol)
   in foo at none:1
   in anonymous at test.jl:159
   in do_test at test.jl:180
ERROR: There was an error during testing
 in record at test.jl:268
 in do_test at test.jl:191</code></pre><p>If we expect that evaluating an expression <em>should</em> throw an exception, then we can use <code>@test_throws()</code> to check that this occurs:</p><pre><code class="language-jlcon">julia&gt; @test_throws MethodError foo(:cat)
Test Passed
  Expression: foo(:cat)
   Evaluated: MethodError</code></pre><a class="nav-anchor" id="Working-with-Test-Sets-1"><h2>Working with Test Sets</h2></a><p>Typically a large of number of tests are used to make sure functions work correctly over a range of inputs. In the event a test fails, the default behavior is to throw an exception immediately. However, it is normally preferable to run the rest of the tests first to get a better picture of how many errors there are in the code being tested.</p><p>The <code>@testset()</code> macro can be used to group tests into <em>sets</em>. All the tests in a test set will be run, and at the end of the test set a summary will be printed. If any of the tests failed, or could not be evaluated due to an error, the test set will then throw a <code>TestSetException</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Test.@testset" href="#Base.Test.@testset"><code>Base.Test.@testset</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@testset [CustomTestSet] [option=val  ...] [&quot;description&quot;] begin ... end
@testset [CustomTestSet] [option=val  ...] [&quot;description $v&quot;] for v in (...) ... end
@testset [CustomTestSet] [option=val  ...] [&quot;description $v, $w&quot;] for v in (...), w in (...) ... end</code></pre><p>Starts a new test set, or multiple test sets if a <code>for</code> loop is provided.</p><p>If no custom testset type is given it defaults to creating a <code>DefaultTestSet</code>. <code>DefaultTestSet</code> records all the results and, and if there are any <code>Fail</code>s or <code>Error</code>s, throws an exception at the end of the top-level (non-nested) test set, along with a summary of the test results.</p><p>Any custom testset type (subtype of <code>AbstractTestSet</code>) can be given and it will also be used for any nested <code>@testset</code> invocations. The given options are only applied to the test set where they are given. The default test set type does not take any options.</p><p>The description string accepts interpolation from the loop indices. If no description is provided, one is constructed based on the variables.</p><p>By default the <code>@testset</code> macro will return the testset object itself, though this behavior can be customized in other testset types. If a <code>for</code> loop is used then the macro collects and returns a list of the return values of the <code>finish</code> method, which by default will return a list of the testset objects used in each iteration.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/test.jl#L607-L632">source</a><br/></section><p>We can put our tests for the <code>foo(x)</code> function in a test set:</p><pre><code class="language-jlcon">julia&gt; @testset &quot;Foo Tests&quot; begin
           @test foo(&quot;a&quot;)   == 1
           @test foo(&quot;ab&quot;)  == 4
           @test foo(&quot;abc&quot;) == 9
       end
Test Summary: | Pass  Total
Foo Tests     |    3      3</code></pre><p>Test sets can also be nested:</p><pre><code class="language-jlcon">julia&gt; @testset &quot;Foo Tests&quot; begin
           @testset &quot;Animals&quot; begin
               @test foo(&quot;cat&quot;) == 9
               @test foo(&quot;dog&quot;) == foo(&quot;cat&quot;)
           end
           @testset &quot;Arrays $i&quot; for i in 1:3
               @test foo(zeros(i)) == i^2
               @test foo(ones(i)) == i^2
           end
       end
Test Summary: | Pass  Total
Foo Tests     |    8      8</code></pre><p>In the event that a nested test set has no failures, as happened here, it will be hidden in the summary. If we do have a test failure, only the details for the failed test sets will be shown:</p><pre><code class="language-jlcon">julia&gt; @testset &quot;Foo Tests&quot; begin
           @testset &quot;Animals&quot; begin
               @testset &quot;Felines&quot; begin
                   @test foo(&quot;cat&quot;) == 9
               end
               @testset &quot;Canines&quot; begin
                   @test foo(&quot;dog&quot;) == 9
               end
           end
           @testset &quot;Arrays&quot; begin
               @test foo(zeros(2)) == 4
               @test foo(ones(4)) == 15
           end
       end

Arrays: Test Failed
  Expression: foo(ones(4)) == 15
   Evaluated: 16 == 15
 in record at test.jl:297
 in do_test at test.jl:191
Test Summary: | Pass  Fail  Total
Foo Tests     |    3     1      4
  Animals     |    2            2
  Arrays      |    1     1      2
ERROR: Some tests did not pass: 3 passed, 1 failed, 0 errored, 0 broken.
 in finish at test.jl:362</code></pre><a class="nav-anchor" id="Other-Test-Macros-1"><h2>Other Test Macros</h2></a><p>As calculations on floating-point values can be imprecise, you can perform approximate equality checks using either <code>@test a ≈ b</code> (where <code>≈</code>, typed via tab completion of <code>\approx</code>, is the <code>isapprox()</code> function) or use <code>isapprox()</code> directly.</p><p>An alternative is the <code>@test_approx_eq</code> macro (which differs from <code>isapprox</code> in that it treats NaN values as equal and has a smaller default tolerance) or <code>@test_approx_eq_eps</code> (which takes an extra argument indicating the relative tolerance):</p><pre><code class="language-jlcon">julia&gt; @test 1 ≈ 0.999999999

julia&gt; @test 1 ≈ 0.999999
ERROR: test failed: 1 isapprox 0.999999
 in expression: 1 ≈ 0.999999
 in error at error.jl:21
 in default_handler at test.jl:30
 in do_test at test.jl:53

julia&gt; @test_approx_eq 1. 0.999999999
ERROR: assertion failed: |1.0 - 0.999999999| &lt; 2.220446049250313e-12
  1.0 = 1.0
  0.999999999 = 0.999999999
 in test_approx_eq at test.jl:75
 in test_approx_eq at test.jl:80

julia&gt; @test_approx_eq 1. 0.9999999999999

julia&gt; @test_approx_eq_eps 1. 0.999 1e-2

julia&gt; @test_approx_eq_eps 1. 0.999 1e-3
ERROR: assertion failed: |1.0 - 0.999| &lt;= 0.001
  1.0 = 1.0
  0.999 = 0.999
  difference = 0.0010000000000000009 &gt; 0.001
 in error at error.jl:22
 in test_approx_eq at test.jl:68</code></pre><p>Note that these macros will fail immediately, and are not compatible with <code>@testset()</code>, so using <code>@test isapprox</code> is encouraged when writing new tests.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Test.@test_approx_eq" href="#Base.Test.@test_approx_eq"><code>Base.Test.@test_approx_eq</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@test_approx_eq(a, b)</code></pre><p>Test two floating point numbers <code>a</code> and <code>b</code> for equality taking into account small numerical errors.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/test.jl#L871-L876">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Test.@test_approx_eq_eps" href="#Base.Test.@test_approx_eq_eps"><code>Base.Test.@test_approx_eq_eps</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@test_approx_eq_eps(a, b, tol)</code></pre><p>Test two floating point numbers <code>a</code> and <code>b</code> for equality taking into account a margin of tolerance given by <code>tol</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/test.jl#L861-L866">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Test.@inferred" href="#Base.Test.@inferred"><code>Base.Test.@inferred</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@inferred f(x)</code></pre><p>Tests that the call expression <code>f(x)</code> returns a value of the same type inferred by the compiler. It is useful to check for type stability.</p><p><code>f(x)</code> can be any call expression. Returns the result of <code>f(x)</code> if the types match, and an <code>Error</code> <code>Result</code> if it finds different types.</p><pre><code class="language-jldoctest">julia&gt; using Base.Test

julia&gt; f(a,b,c) = b &gt; 1 ? 1 : 1.0
f (generic function with 1 method)

julia&gt; typeof(f(1,2,3))
Int64

julia&gt; @code_warntype f(1,2,3)
...
Body:
  begin
      unless (Base.slt_int)(1,b::Int64)::Bool goto 3
      return 1
      3:
      return 1.0
  end::UNION{FLOAT64,INT64}

julia&gt; @inferred f(1,2,3)
ERROR: return type Int64 does not match inferred return type Union{Float64,Int64}
 in error(::String) at ./error.jl:21
 ...

julia&gt; @inferred max(1,2)
2</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/test.jl#L882-L919">source</a><br/></section><a class="nav-anchor" id="Broken-Tests-1"><h2>Broken Tests</h2></a><p>If a test fails consistently it can be changed to use the <code>@test_broken()</code> macro. This will denote the test as <code>Broken</code> if the test continues to fail and alerts the user via an <code>Error</code> if the test succeeds.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Test.@test_broken" href="#Base.Test.@test_broken"><code>Base.Test.@test_broken</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@test_broken ex</code></pre><p>Indicates a test that should pass but currently consistently fails. Tests that the expression <code>ex</code> evaluates to <code>false</code> or causes an exception. Returns a <code>Broken</code> <code>Result</code> if it does, or an <code>Error</code> <code>Result</code> if the expression evaluates to <code>true</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/test.jl#L194-L201">source</a><br/></section><p><code>@test_skip()</code> is also available to skip a test without evaluation, but counting the skipped test in the test set reporting. The test will not run but gives a <code>Broken</code><code>Result</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Test.@test_skip" href="#Base.Test.@test_skip"><code>Base.Test.@test_skip</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@test_skip ex</code></pre><p>Marks a test that should not be executed but should be included in test summary reporting as <code>Broken</code>. This can be useful for tests that intermittently fail, or tests of not-yet-implemented functionality.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/test.jl#L209-L215">source</a><br/></section><a class="nav-anchor" id="Creating-Custom-AbstractTestSet-Types-1"><h2>Creating Custom <code>AbstractTestSet</code> Types</h2></a><p>Packages can create their own <code>AbstractTestSet</code> subtypes by implementing the <code>record</code> and <code>finish</code> methods. The subtype should have a one-argument constructor taking a description string, with any options passed in as keyword arguments.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Test.record" href="#Base.Test.record"><code>Base.Test.record</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">record(ts::AbstractTestSet, res::Result)</code></pre><p>Record a result to a testset. This function is called by the <code>@testset</code> infrastructure each time a contained <code>@test</code> macro completes, and is given the test result (which could be an <code>Error</code>). This will also be called with an <code>Error</code> if an exception is thrown inside the test block but outside of a <code>@test</code> context.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/test.jl#L341-L348">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Test.finish" href="#Base.Test.finish"><code>Base.Test.finish</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">finish(ts::AbstractTestSet)</code></pre><p>Do any final processing necessary for the given testset. This is called by the <code>@testset</code> infrastructure after a test block executes. One common use for this function is to record the testset to the parent&#39;s results list, using <code>get_testset</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/test.jl#L351-L358">source</a><br/></section><p><code>Base.Test</code> takes responsibility for maintaining a stack of nested testsets as they are executed, but any result accumulation is the responsibility of the <code>AbstractTestSet</code> subtype. You can access this stack with the <code>get_testset</code> and <code>get_testset_depth</code> methods. Note that these functions are not exported.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Test.get_testset" href="#Base.Test.get_testset"><code>Base.Test.get_testset</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">get_testset()</code></pre><p>Retrieve the active test set from the task&#39;s local storage. If no test set is active, use the fallback default test set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/test.jl#L775-L780">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Test.get_testset_depth" href="#Base.Test.get_testset_depth"><code>Base.Test.get_testset_depth</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">get_testset_depth()</code></pre><p>Returns the number of active test sets, not including the defaut test set</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/test.jl#L810-L814">source</a><br/></section><p><code>Base.Test</code> also makes sure that nested <code>@testset</code> invocations use the same <code>AbstractTestSet</code> subtype as their parent unless it is set explicitly. It does not propagate any properties of the testset. Option inheritance behavior can be implemented by packages using the stack infrastructure that <code>Base.Test</code> provides.</p><p>Defining a basic <code>AbstractTestSet</code> subtype might look like:</p><pre><code class="language-julia">import Base.Test: record, finish
using Base.Test: AbstractTestSet, Result, Pass, Fail, Error
using Base.Test: get_testset_depth, get_testset
immutable CustomTestSet &lt;: Base.Test.AbstractTestSet
    description::AbstractString
    foo::Int
    results::Vector
    # constructor takes a description string and options keyword arguments
    CustomTestSet(desc; foo=1) = new(desc, foo, [])
end

record(ts::CustomTestSet, child::AbstractTestSet) = push!(ts.results, child)
record(ts::CustomTestSet, res::Result) = push!(ts.results, res)
function finish(ts::CustomTestSet)
    # just record if we&#39;re not the top-level parent
    if get_testset_depth() &gt; 0
        record(get_testset(), ts)
    end
    ts
end</code></pre><p>And using that testset looks like:</p><pre><code class="language-julia">@testset CustomTestSet foo=4 &quot;custom testset inner 2&quot; begin
    # this testset should inherit the type, but not the argument.
    @testset &quot;custom testset inner&quot; begin
        @test true
    end
end</code></pre><footer><hr/><a class="previous" href="strings.html"><span class="direction">Previous</span><span class="title">Strings</span></a><a class="next" href="../devdocs/C.html"><span class="direction">Next</span><span class="title">Developing/debugging Julia&#39;s C code</span></a></footer></article></body></html>
