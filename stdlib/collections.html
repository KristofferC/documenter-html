<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Collections and Data Structures · Julia language documentation</title><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../assets/debug.js"></script></head><body><nav class="toc"><a href><img class="logo" src="../logo.png" alt="Julia language logo"/></a><h1>Julia language</h1><input id="search-query" type="text" placeholder="Search docs"/><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../manual/arrays.html">Multi-dimensional Arrays</a></li><li><a class="toctext" href="../manual/calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="toctext" href="../manual/complex-and-rational-numbers.html">Complex and Rational Numbers</a></li><li><a class="toctext" href="../manual/constructors.html">Constructors</a></li><li><a class="toctext" href="../manual/control-flow.html">Control Flow</a></li><li><a class="toctext" href="../manual/conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="toctext" href="../manual/dates.html">Date and DateTime</a></li><li><a class="toctext" href="../manual/documentation.html">Documentation</a></li><li><a class="toctext" href="../manual/embedding.html">Embedding Julia</a></li><li><a class="toctext" href="../manual/faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="../manual/functions.html">Functions</a></li><li><a class="toctext" href="../manual/getting-started.html">Getting Started</a></li><li><a class="toctext" href="../manual/handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="../manual/index.html">The Julia Manual</a></li><li><a class="toctext" href="../manual/integers-and-floating-point-numbers.html">Integers and Floating-Point Numbers</a></li><li><a class="toctext" href="../manual/interacting-with-julia.html">Interacting With Julia</a></li><li><a class="toctext" href="../manual/interfaces.html">Interfaces</a></li><li><a class="toctext" href="../manual/introduction.html">Introduction</a></li><li><a class="toctext" href="../manual/linear-algebra.html">Linear algebra</a></li><li><a class="toctext" href="../manual/mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="../manual/metaprogramming.html">Metaprogramming</a></li><li><a class="toctext" href="../manual/methods.html">Methods</a></li><li><a class="toctext" href="../manual/modules.html">Modules</a></li><li><a class="toctext" href="../manual/networking-and-streams.html">Networking and Streams</a></li><li><a class="toctext" href="../manual/noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="../manual/packages.html">Packages</a></li><li><a class="toctext" href="../manual/parallel-computing.html">Parallel Computing</a></li><li><a class="toctext" href="../manual/performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="../manual/profile.html">Profiling</a></li><li><a class="toctext" href="../manual/running-external-programs.html">Running External Programs</a></li><li><a class="toctext" href="../manual/stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="../manual/strings.html">Strings</a></li><li><a class="toctext" href="../manual/style-guide.html">Style Guide</a></li><li><a class="toctext" href="../manual/types.html">Types</a></li><li><a class="toctext" href="../manual/unicode-input.html">Unicode Input</a></li><li><a class="toctext" href="../manual/variables-and-scoping.html">Scope of Variables</a></li><li><a class="toctext" href="../manual/variables.html">Variables</a></li><li><a class="toctext" href="../manual/workflow-tips.html">Workflow Tips</a></li></ul></li><li><span class="toctext">Standard Libary</span><ul><li><a class="toctext" href="arrays.html">Arrays</a></li><li><a class="toctext" href="base.html">Essentials</a></li><li><a class="toctext" href="c.html">C Interface</a></li><li class="current"><a class="toctext" href="collections.html">Collections and Data Structures</a><ul class="internal"><li><a class="toctext" href="#Iteration-1">Iteration</a></li><li><a class="toctext" href="#General-Collections-1">General Collections</a></li><li><a class="toctext" href="#Iterable-Collections-1">Iterable Collections</a></li><li><a class="toctext" href="#Indexable-Collections-1">Indexable Collections</a></li><li><a class="toctext" href="#Associative-Collections-1">Associative Collections</a></li><li><a class="toctext" href="#Set-Like-Collections-1">Set-Like Collections</a></li><li><a class="toctext" href="#Dequeues-1">Dequeues</a></li><li><a class="toctext" href="#PriorityQueue-1">PriorityQueue</a></li><li><a class="toctext" href="#Heap-Functions-1">Heap Functions</a></li></ul></li><li><a class="toctext" href="constants.html">Constants</a></li><li><a class="toctext" href="dates.html">Dates and Time</a></li><li><a class="toctext" href="file.html">Filesystem</a></li><li><a class="toctext" href="index.html">The Julia Standard Library</a></li><li><a class="toctext" href="io-network.html">I/O and Network</a></li><li><a class="toctext" href="libc.html">C Standard Library</a></li><li><a class="toctext" href="libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="linalg.html">Linear Algebra</a></li><li><a class="toctext" href="math.html">Mathematics</a></li><li><a class="toctext" href="numbers.html">Numbers</a></li><li><a class="toctext" href="parallel.html">Tasks and Parallel Computing</a></li><li><a class="toctext" href="pkg.html">Package Manager Functions</a></li><li><a class="toctext" href="profile.html">Profiling</a></li><li><a class="toctext" href="punctuation.html">Punctuation</a></li><li><a class="toctext" href="simd-types.html">SIMD Support</a></li><li><a class="toctext" href="sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="stacktraces.html">StackTraces</a></li><li><a class="toctext" href="strings.html">Strings</a></li><li><a class="toctext" href="test.html">Unit Testing</a></li></ul></li><li><span class="toctext">DevDocs</span><ul><li><a class="toctext" href="../devdocs/C.html">Developing/debugging Julia&#39;s C code</a></li><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../devdocs/julia.html">Documentation of Julia&#39;s Internals</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/promote-op.html">Operator-sensitive promotion</a></li><li><a class="toctext" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/types.html">More about types</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li></ul></li><li><span class="toctext">Dynamic pages</span><ul><li><a class="toctext" href="../dynamic/code.html">Code examples</a></li><li><a class="toctext" href="../dynamic/admonitions.html">Admonitions &amp; Co</a></li><li><a class="toctext" href="../dynamic/styles.html">Demonstrating <em>styles</em> of MD elements</a></li><li><a class="toctext" href="../dynamic/latex.html">The <span>$\sin(x^2)$</span> project</a></li><li><a class="toctext" href="../dynamic/bugs.html">Some existing bugs</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Standard Libary</li><li><a href="collections.html">Collections and Data Structures</a></li></ul><a class="edit-page" href="https://github.com/"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><a id="Collections-and-Data-Structures-1"></a><h1>Collections and Data Structures</h1><a id="Iteration-1"></a><h2>Iteration</h2><p>Sequential iteration is implemented by the methods <a href="collections.html#Base.start"><code>start()</code></a>, <a href="collections.html#Base.done"><code>done()</code></a>, and <a href="collections.html#Base.next"><code>next()</code></a>. The general <code>for</code> loop:</p><pre><code class="language-julia">for i = I   # or  &quot;for i in I&quot;
    # body
end</code></pre><p>is translated into:</p><pre><code class="language-julia">state = start(I)
while !done(I, state)
    (i, state) = next(I, state)
    # body
end</code></pre><p>The <code>state</code> object may be anything, and should be chosen appropriately for each iterable type. See the <a href="@ref">manual section on the iteration interface</a> for more details about defining a custom iterable type.</p><section class="docstring"><div class="docheader"><a id="Base.start" href="#Base.start"># <strong><code>Base.start</code></strong></a> — <em>Function</em>.</div><div><pre><code class="language-none">start(iter) -&gt; state</code></pre><p>Get initial iteration state for an iterable object.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/docs/helpdb/Base.jl#L7337-L7341">source</a><br/></section><section class="docstring"><div class="docheader"><a id="Base.done" href="#Base.done"># <strong><code>Base.done</code></strong></a> — <em>Function</em>.</div><div><pre><code class="language-none">done(iter, state) -&gt; Bool</code></pre><p>Test whether we are done iterating.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/docs/helpdb/Base.jl#L7489-L7493">source</a><br/></section><section class="docstring"><div class="docheader"><a id="Base.next" href="#Base.next"># <strong><code>Base.next</code></strong></a> — <em>Function</em>.</div><div><pre><code class="language-none">next(iter, state) -&gt; item, state</code></pre><p>For a given iterable object and iteration state, return the current item and the next iteration state.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/docs/helpdb/Base.jl#L3430-L3434">source</a><br/></section><section class="docstring"><div class="docheader"><a id="Base.zip" href="#Base.zip"># <strong><code>Base.zip</code></strong></a> — <em>Function</em>.</div><div><pre><code class="language-none">zip(iters...)</code></pre><p>For a set of iterable objects, returns an iterable of tuples, where the <code>i</code>th tuple contains the <code>i</code>th component of each input iterable.</p><p>Note that <a href=":func:`zip`"><code>zip</code></a> is its own inverse: <code>collect(zip(zip(a...)...)) == collect(a)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/docs/helpdb/Base.jl#L3562-L3569">source</a><br/></section><section class="docstring"><div class="docheader"><a id="Base.enumerate" href="#Base.enumerate"># <strong><code>Base.enumerate</code></strong></a> — <em>Function</em>.</div><div><pre><code class="language-none">enumerate(iter)</code></pre><p>An iterator that yields <code>(i, x)</code> where <code>i</code> is an index starting at 1, and <code>x</code> is the <code>i</code>th value from the given iterator. It&#39;s useful when you need not only the values <code>x</code> over which you are iterating, but also the index <code>i</code> of the iterations.</p><pre><code class="language-jldoctest">julia&gt; a = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];

julia&gt; for (index, value) in enumerate(a)
           println(&quot;$index $value&quot;)
       end
1 a
2 b
3 c</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/docs/helpdb/Base.jl#L8933-L8951">source</a><br/></section><section class="docstring"><div class="docheader"><a id="Base.rest" href="#Base.rest"># <strong><code>Base.rest</code></strong></a> — <em>Function</em>.</div><div><pre><code class="language-none">rest(iter, state)</code></pre><p>An iterator that yields the same elements as <code>iter</code>, but starting at the given <code>state</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/docs/helpdb/Base.jl#L2587-L2591">source</a><br/></section><section class="docstring"><div class="docheader"><a id="Base.countfrom" href="#Base.countfrom"># <strong><code>Base.countfrom</code></strong></a> — <em>Function</em>.</div><div><pre><code class="language-none">countfrom(start=1, step=1)</code></pre><p>An iterator that counts forever, starting at <code>start</code> and incrementing by <code>step</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/docs/helpdb/Base.jl#L2904-L2908">source</a><br/></section><section class="docstring"><div class="docheader"><a id="Base.take" href="#Base.take"># <strong><code>Base.take</code></strong></a> — <em>Function</em>.</div><div><pre><code class="language-none">take(iter, n)</code></pre><p>An iterator that generates at most the first <code>n</code> elements of <code>iter</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/docs/helpdb/Base.jl#L8233-L8237">source</a><br/></section><section class="docstring"><div class="docheader"><a id="Base.drop" href="#Base.drop"># <strong><code>Base.drop</code></strong></a> — <em>Function</em>.</div><div><pre><code class="language-none">drop(iter, n)</code></pre><p>An iterator that generates all but the first <code>n</code> elements of <code>iter</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/docs/helpdb/Base.jl#L3012-L3016">source</a><br/></section><section class="docstring"><div class="docheader"><a id="Base.cycle" href="#Base.cycle"># <strong><code>Base.cycle</code></strong></a> — <em>Function</em>.</div><div><pre><code class="language-none">cycle(iter)</code></pre><p>An iterator that cycles through <code>iter</code> forever.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/docs/helpdb/Base.jl#L6517-L6521">source</a><br/></section><section class="docstring"><div class="docheader"><a id="Base.repeated" href="#Base.repeated"># <strong><code>Base.repeated</code></strong></a> — <em>Function</em>.</div><div><pre><code class="language-none">repeated(x[, n::Int])</code></pre><p>An iterator that generates the value <code>x</code> forever. If <code>n</code> is specified, generates <code>x</code> that many times (equivalent to <code>take(repeated(x), n)</code>).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/docs/helpdb/Base.jl#L5336-L5341">source</a><br/></section><section class="docstring"><div class="docheader"><a id="Base.iteratorsize" href="#Base.iteratorsize"># <strong><code>Base.iteratorsize</code></strong></a> — <em>Function</em>.</div><div><pre><code class="language-none">iteratorsize(itertype::Type) -&gt; IteratorSize</code></pre><p>Given the type of an iterator, returns one of the following values:</p><ul><li><p><code>SizeUnknown()</code> if the length (number of elements) cannot be determined in advance.</p></li><li><p><code>HasLength()</code> if there is a fixed, finite length.</p></li><li><p><code>HasShape()</code> if there is a known length plus a notion of multidimensional shape (as for an array). In this case the <code>size</code> function is valid for the iterator.</p></li><li><p><code>IsInfinite()</code> if the iterator yields values forever.</p></li></ul><p>The default value (for iterators that do not define this function) is <code>HasLength()</code>. This means that most iterators are assumed to implement <code>length</code>.</p><p>This trait is generally used to select between algorithms that pre-allocate space for their result, and algorithms that resize their result incrementally.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/generator.jl#L38-L54">source</a><br/></section><section class="docstring"><div class="docheader"><a id="Base.iteratoreltype" href="#Base.iteratoreltype"># <strong><code>Base.iteratoreltype</code></strong></a> — <em>Function</em>.</div><div><pre><code class="language-none">iteratoreltype(itertype::Type) -&gt; IteratorEltype</code></pre><p>Given the type of an iterator, returns one of the following values:</p><ul><li><p><code>EltypeUnknown()</code> if the type of elements yielded by the iterator is not known in advance.</p></li><li><p><code>HasEltype()</code> if the element type is known, and <code>eltype</code> would return a meaningful value.</p></li></ul><p><code>HasEltype()</code> is the default, since iterators are assumed to implement <code>eltype</code>.</p><p>This trait is generally used to select between algorithms that pre-allocate a specific type of result, and algorithms that pick a result type based on the types of yielded values.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/generator.jl#L67-L80">source</a><br/></section><p>Fully implemented by:</p><ul><li><p><code>Range</code></p></li><li><p><code>UnitRange</code></p></li><li><p><code>Tuple</code></p></li><li><p><code>Number</code></p></li><li><p><code>AbstractArray</code></p></li><li><p><a href="collections.html#Base.IntSet"><code>IntSet</code></a></p></li><li><p><code>ObjectIdDict</code></p></li><li><p><a href="collections.html#Base.Dict"><code>Dict</code></a></p></li><li><p><code>WeakKeyDict</code></p></li><li><p><code>EachLine</code></p></li><li><p><code>AbstractString</code></p></li><li><p><a href="collections.html#Base.Set"><code>Set</code></a></p></li><li><p><a href="parallel.html#Core.Task"><code>Task</code></a></p></li></ul><a id="General-Collections-1"></a><h2>General Collections</h2><pre><code class="language-none">Base.isempty
Base.empty!
Base.length
Base.endof</code></pre><p>Fully implemented by:</p><ul><li><p><code>Range</code></p></li><li><p><code>UnitRange</code></p></li><li><p><code>Tuple</code></p></li><li><p><code>Number</code></p></li><li><p><code>AbstractArray</code></p></li><li><p><a href="collections.html#Base.IntSet"><code>IntSet</code></a></p></li><li><p><a href="collections.html#Base.Dict"><code>Dict</code></a></p></li><li><p><code>WeakKeyDict</code></p></li><li><p><code>AbstractString</code></p></li><li><p><a href="collections.html#Base.Set"><code>Set</code></a></p></li></ul><a id="Iterable-Collections-1"></a><h2>Iterable Collections</h2><pre><code class="language-none">Base.in
Base.eltype
Base.indexin
Base.findin
Base.unique
Base.unique
Base.unique
Base.allunique
Base.reduce
Base.reduce
Base.foldl
Base.foldl
Base.foldr
Base.foldr
Base.maximum
Base.maximum
Base.maximum!
Base.minimum
Base.minimum
Base.minimum!
Base.extrema
Base.extrema
Base.indmax
Base.indmin
Base.findmax
Base.findmax
Base.findmin
Base.findmin
Base.findmax!
Base.findmin!
Base.maxabs
Base.maxabs
Base.maxabs!
Base.minabs
Base.minabs
Base.minabs!
Base.sum
Base.sum
Base.sum!
Base.sum
Base.sumabs
Base.sumabs
Base.sumabs!
Base.sumabs2
Base.sumabs2
Base.sumabs2!
Base.prod
Base.prod
Base.prod!
Base.any
Base.any
Base.any!
Base.all
Base.all
Base.all!
Base.count
Base.any
Base.all
Base.foreach
Base.map
Base.map!
Base.map!
Base.mapreduce
Base.mapreduce
Base.mapfoldl
Base.mapfoldl
Base.mapfoldr
Base.mapfoldr
Base.first
Base.last
Base.step
Base.collect
Base.collect
Base.issubset
Base.filter
Base.filter!</code></pre><a id="Indexable-Collections-1"></a><h2>Indexable Collections</h2><pre><code class="language-none">Base.getindex
Base.setindex!</code></pre><p>Fully implemented by:</p><ul><li><p><a href="arrays.html#Core.Array"><code>Array</code></a></p></li><li><p><code>BitArray</code></p></li><li><p><code>AbstractArray</code></p></li><li><p><code>SubArray</code></p></li><li><p><code>ObjectIdDict</code></p></li><li><p><a href="collections.html#Base.Dict"><code>Dict</code></a></p></li><li><p><code>WeakKeyDict</code></p></li><li><p><code>AbstractString</code></p></li></ul><p>Partially implemented by:</p><ul><li><p><code>Range</code></p></li><li><p><code>UnitRange</code></p></li><li><p><code>Tuple</code></p></li></ul><a id="Associative-Collections-1"></a><h2>Associative Collections</h2><p><a href="collections.html#Base.Dict"><code>Dict</code></a> is the standard associative collection. Its implementation uses <a href="base.html#Base.hash"><code>hash()</code></a> as the hashing function for the key, and <a href="base.html#Base.isequal"><code>isequal()</code></a> to determine equality. Define these two functions for custom types to override how they are stored in a hash table.</p><p><code>ObjectIdDict</code> is a special hash table where the keys are always object identities.</p><p><code>WeakKeyDict</code> is a hash table implementation where the keys are weak references to objects, and thus may be garbage collected even when referenced in a hash table.</p><p><a href="collections.html#Base.Dict"><code>Dict</code></a>s can be created by passing pair objects constructed with <code>=&gt;()</code> to a <a href="collections.html#Base.Dict"><code>Dict</code></a> constructor: <code>Dict(&quot;A&quot;=&gt;1, &quot;B&quot;=&gt;2)</code>. This call will attempt to infer type information from the keys and values (i.e. this example creates a <code>Dict{String, Int64}</code>). To explicitly specify types use the syntax <code>Dict{KeyType,ValueType}(...)</code>. For example, <code>Dict{String,Int32}(&quot;A&quot;=&gt;1, &quot;B&quot;=&gt;2)</code>.</p><p><a href="collections.html#Base.Dict"><code>Dict</code></a>s may also be created with generators. For example, <code>Dict(i =&gt; f(i) for i = 1:10)</code>.</p><p>Given a dictionary <code>D</code>, the syntax <code>D[x]</code> returns the value of key <code>x</code> (if it exists) or throws an error, and <code>D[x] = y</code> stores the key-value pair <code>x =&gt; y</code> in <code>D</code> (replacing any existing value for the key <code>x</code>).  Multiple arguments to <code>D[...]</code> are converted to tuples; for example, the syntax <code>D[x,y]</code>  is equivalent to <code>D[(x,y)]</code>, i.e. it refers to the value keyed by the tuple <code>(x,y)</code>.</p><pre><code class="language-none">Base.Dict
Base.haskey
Base.get
Base.get
Base.get!
Base.get!
Base.getkey
Base.delete!
Base.pop!
Base.keys
Base.values
Base.merge
Base.merge!
Base.sizehint!
Base.keytype
Base.valtype</code></pre><p>Fully implemented by:</p><ul><li><p><code>ObjectIdDict</code></p></li><li><p><a href="collections.html#Base.Dict"><code>Dict</code></a></p></li><li><p><code>WeakKeyDict</code></p></li></ul><p>Partially implemented by:</p><ul><li><p><a href="collections.html#Base.IntSet"><code>IntSet</code></a></p></li><li><p><a href="collections.html#Base.Set"><code>Set</code></a></p></li><li><p><a href="@ref"><code>EnvHash</code></a></p></li><li><p><a href="arrays.html#Core.Array"><code>Array</code></a></p></li><li><p><code>BitArray</code></p></li></ul><a id="Set-Like-Collections-1"></a><h2>Set-Like Collections</h2><pre><code class="language-none">Base.Set
Base.IntSet
Base.union
Base.union!
Base.intersect
Base.setdiff
Base.setdiff!
Base.symdiff
Base.symdiff!
Base.symdiff!
Base.symdiff!
Base.intersect!
Base.issubset</code></pre><p>Fully implemented by:</p><ul><li><p><a href="collections.html#Base.IntSet"><code>IntSet</code></a></p></li><li><p><a href="collections.html#Base.Set"><code>Set</code></a></p></li></ul><p>Partially implemented by:</p><ul><li><p><a href="arrays.html#Core.Array"><code>Array</code></a></p></li></ul><a id="Dequeues-1"></a><h2>Dequeues</h2><pre><code class="language-none">Base.push!
Base.pop!
Base.unshift!
Base.shift!
Base.insert!
Base.deleteat!
Base.deleteat!
Base.splice!
Base.splice!
Base.resize!
Base.append!
Base.prepend!</code></pre><p>Fully implemented by:</p><ul><li><p><code>Vector</code> (a.k.a. 1-dimensional <a href="arrays.html#Core.Array"><code>Array</code></a>)</p></li><li><p><code>BitVector</code> (a.k.a. 1-dimensional <code>BitArray</code>)</p></li></ul><a id="PriorityQueue-1"></a><h2>PriorityQueue</h2><p>The <a href="@ref"><code>PriorityQueue</code></a> type is available from the <code>Collections</code> module. It provides a basic priority queue implementation allowing for arbitrary key and priority types. Multiple identical keys are not permitted, but the priority of existing keys can be changed efficiently.</p><section class="docstring"><div class="docheader"><a id="Base.Collections.PriorityQueue" href="#Base.Collections.PriorityQueue"># <strong><code>Base.Collections.PriorityQueue</code></strong></a> — <em>Type</em>.</div><div><pre><code class="language-none">PriorityQueue(K, V, [ord])</code></pre><p>Construct a new <a href=":obj:`PriorityQueue`"><code>PriorityQueue</code></a>, with keys of type <code>K</code> and values/priorites of type <code>V</code>. If an order is not given, the priority queue is min-ordered using the default comparison for <code>V</code>.</p><p>A <code>PriorityQueue</code> acts like a <code>Dict</code>, mapping values to their priorities, with the addition of a <code>dequeue!</code> function to remove the lowest priority element.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/collections.jl#L149-L160">source</a><br/></section><section class="docstring"><div class="docheader"><a id="Base.Collections.enqueue!" href="#Base.Collections.enqueue!"># <strong><code>Base.Collections.enqueue!</code></strong></a> — <em>Function</em>.</div><div><pre><code class="language-none">enqueue!(pq, k, v)</code></pre><p>Insert the a key <code>k</code> into a priority queue <code>pq</code> with priority <code>v</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/collections.jl#L303-L307">source</a><br/></section><section class="docstring"><div class="docheader"><a id="Base.Collections.dequeue!" href="#Base.Collections.dequeue!"># <strong><code>Base.Collections.dequeue!</code></strong></a> — <em>Function</em>.</div><div><pre><code class="language-none">dequeue!(pq)</code></pre><p>Remove and return the lowest priority key from a priority queue.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/collections.jl#L318-L322">source</a><br/></section><section class="docstring"><div class="docheader"><a id="Base.Collections.peek" href="#Base.Collections.peek"># <strong><code>Base.Collections.peek</code></strong></a> — <em>Function</em>.</div><div><pre><code class="language-none">peek(pq)</code></pre><p>Return the lowest priority key from a priority queue without removing that key from the queue.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/collections.jl#L220-L225">source</a><br/></section><p><a href="@ref"><code>PriorityQueue</code></a> also behaves similarly to a <code>Dict</code> in that keys can be inserted and priorities accessed or changed using indexing notation.</p><pre><code class="language-jlcon">julia&gt; # Julia code
       pq = Collections.PriorityQueue();

julia&gt; # Insert keys with associated priorities
       pq[&quot;a&quot;] = 10; pq[&quot;b&quot;] = 5; pq[&quot;c&quot;] = 15; pq
Base.Collections.PriorityQueue{Any,Any,Base.Order.ForwardOrdering} with 3 entries:
  &quot;c&quot; =&gt; 15
  &quot;b&quot; =&gt; 5
  &quot;a&quot; =&gt; 10

julia&gt; # Change the priority of an existing key
       pq[&quot;a&quot;] = 0; pq
Base.Collections.PriorityQueue{Any,Any,Base.Order.ForwardOrdering} with 3 entries:
  &quot;c&quot; =&gt; 15
  &quot;b&quot; =&gt; 5
  &quot;a&quot; =&gt; 0</code></pre><a id="Heap-Functions-1"></a><h2>Heap Functions</h2><p>Along with the <a href="@ref"><code>PriorityQueue</code></a> type, the <code>Collections</code> module provides lower level functions for performing binary heap operations on arrays. Each function takes an optional ordering argument. If not given, default ordering is used, so that elements popped from the heap are given in ascending order.</p><section class="docstring"><div class="docheader"><a id="Base.Collections.heapify" href="#Base.Collections.heapify"># <strong><code>Base.Collections.heapify</code></strong></a> — <em>Function</em>.</div><div><pre><code class="language-none">heapify(v, [ord])</code></pre><p>Returns a new vector in binary heap order, optionally using the given ordering.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/collections.jl#L123-L127">source</a><br/></section><section class="docstring"><div class="docheader"><a id="Base.Collections.heapify!" href="#Base.Collections.heapify!"># <strong><code>Base.Collections.heapify!</code></strong></a> — <em>Function</em>.</div><div><pre><code class="language-none">heapify!(v, [ord])</code></pre><p>In-place <a href=":func:`heapify`"><code>heapify</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/collections.jl#L111-L115">source</a><br/></section><section class="docstring"><div class="docheader"><a id="Base.Collections.isheap" href="#Base.Collections.isheap"># <strong><code>Base.Collections.isheap</code></strong></a> — <em>Function</em>.</div><div><pre><code class="language-none">isheap(v, [ord])</code></pre><p>Return <code>true</code> if an array is heap-ordered according to the given order.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/collections.jl#L130-L134">source</a><br/></section><section class="docstring"><div class="docheader"><a id="Base.Collections.heappush!" href="#Base.Collections.heappush!"># <strong><code>Base.Collections.heappush!</code></strong></a> — <em>Function</em>.</div><div><pre><code class="language-none">heappush!(v, x, [ord])</code></pre><p>Given a binary heap-ordered array, push a new element <code>x</code>, preserving the heap property. For efficiency, this function does not check that the array is indeed heap-ordered.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/collections.jl#L97-L102">source</a><br/></section><section class="docstring"><div class="docheader"><a id="Base.Collections.heappop!" href="#Base.Collections.heappop!"># <strong><code>Base.Collections.heappop!</code></strong></a> — <em>Function</em>.</div><div><pre><code class="language-none">heappop!(v, [ord])</code></pre><p>Given a binary heap-ordered array, remove and return the lowest ordered element. For efficiency, this function does not check that the array is indeed heap-ordered.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/cede5394b79c152829203dd9c19bf30772eb7ca1/base/collections.jl#L82-L87">source</a><br/></section><footer><hr/><a class="previous" href="c.html"><span class="direction">Previous</span><span class="title">C Interface</span></a><a class="next" href="constants.html"><span class="direction">Next</span><span class="title">Constants</span></a></footer></article></body></html>
